====== PHP RFC: New in initializers ======
  * Date: 2021-03-02
  * Author: Nikita Popov <nikic@php.net>
  * Status: Under Discussion
  * Proposed Version: PHP 8.1
  * Implementation: https://github.com/php/php-src/pull/6746

===== Introduction =====

This RFC proposes to allow use of ''new'' expressions inside initializer expressions, including for property and parameter default values.

Currently, code such as the following is not permitted:

<PHP>
class Test {
    public function __construct(
        private Logger $logger = new NullLogger,
    ) {}
}
</PHP>

Instead, it is necessary to write code along the following lines:

<PHP>
class Test {
    private Logger $logger;

    public function __construct(
        ?Logger $logger = null,
    ) {
        $this->logger = $logger ?? new NullLogger;
    }
}
</PHP>

This makes the actual default value less obvious (from an API contract perspective), and requires the use of a nullable argument.

This RFC proposes to relax this restriction and allow the use of ''new'' inside all initializer expressions.

===== Proposal =====

''new'' expressions are allowed as part of initializer expressions. It is possible to pass arguments to the constructor, including the use of named arguments:

<PHP>
// All allowed:
function test(
    $foo = new A,
    $bar = new B(1),
    $baz = new C(x: 2),
) {
}
</PHP>

The use of a dynamic or non-string class name is not allowed. The use of argument unpacking is not allowed. The use of unsupported expressions as arguments is not allowed. 

<PHP>
// All not allowed (compile-time error):
function test(
    $foo = new (CLASS_NAME_CONSTANT)(), // dynamic class name
    $bar = new A(...[]), // argument unpacking
    $baz = new B($abc), // unsupported constant expression
) {}
</PHP>

Affected positions are static variable intializers, constant and class constant initializers, static and non-static property intializers, parameter default values, as well as attribute arguments:

<PHP>
static $x = new Foo;

const C = new Foo;

#[AnAttribute(new Foo)]
class Test {
    const C = new Foo;
    public static $prop = new Foo;
    public $prop = new Foo;
}

function test($param = new Foo) {}
</PHP>

==== Order of evaluation ====

Initializer expressions could always contain side-effects through autoloaders or error handlers. However, support for ''new'' and the accompanying construct calls make side-effect a more first-class citizen in initializer expressions, so it is worthwhile to specify when and in what order they are evaluated. This depends on the type of initializer:

  * Static variable initializers are evaluated when control flow reaches the static variable declaration.
  * Global constant initializers are evaluated when control flow reaches the constant declaration.
  * Attribute arguments are evaluated from left to right on every call of ''ReflectionAttribute::getArguments()'' or ''ReflectionAttribute::newInstance()''.
  * Parameter default values are evaluated from left to right on every call to the function where the parameter is not explicitly passed.
  * Property default values are evaluated in order of declaration (with parent properties before properties declared in the class) when the object is instantiated. This happens before the constructor is invoked. If an exception is thrown during evaluation, the object destructor will not be invoked.
  * The time of evaluation for static properties and class constants is unspecified. Currently, all static property and class constant initializers are evaluated on certain first uses of the class. (TBD)

==== Recursion protection ====

If the evaluation of an object property default value results in recursion, an ''Error'' exception is thrown:

<PHP>
class Test {
    public $test = new Test;
}

new Test;
// Error: Trying to recursively instantiate Test while evaluating default value for Test::$test
</PHP>

===== Backward Incompatible Changes =====

None.

===== Future Scope =====

This RFC is narrow in that it only adds support for ''new'' expressions. However, it also lays the technical groundwork for supporting other expressions like calls.

===== Vote  =====

Yes/No.
