====== PHP RFC: Strict operators directive ======
  * Version: 0.1
  * Date: 2019-05-25
  * Author: Arnold Daniels, jasny@php.net
  * Status: Draft
  * Target Version: PHP 7.4
  * First Published at: http://wiki.php.net/rfc/strict_operators


===== Introduction =====
This RFC proposes the addition of a new optional per-file directive, ''declare(strict_operators=1);'', which makes all operators within a file have "strict" type-checking. Using operators with incompatible types with this directive throws a ''TypeError''.

The directive addresses all issues related to type juggling in a backward compatible way, following the same rationale as [[rfc:scalar_type_hints_v5|PHP RFC: Scalar Type Declarations]]. Please make sure you've read the //Background and Rationale// section of that RFC. 

//This RFC contains some examples of unexpected behavior but isn't intended as a complete list.//

==== Comparison operators ====
PHP supports two different types of comparison operators: The strict comparisons ''==='' and ''!=='', and the non-strict comparisons ''=='', ''!='', ''>'', ''>='', ''<'', ''%%<=%%'' and ''%%<=>%%''. The primary difference between them is that strict comparisons require both operands to be of the same type, and do not perform implicit type coercions.

The current dogma in the PHP world is that non-strict comparisons should **always** be avoided because their conversion semantics are rarely desirable and can easily lead to bugs or even security issues. This is an issue for the ''>'', ''>='', ''<'', ''%%<=%%'' and ''%%<=>%%'' operators as no strict alternative of these operators exist. Using the non-strict operators can lead to unexpected behavior.

=== Type juggling ===
Logic dictates that if ''a > b'' and ''b > c'' then ''a > c'' **must** be true. These elementry rules do not hold up due to type juggling.

<code php>
$a = '42';
$b = 10;
$c = '9 eur';

var_dump($a > $b); // true
var_dump($b > $c); // true
var_dump($a > $c); // false
</code>

=== Numeric string comparison ===
Non-strict comparison uses a "smart" comparison method that treats strings as numbers if they are numeric. This can lead to similar issues as with type juggling.

Using the `<=>` operator to ordering the values of an array, can lead to different results based on the initial state of the array.

<code php>
function sort_print(array $arr) {
  usort($arr, function($x, $y) { return $x <=> $y; });
  var_export($arr);
}

sort_print(['100', '5 eur', '62']); // array (0 => '100', 1 => '5 eur', 2 => '62')
sort_print(['100', '62', '5 eur']); // array (0 => '5 eur', 1 => '62', 2 => '100')
sort_print(['62', '100', '5 eur']); // array (0 => '62', 1 => '100', 2 => '5 eur')
</code>

=== Key order ===
Strict comparison requires that arrays have keys occurring in the same order, while non-strict comparison allows out-of-order keys.

To compare the values of two arrays in a strict way, while not concerned about the order requires ordering the array. This is especially problematic for arrays that can't be easily sorted like a 2-or-more dimensional array or array containing objects.

=== Key mismatch ===
Using the ''>'', ''>='', ''<'', ''%%<=%%'' and ''%%<=>%%'' operator on arrays or objects that don't have the same keys in the same order gives unexpected results.

In the following example ''$a'' is both larger and smaller than ''$b''

<code php>
$a = ['x' => 1, 'y' => 22];
$b = ['y' => 10, 'x' => 15];

var_dump($a > $b); // true
var_dump($b < $a); // true
</code>

Omitting keys and other variations yield completely different results, like both comparisons resulting in `false` or a situation similar to the one seen with type juggling, were ''a > b'' and ''b > c'', but ''a < c''.

==== Arithmetic and Incrementing operators ====
//TODO//

==== Bitwise Operators ====
//TODO//

===== Proposal =====
By default, all PHP files are in weak type-checking mode for operators. A new ''declare()'' directive is added, ''strict_operators'', which takes either ''1'' or ''0''. If ''1'', strict type-checking mode is used for operators in the the file. If ''0'', weak type-checking mode is used.

Similar to ''declare(strict_types=1)'', ''declare(strict_operators=1)'' directive **must** be the first statement in a file. If it appears anywhere else in the file it will generate a compiler error. Block mode is also explicitly disallowed (''declare(strict_operators=1);'' is the only allowed form). If the file contains both ''declare(strict_types=1)'' and ''declare(strict_operators=1)'', the order of these two directives doesn't matter.

==== Behaviour of strict type checks ====

A strictly type-checked operator call will throw an ''TypeError'' in case of a failure, and it follows strict type checking rules for scalar typed parameters, rather than the traditional weak type checking rules.

The strict type checking rules are quite straightforward: when the type of the value matches that specified by the type declaration it is accepted, otherwise it is not.

These strict type checking rules are used for userland scalar type declarations, and for extension and built-in PHP functions.

The one exception is that [[http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.2|widening primitive conversion]] is allowed for ''int'' to ''float''. This means that parameters that declare ''float'' can also accept ''int''.

<file php widening.php>
<?php
declare(strict_types=1);

function add(float $a, float $b): float {
    return $a + $b;
}

add(1, 2); // float(3)
</file>

In this case, we're passing an ''int'' to a function that accepts ''float''. The parameter is converted (widened) to float.

No other conversions are allowed.

===== Backward Incompatible Changes =====
None

===== Open Issues =====
To be discussed

===== Unaffected PHP Functionality =====
This RFC does not affect any functionality concerning explicit type casting. It's largely unaffected by other proposals like [[rfc:string_to_number_comparison|PHP RFC: Saner string to number comparisons]] that focus on improving type juggling at the cost of breaking BC, as none cover all issues as described in this RFC.

===== Proposed Voting Choices =====
Include these so readers know where you are heading and can discuss the proposed voting options.

===== Patches and Tests =====
A patch will be created by my after this RFC has been discussed.

===== Rejected Features =====
