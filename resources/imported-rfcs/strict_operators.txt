====== PHP RFC: Strict operators directive ======
  * Version: 0.1
  * Date: 2019-05-25
  * Author: Arnold Daniels, jasny@php.net
  * Status: Draft
  * Target Version: PHP 7.4
  * First Published at: http://wiki.php.net/rfc/strict_operators


===== Introduction =====
This RFC proposes the addition of a new optional per-file directive, ''declare(strict_operators=1);'', which makes all operators within a file have "strict" type-checking. Using operators with incompatible types with this directive throws a ''TypeError''.

The directive addresses all issues related to type juggling in a backward compatible way, following the same rationale as [[rfc:scalar_type_hints_v5|PHP RFC: Scalar Type Declarations]].

//This RFC contains some examples of unexpected behavior but isn't intended as a complete list.//

==== Comparison operators ====
PHP supports two different types of comparison operators: The strict comparisons ''==='' and ''!=='', and the non-strict comparisons ''=='', ''!='', ''>'', ''>='', ''<'', ''%%<=%%'' and ''%%<=>%%''. The primary difference between them is that strict comparisons require both operands to be of the same type, and do not perform implicit type coercions.

The current dogma in the PHP world is that non-strict comparisons should **always** be avoided because their conversion semantics are rarely desirable and can easily lead to bugs or even security issues. This is an issue for the ''>'', ''>='', ''<'', ''%%<=%%'' and ''%%<=>%%'' operators as no strict alternative of these operators exist. Using the non-strict operators can lead to unexpected behavior.

=== Type juggling ===
Logic dictates that if ''a > b'' and ''b > c'' then ''a > c'' **must** be true. These elementry rules do not hold up due to type juggling.

<code php>
$a = '42';
$b = 10;
$c = '9 eur';

var_dump($a > $b); // true
var_dump($b > $c); // true
var_dump($a > $c); // false
</code>

=== Numeric string comparison ===
Non-strict comparison uses a "smart" comparison method that treats strings as numbers if they are numeric. This can lead to similar issues as with type juggling.

Using the `<=>` operator to ordering the values of an array, can lead to different results based on the initial state of the array.

<code php>
function sort_print(array $arr) {
  usort($arr, function($x, $y) { return $x <=> $y; });
  var_export($arr);
}

sort_print(['100', '5 eur', '62']); // array (0 => '100', 1 => '5 eur', 2 => '62')
sort_print(['100', '62', '5 eur']); // array (0 => '5 eur', 1 => '62', 2 => '100')
sort_print(['62', '100', '5 eur']); // array (0 => '62', 1 => '100', 2 => '5 eur')
</code>

=== Key order ===
Strict comparison requires that arrays have keys occurring in the same order, while non-strict comparison allows out-of-order keys.

To compare the values of two arrays in a strict way, while not concerned about the order requires ordering the array. This is especially problematic for arrays that can't be easily sorted like a 2-or-more dimensional array or array containing objects.

=== Key mismatch ===
Using the ''>'', ''>='', ''<'', ''%%<=%%'' and ''%%<=>%%'' operator on arrays or objects that don't have the same keys in the same order gives unexpected results.

In the following example ''$a'' is both larger and smaller than ''$b''

<code php>
$a = ['x' => 1, 'y' => 22];
$b = ['y' => 10, 'x' => 15];

var_dump($a > $b); // true
var_dump($b < $a); // true
</code>

Omitting keys and other variations yield completely different results, like both comparisons resulting in `false` or a situation similar to the one seen with type juggling, were ''a > b'' and ''b > c'', but ''a < c''.

==== Arithmetic and Incrementing operators ====

TODO



===== Proposal =====
All the features and examples of the proposal.

To [[http://news.php.net/php.internals/66051|paraphrase Zeev Suraski]], explain hows the proposal brings substantial value to be considered
for inclusion in one of the world's most popular programming languages.

Remember that the RFC contents should be easily reusable in the PHP Documentation.

If applicable, you may wish to use the language specification as a reference.

===== Backward Incompatible Changes =====
None

===== Open Issues =====
Make sure there are no open issues when the vote starts!

===== Unaffected PHP Functionality =====
List existing areas/features of PHP that will not be changed by the RFC.

This helps avoid any ambiguity, shows that you have thought deeply about the RFC's impact, and helps reduces mail list noise.

===== Future Scope =====
This section details areas where the feature might be improved in future, but that are not currently proposed in this RFC.

===== Proposed Voting Choices =====
Include these so readers know where you are heading and can discuss the proposed voting options.

===== Patches and Tests =====
Links to any external patches and tests go here.

If there is no patch, make it clear who will create a patch, or whether a volunteer to help with implementation is needed.

Make it clear if the patch is intended to be the final patch, or is just a prototype.

For changes affecting the core language, you should also provide a patch for the language specification.

===== Implementation =====
After the project is implemented, this section should contain 
  - the version(s) it was merged into
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature
  - a link to the language specification section (if any)

===== References =====
Links to external references, discussions or RFCs

===== Rejected Features =====
Keep this updated with features that were discussed on the mail lists.