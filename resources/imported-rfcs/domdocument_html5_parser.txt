====== PHP RFC: DOMDocument HTML5 parser ======
  * Version: 0.1-dev
  * Date: 2023-08-12
  * Author: Niels Dossche, nielsdos@php.net
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/domdocument_html5_parser

===== Introduction =====

PHP's DOM extension supports loading HTML documents using the methods <php>DOMDocument::loadHTML</php> and <php>DOMDocument::loadHTMLFile</php>.
This uses libxml2's HTML parser under the hood to parse these documents into a libxml2 tree.
Unfortunately, this parser only supports HTML up to version 4.01. This is a problem, because HTML5 has become the de facto standard for websites over the past 10 years.
Introducing HTML5 parsing to PHP's DOM implementation is crucial for modernizing and enhancing PHP's capabilities in handling web content.

Using loadHTML(File) to process HTML5 content results in multiple parsing errors and incorrect document trees. These issues arise from changes in parsing rules between HTML4 and HTML5. Notably, the current parser does not recognize semantic HTML5 tags (e.g., main, article, section, ...) as valid tags. Then there's also problems with certain elements nestings not allowed in HTML4, but allowed in HTML5, causing incorrect document trees.
Another concern highlighted in the bug tracker is the handling of closing tags within script contexts. With the common practice of embedding HTML within JavaScript, HTML4 parsers encounter problems when encountering a closing tag within a JavaScript variable. Consequently, parsing through loadHTML(File) leads to the production of inaccurate documents. HTML5 parsers, however, do not face this challenge. The list of issues goes on and on.

There's an open issue at the libxml2 bugtracker to add HTML5 parsing support: https://gitlab.gnome.org/GNOME/libxml2/-/issues/211.
However, it seems like this won't happen anytime soon.
This RFC proposes leveraging an alternative HTML5 parser to create the libxml2 tree. This is done with the introduction of two new methods: <php>DOMDocument::loadHTML5(string $html)</php> and <php>DOMDocument::loadHTML5File(string $path)</php>. This parser seamlessly integrates with the DOM extension, ensuring compatibility for all existing code and third-party extensions.

===== Proposal =====

The most important requirement is that the HTML5 parser must integrate seamlessly with the DOM extension. This means that using the HTML5 parser must be a simple drop-in replacement. You must still be able to use the methods you normally use to traverse and manipulate DOMDocuments without caveats. We propose the introduction of two new methods <php>DOMDocument::loadHTML5(string $html)</php> and <php>DOMDocument::loadHTML5File(string $path)</php> instead of replacing the existing ones. This ensures full backwards compatibility for applications that actually work with legacy HTML4 documents, and want the HTML4 behaviour (with all its peculiarities).

Note that unlike the existing load methods, these do not take an options parameter. The options for the existing load methods change the way the parser behaves (e.g. not adding implied html & body elements). These options deviate from the HTML spec. I will stick to the spec and therefore not introduce such option parameters. The only option that //might// be useful is LIBXML_NOERROR, which disables error reporting, but you can achieve this in other ways.

==== Background ====

The DOM extensions supports both XML and HTML documents. It's built heavily upon libxml2's APIs and data structures, just like all XML-related PHP extensions within php-src. This is great for interopability (e.g. with simplexml and xsl).
Third-party extensions also use libxml2 APIs. For example, the xmldiff PECL extension peeks into the internals of DOMDocument to grab the libxml2 data structures and compare them.
It is not possible to switch away from the libxml2 library as the underlying basis for the DOM extension because of the major BC break.

==== Approach ====

Parsing an HTML document via an HTML parser results in a document tree. The HTML nodes are structs on the heap as created by said parser. In order to integrate this into our DOM extension, these nodes need to be converted into libxml2 nodes.

The conversion is fairly straight-forward. We perform a depth-first search on the tree, checking the node type and creating the corresponding libxml2 node. The search is performed using iteration instead of recursion to prevent stack overflows with deep trees. After this process is done, we throw away the old tree and are left with only the libxml2 tree. This libxml2 tree is then used in the DOM extension, just //as if// it had come from libxml2's parser itself.

==== Choosing an HTML5 parser ====

First, we have to choose a suitable HTML5 parser. It should be spec-compliant, heavily tested, and fast.
I propose to use [[https://github.com/lexbor/lexbor|Lexbor]]. According to its README, it satisfies our requirements. Furthermore, it has bindings for Elixir, Crystal, Python, D, and Ruby. This shows that it has been used in practice in other serious projects.

It is fully written in C99. That's ideal, because PHP is also using the C99 standard.
One small complication is that this library is not available in package managers for almost all distros. Therefore, I propose to bundle it with PHP. This also gives us the freedom to incorporate a patch to expose the line and column numbers of HTML nodes such that the error messages are richer and the <php>DOMNode::getLineNo()</php> function will work properly.
Bundling a library with PHP is not unprecedented, PHP bundles e.g. pcre2lib, gd, libmagic already.

Lexbor also supports overriding the allocation routines. Therefore, we can make it work with PHP's memory limit.

=== Alternative considered HTML5 parsers ===

Lexbor is one of several HTML5 parsers available. During my investigation, I considered two alternatives:

  * Gumbo: https://github.com/google/gumbo-parser.\\ A relatively well-known HTML5 parser developed by Google in C.\\ Unfortunately, it has been unmaintained since 2016, as indicated in its README, making it unsuitable for use.
  * html5ever: https://github.com/servo/html5ever.\\ This is Servo's HTML5 parser, written in Rust.\\ I have implemented a [[https://github.com/nielsdos/html5ever-libxml2-bridge/blob/main/src/lib.rs|proof-of-concept conversion]] from html5ever to libxml2, and a [[https://github.com/nielsdos/php-src/commits/dom-bridge|proof-of-concept integration with PHP]] on my fork.\\ \\ I decided to not go with this option for a few reasons.\\ * Firstly, while writing it in Rust would enhance memory safety (especially for untrusted documents), introducing Rust as an additional dependency for PHP adds extra complexity. PHP's default-enabled extensions can currently be built using only C, but if we go this route this would change.\\ * Secondly, the implementation is incomplete, primarily functioning effectively with UTF-8 documents. Support for other text encodings is lacking, necessitating a prior conversion. Moreover, reparsing logic for character encoding meta tags is absent.\\ * Lastly, observing the commit activity raises doubts about the ongoing activity of this project.

Considering these factors, I opted against using the above two. Lexbor emerged as the better choice after this investigation.

==== Error handling ====

When parsing a document, potential parse errors may occur. With the existing load methods of DOMDocument, a parser error results in an E_WARNING by default. //However//, you can use <php>libxml_use_internal_errors(true)</php> to store the errors inside an array. In this case, no warning will be generated and the parse errors may be inspected using <php>libxml_get_errors()</php> and <php>libxml_get_last_error()</php>.

The naming of these methods is a bit unfortunate. These methods have become almost synonymous with handling DOMDocument parse errors.
To offer a seamless HTML5 parser replacement, my current implementation follows the same error handling as described above.
That means, by default we will emit an E_WARNING, and if <php>libxml_use_internal_errors(true)</php> is used then the errors will be stored, and can be retrieved in the same way as described above. This may seem unconventional since the errors originate from Lexbor rather than libxml2.

The alternative would be to introduce methods specific to getting the errors from the HTML5 parser.
However, I do not believe that's a good idea because:
  - The users of these new parsing methods don't actually know that it uses Lexbor. So they expect the error handling behaviour to be the same as the existing ones.
  - The proposed approach makes it easier to use as a drop-in replacement.
  - If libxml2 ever introduces its own HTML5 parser, we can drop Lexbor and nothing changes for the end user w.r.t. error handling.

==== External entity loader ====

XML supports something called "external entities". This will load data from an external source into the current document (if enabled). Because you might want to customise the external entity handling, there's a <php>libxml_set_external_entity_loader(?callable $resolver_function)</php> function to setup a custom "resolver". This "resolver" returns either a path, a stream resource, or null. In the former two cases, the entity will be loaded from the path or stream. In the latter case, the loading will be blocked.

This interacts a bit surprisingly with the existing loadHTMLFile method. You can observe this here: https://3v4l.org/rJTTc.
The loadHTMLFile method considers loading the file also as loading an external entity, hence the "resolver" is invoked.

There's a (deprecated) similar function <php>libxml_disable_entity_loader(bool $disable)</php> that completely disables loading external entities.
This function has been perceived as broken by the community due to it blocking loading anything that's not coming from a string. See https://github.com/php/php-src/pull/5867 for more details.
I don't know how the community perceives the interaction between loadHTMLFile and <php>libxml_set_external_entity_loader</php>.

Unlike XML, HTML5 does not have a concept of external entities.
The question I have is whether <php>libxml_set_external_entity_loader</php> should affect loadHTML5File in the same way as it does loadHTMLFile.
The advantage would be consistency, but I don't know if this is what the community wants.
I'm leaving this for a secondary vote for the community to decide on.

==== Parsing benchmarks ====

You might wonder about the performance impact of the tree conversion. In particular, how does the performance of <php>DOMDocument::loadHTML5()</php> compare with the performance of <php>DOMDocument::loadHTML()</php>? Note that the latter method doesn't follow the HTML5 rules, but it does give an indication about the performance.

=== Experimental setup ===

I downloaded the homepages of the top 50 websites (excluding blank pages and NSFW pages) as listed according to [[https://www.similarweb.com/top-websites/|similarweb]].
I created a PHP script that invokes each parser 1000 times. I ran the experiment on an i7-4790 with 16GiB RAM.

=== Results ===

The following graph shows the results. The blue bar shows the parse time in seconds for loadHTML, and the orange bar does so for loadHTML5.
The black vertical line indicates the minimum & maximum measured times for each bar.
First of all, some measurements on the far left are very flow. That's because those sites primarily generate their content using JavaScript. Hence, there are not many HTML nodes in the document.
Second, we can see that loadHTML5 is consistently faster than the existing loadHTML method, despite having to do a conversion.

Based on this limited experiment, I conclude that the performance is acceptable.

{{:rfc:domdocument_html5_parser:bench.png?400|}}

==== Effect on binary size ====

Incorporating any library will increase the binary size of the DOM extension. The Lexbor library is fairly big.
The reality is however that a lot of the library is not actually used.
Diving into each source file and ripping out functions that are not used is time-consuming and difficult however. Furthermore, this would make syncing upstream changes also more difficult.

^ before/after        ^ text       ^ data       ^ total       ^
| before this patch   | 174.78 KiB | 15.18 KiB  | 192.24 KiB  |
| after this patch    | 738.03 KiB | 584.63 KiB | 1325.12 KiB |

The large data section is due to the large lookup tables for text encoding handling.

==== Completely alternative solution ====

This section will list alternative solutions that I considered, but ultimately rejected.

=== Alternative DOM extension ===

One might wonder why we don't just create a new DOM extension, based on another library, with HTML5 support.
There are a couple of reasons:
  - Interopability problems with other extensions (both first-party and third-party).
  - Fragmentation of userland.
  - Additional maintenance work and complexity.
  - I don't have time to do build this.

===== Backward Incompatible Changes =====

This RFC adds two new methods, but the existing methods for loading HTML4 documents remain as-is.
Therefore, this feature is purely opt-in, and there is no BC break.

===== Proposed PHP Version(s) =====

Next PHP 8.x. At the time of writing this is PHP 8.4.

===== RFC Impact =====
==== To SAPIs ====

None.

==== To Existing Extensions ====

Only ext/dom is affected.

==== To Opcache ====

No impact.

==== New Constants ====

None.

==== php.ini Defaults ====

None.

===== Open Issues =====

None yet.

===== Unaffected PHP Functionality =====

Everything outside of ext/dom is unaffected.

===== Future Scope =====

This section details areas where the feature might be improved in future, but that are not currently proposed in this RFC.

The Lexbor library also includes functionality outside of HTML parsing that we do not use right now.
  - It contains a CSS selector parser, that transforms the expression into a list of actions we must follow to find the elements. This could make implementing querySelector(All) feasible.
  - It contains a WHATWG-compliant URL parser, which might be useful for extending PHP's URL pasing capabilities.

===== Proposed Voting Choices =====

There are two votes:
  - Whether <php>DOMDocument::loadHTML5(string $html)</php> and <php>DOMDocument::loadHTML5File(string $path)</php> should be introduced. This requires 2/3 majority.
  - Whether loadHTML5File should respect the resolver set by <php>libxml_set_external_entity_loader</php>. This requires 50% majority.

===== Patches and Tests =====

https://github.com/nielsdos/php-src/pull/32

This does not yet include the external entity loader support.
I want to wait until we have the results of the secondary vote before I spend time coding this part.

===== Implementation =====
After the project is implemented, this section should contain 
  - the version(s) it was merged into
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature
  - a link to the language specification section (if any)

===== References =====

None yet.

===== Rejected Features =====

None yet.
