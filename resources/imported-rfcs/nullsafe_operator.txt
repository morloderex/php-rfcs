====== PHP RFC: Nullsafe operator ======

  * Date: 2020-05-25
  * Author: Ilija Tovilo, tovilo.ilija@gmail.com
  * Status: Under discussion
  * Target Version: PHP 8.0
  * Implementation: https://github.com/php/php-src/pull/5619
  * Supersedes: https://wiki.php.net/rfc/nullsafe_calls

===== Introduction =====
This RFC proposes a new operator nullsafe operator ''?->'' with full short-ciruiting.

===== Proposal =====
It is fairly common to only want to call a method or fetch a property on the result of an expression it it is not ''null''. This is usually done with ternary expressions and temporary variables.

<code php>
$bar = $foo !== null ? $foo->bar() : null;
$baz = $bar !== null ? $bar->baz : null;
</code>

With the nullsafe operator ''?->'' this code could instead be expressed like this:

<code php>
$baz = $foo?->bar()?->baz;
</code>

When the left hand side of the operator evaluates to ''null'' the execution of the entire chain will stop and evalute to ''null''. When it not ''null'' it will behave exactly like the normal ''->'' operator.

==== Short circuiting ====
This RFC proposes full short circuiting. This means when the evaluation of one element in the chain fails the execution of the entire chain is aborted. The following elements are considert part of the chain.

  * Array offset (''[]'')
  * Property access (''->'')
  * Nullsafe property access (''?->'')
  * Static property access (''::'')
  * Method call (''->'')
  * Nullsafe method call (''?->'')
  * Static method call (''::'')
  * Left hand side of an assignment (''='', ''+='', ''??='', ''= &'', etc.)
  * Post/pre increment (''++'', ''--'')

Chains are automatically inferred. Using ''?->'' in the left hand side of an assignment will cause them to be nested. Only the closest chain will terminate. The following examples will try to illustrate.

<code php>
     $foo?->bar = $a?->b()->c()?->d()['e'];
// 1 -------------------------------------
// 2              ------------------------
// If $foo is null chain 1 is aborted (assignment is not executed)
// If `$a` or `...->c()` are null chain 2 is aborted ($foo->bar is set to null)

     ++$foo?->bar;
// 1 ------------
// Skips the pre inecrement if ''$foo'' is null
// Otherwise skips the assignment and evaluates to null
</code>

===== Backward Incompatible Changes =====
There are no backward incompatible changes in this RFC.

===== Future Scope =====
Since PHP 7.4 a notice is emitted when accessing an offset on null (''null["foo"]''). Thus the operator ''?[]'' could also be useful (''$foo?["foo"]''). Unfortunately, this code introduces a parser ambiguity because of the ternary operator and short array syntax (''$foo?["foo"]:["bar"]''). Because of this complication this operator is not part of this RFC.

===== Vote =====
...
