====== PHP RFC: Support object type in BCMath ======
  * Version: 0.6
  * Date: 2024-03-24
  * Author: Saki Takamachi, saki@php.net
  * Status: Discussion
  * First Published at: https://wiki.php.net/rfc/support_object_type_in_bcmath

===== Introduction =====
BCMath currently only supports procedural functionality and does not support object types. Object-based programming is mainstream these days, so it's a bit outdated from that perspective. Also, the GMP extension, which is likely to have similar needs to BCMath, already supports object types.

Of course, it is also possible to treat BCMath like an object if you devise some ideas in userland. However, things like operator overloading cannot be implemented in userland.

===== Proposal =====
This RFC proposes support for object types in BCMath. Please take a look at the usage example first.

<code>
use BcMath\Number;

$num = new Number('1');
$num2 = new Number('2');
$result = $num + $num2;

$result->value; // '3'
var_dump($num > $num2); // false
</code>

Operator overloading allows you to treat objects as if they were computing or comparing primitive values. Also, for reasons explained later, it supports not only calculations using operators, but also calculations using methods.

The following example is equivalent to the above example.

<code>
use BcMath\Number;

$num = new Number('1');
$num2 = new Number('2');
$result = $num->add($num2);

$result->value; // '3'
var_dump($num->gt($num2)); // false
</code>

`new BCMath()` is difficult to understand what "BCMath object" specifically refers to, so we will use "Number".

(Updated 03/26)
One important thing to note first: existing global settings related to scale are not used by Number. Therefore, **no matter what is set in the global settings, it has no effect on the behavior of Number**.

==== namespace ====
(updated 03/27)
Use namespace "BCMath" for this class according to the following RFC:
https://wiki.php.net/rfc/namespaces_in_bundled_extensions

In the RFC example, the symbols use common names, so I follow suit and use the symbol "Number".

Therefore, the fully qualified name of the class would be:
<code>
BCMath\Number;
</code>

==== It is immutable ====
There is a concept called "value object" that is often seen in domain-driven design, etc., and Number is exactly what should be treated as a value object. That is, the object must be immutable.

No matter what we do, the original object remains unchanged and always returns a new object.

==== Stringable ====
In addition to referencing the value property to obtain the value of Number, you can also obtain the value by casting to the string type.
<code>
use BcMath\Number;

$num = new Number('1');
var_dump((string) $num); // '1'
</code>

==== Constructor ====

The constructor signature is:
<code>
public function __construct(string|int $num, int $maxExpansionScale = 10, int $roundMode = PHP_ROUND_TOWARD_ZERO) {}
</code>

Since there is no need to consider errors for integers in the range that can be represented by ints, it is reasonable to accept ints in the constructor.

(Updated 04/04)
**The scale of the value is always implicitly calculated from the given $num.**

In many cases, Number Class can automatically calculate the scale of the calculation result. However, in three cases, when using a div, sqrt and when the pow's exporent is a negative value, the scale cannot be determined automatically if the value is not divisible. In some cases, calculations need to continue indefinitely. This is not reasonable, so in these three cases the calculation must be stopped midway.

`$maxExpansionScale` specifies the maximum scale of the result in these three cases. However, please note that this is a relative value. Adds the value specified by `$maxExpansionScale` to the implicit scale of the left operand and uses it as the maximum scale value in the calculation.

Since sqrt doesn't involve operator overloading, you can also require scale in the method argument. However, from a consistency point of view, I will use the same specifications as div etc.

And `$roundMode` is only used in these three cases as well. Specifies how to round the value when the calculation is stopped midway due to the maximum scale. The default value is `PHP_ROUND_TOWARD_ZERO`, which has the same behavior as the BCMath function.

powmod has some restrictions on the arguments, so it will not prevent from automatically calculating the scale.

**No global settings are used.**

See code example.
<code>
use BcMath\Number;

$num = new Number('2'); // value is '2'
$num->div('3'); // value is '0.6666666666', max scale when div is 0 + 10 = 10

$num = new Number('1'); // value is '1'
$num->div('2'); // value is '0.5', max scale when div is 0 + 10 = 10, but the result is less than the maximum scale, so it becomes 1

$num = new Number('2', 5, PHP_ROUND_HALF_UP); // value is '2'
$num->div('3'); // value is '0.66667', max scale when div is 0 + 5 = 10, round mode is PHP_ROUND_HALF_UP

$num = new Number('1.2345', 2); // value is '1.2345'
$num / 7; // value is '0.176357', max scale when div is 4 + 2 = 6
</code>

In this way, by receiving several option settings in the constructor, we eliminate the differences between calculations using operator overloads and methods as much as possible.

==== Poperties ====
(03/26 updated) This class has properties "value" and "scale". Both are read-only.

<code>
namespace BcMath;

class Number
{
    public readonly string $value;
    public readonly int $scale;
}
</code>

==== Methods ====
(updated 3/27)
(updated 4/4)
Only div, pow, and sqrt accept $maxExpansionScale as an option. This means the same thing as $maxExpansionScale in the constructor, and allows you to use any $maxExpansionScale when calculating rather than the one from the constructor.

Also, since it is not ideal for users to customize operator overloads, all computational methods should be final. Then, from a consistency perspective and because there is no common use case to override Number's methods to change their behavior, we make all methods final. In reality, operator overload calculations and method calculations follow different processing paths, so users cannot customize the behavior of operators via methods, but from the perspective of consistency of behavior, they should be final.

The Number class itself should be extensible. By doing so, the user can use the NumberChild class by adding any method. This is a very common use case, as BCMath's main use case is money calculations.

In addition to calculations using operators, Number also supports calculations using methods. 
Basically, it corresponds to the bcXXX functions. See stub.

<code>
namespace BCMath;

class Number
{
    public function __construct(string|int $num, int $maxExpansionScale = 10, int $roundMode = PHP_ROUND_TOWARD_ZERO) {}

    final public function add(Number|string|int $num): Number {}

    final public function sub(Number|string|int $num): Number {}

    final public function mul(Number|string|int $num): Number {}

    final public function div(Number|string|int $num, ?int $maxExpansionScale = null): Number {}

    final public function mod(Number|string|int $num): Number {}

    final public function powmod(Number|string|int $exponent, string $modulus): Number {}

    final public function pow(Number|string|int $exponent, ?int $maxExpansionScale = null): Number {}

    final public function sqrt(?int $maxExpansionScale = null): Number {}

    final public function comp(Number|string|int $num): int {}

    final public function floor(): Number {}

    final public function ceil(): Number {}

    final public function round(int $precision = 0, int $mode = PHP_ROUND_HALF_UP): Number {}

    final public function eq(Number|string|int $num): bool {}

    final public function gt(Number|string|int $num): bool {}

    final public function gte(Number|string|int $num): bool {}

    final public function lt(Number|string|int $num): bool {}

    final public function lte(Number|string|int $num): bool {}
  
    final puclic function format(?int $scale = null, string $decimalSeparator = '.', string $thousandsSeparator = ''): string {}

    final public function with(int $maxExpansionScale, int $roundMode): Number {}

    final public function withMaxExpansionScale(int $maxExpansionScale): Number {}
    
    final public function withRoundMode(int $roundMode): Number {}
    
    final public function __toString(): string {}
}
</code>

The bcXXX functions accept numbers to calculate as string, while Number accepts Number instance, string, and int.

=== Major difference from bcXXX functions ===
I think the differences in arguments are easy to understand, so I will omit them.

**The notable difference here is "behavior when $scale is not specified".**

For example, if omit $scale in bcadd, it will look like this:
<code>
bcadd('1.23', '2.111'); // Global settings are used. If set to 0, '3' is returned.
</code>

With Number it works like this:
<code>
use BcMath\Number;

$num = new Number('1.23');
$num2 = new Number('2.111');

// If scale is omitted, the larger scale of $num and $num2 is used.
// In this example, the scale of $num2 is larger, so the calculation is done with scale = 3.
$result = $num->add($num2); // A Number containing '3.341' will be returned.
</code>

In this way, **the calculation of Number does not use the global setting $scale.**

If $num2 is not Number, the following behavior:
<code>
use BcMath\Number;

// $num2 is int
$num->add(4); // Equivalent to "$num->add(new Number('4'));"

// $num2 is string
$num->add('2.3355'); // Equivalent to "$num->add(new Number('2.3355'));"
</code>

(updated 3/27)
(updated 4/4)
When calculating, the value is always implicitly converted to the bc_num structure that Number has internally.

=== Comparison method ===

These are equivalent to the following operators:
^ method ^ operator ^
| comp | <=> |
| eq | == |
| gt | > |
| gte | >= |
| lt | < |
| lte | <= |

=== format ===
(updated 4/4)
This behaves similar to number_format. However, the arguments are slightly different. See code example:

<code>
use BcMath\Number;

$num = new Number('123456.789'); // round mode is  PHP_ROUND_TOWARD_ZERO

$num->format(); // '123456.789'
$num->format(1); // '123456.7'
$num->format(1, '.', ','); // '123,456.7'

$num->format(2, ',', ' '); // '123 456,78' french notation

$num2 = new Number('123456.789', 10, PHP_ROUND_HALF_UP);
$num->format(); // '123456.789'
$num->format(1); // '123456.8'
$num->format(2, '.', ','); // '123,456.79'
</code>

=== with, withMaxExpansionScale, withRoundMode ===
(updated 4/4)
Each generates and returns a new instance with the constructor option values reset.
<code>
use BcMath\Number;

$num = new Number('1.23', 5, PHP_ROUND_HALF_UP);
$newNum = $num->withMaxExpansionScale(2); // same as new Number('1.23', 2, PHP_ROUND_HALF_UP)
$newNum = $num->withRoundMode(PHP_ROUND_HALF_EVEN); // same as new Number('1.23', 5, PHP_ROUND_HALF_EVEN)
$newNum = $num->with(8, PHP_ROUND_HALF_ODD); // same as new Number('1.23', 8, PHP_ROUND_HALF_ODD)
</code>

==== Operator overload ====

See the table below for supported operators.

^ type ^ support ^
| comparison | yes |
| add | yes |
| sub | yes |
| mul | yes |
| div | yes |
| mod | yes |
| pow | yes |
| bit shift | no |
| bit wise | no |

The calculation with the operator is equivalent to not specifying scale in the method.

Therefore, calculations such as the following are allowed:

(updated 3/27)
<code>
use BcMath\Number;

$num = new Number('1.23');
$result = $num + 2;
$result->value; // '3.23'
$result->scale; // 2

$num = new Number('1.23');
$result = $num + '1.23456';
$result->value; // '2.46456'
$result->scale; // 5
</code>

=== Increment and decrement ===

Incrementing and decrementing Number behaves similarly to GMP objects.

<code>
use BcMath\Number;

$num = new Number('1.23', 2);
$numA = $num;

$num++; // Here, $num will change to a new object.

$num->value; // '2.23'
$numA->value; // '1.23'
</code>

==== Exception ====
There are several times when you should throw an exception, such as division by 0. This is the same as the existing bcXXX functions. Therefore, we will not prepare a new exception class specifically for Number.

===== Backward Incompatible Changes =====
This is a new feature, so it doesn't break anything that already exists. The only concern is whether there is already a library that defines a class called "Number" without a namespace.

See search results on GitHub.
https://github.com/search?type=code&auto_enroll=true&q=%22new+Number%28%22+language%3APHP+

There's only one result, and it's my repository, so there's nothing wrong with it.

===== Proposed PHP Version(s) =====
I suggest implementing it in the next minor version (currently 8.4) or the next major version (currently 9.x).
Personally I'd like 8.4, but it might be worth a second vote on this. (Before that, it would be helpful if we could discuss this.)

===== RFC Impact =====
==== To SAPIs ====
Add BCMath\Number to all environments.

==== To Existing Extensions ====
Only BCMath is affected.

==== To Opcache ====
None;

==== New Constants ====
None.

==== php.ini Defaults ====
None.

===== Open Issues =====
None.

===== Unaffected PHP Functionality =====
There is no effect on anything other than BCMath.

===== Future Scope =====
None;

===== Proposed Voting Choices =====
There is a yes/no choice whether to accept this RFC and requires a 2/3 majority vote to be accepted.

(There may be a second vote on which PHP version to release.)

===== Patches and Tests =====
Prototype:
https://github.com/php/php-src/pull/13741

Not all features have been implemented yet.

===== Implementation =====
It's still a prototype.

===== References =====
https://externals.io/message/122651 (Mailing list thread before creating RFC)

===== Rejected Features =====
None;