====== PHP RFC: Support object type in BCMath ======
  * Version: 0.4
  * Date: 2024-03-24
  * Author: Saki Takamachi, saki@php.net
  * Status: Discussion
  * First Published at: https://wiki.php.net/rfc/support_object_type_in_bcmath

===== Introduction =====
BCMath currently only supports procedural functionality and does not support object types. Object-based programming is mainstream these days, so it's a bit outdated from that perspective. Also, the GMP extension, which is likely to have similar needs to BCMath, already supports object types.

Of course, it is also possible to treat BCMath like an object if you devise some ideas in userland. However, things like operator overloading cannot be implemented in userland.

===== Proposal =====
This RFC proposes support for object types in BCMath. Please take a look at the usage example first.

<code>
use BcMath\Number;

$num = new Number('1');
$num2 = new Number('2');
$result = $num + $num2;

$result->value; // '3'
var_dump($num > $num2); // false
</code>

Operator overloading allows you to treat objects as if they were computing or comparing primitive values. Also, for reasons explained later, it supports not only calculations using operators, but also calculations using methods.

The following example is equivalent to the above example.

<code>
use BcMath\Number;

$num = new Number('1');
$num2 = new Number('2');
$result = $num->add($num2);

$result->value; // '3'
var_dump($num->gt($num2)); // false
</code>

`new BCMath()` is difficult to understand what "BCMath object" specifically refers to, so we will use "Number".

(Updated 03/26)
One important thing to note first: existing global settings related to scale are not used by Number. Therefore, **no matter what is set in the global settings, it has no effect on the behavior of Number**.

==== namespace ====
(updated 03/27)
Use namespace "BCMath" for this class according to the following RFC:
https://wiki.php.net/rfc/namespaces_in_bundled_extensions

In the RFC example, the symbols use common names, so I follow suit and use the symbol "Number".

Therefore, the fully qualified name of the class would be:
<code>
BCMath\Number;
</code>

==== It is immutable ====
There is a concept called "value object" that is often seen in domain-driven design, etc., and Number is exactly what should be treated as a value object. That is, the object must be immutable.

No matter what we do, the original object remains unchanged and always returns a new object.

==== Stringable ====
In addition to referencing the value property to obtain the value of Number, you can also obtain the value by casting to the string type.
<code>
use BcMath\Number;

$num = new Number('1');
var_dump((string) $num); // '1'
</code>

==== Constructor ====

The constructor signature is:
<code>
public function __construct(string|int $num, ?int $scale = null) {}
</code>

Since there is no need to consider errors for integers in the range that can be represented by ints, it is reasonable to accept ints in the constructor.

$scale is optional. If omitted, $scale will be automatically set so that $num will fit all the way to the end. **No global settings are used.** Adjusts the digits in $num based on the scale set in the constructor. See code example.
<code>
use BcMath\Number;

$num = new Number('1.23456789', 4);
$num->value; // '1.2345'

$num2 = new Number('1', 4);
$num2->value; // '1.0000'

$num3 = new Number('1.23456789');
$num3->value; // '1.23456789'
</code>

At this point, the digits are already adjusted.

==== Poperties ====
(03/26 updated) This class has properties "value" and "scale". Both are read-only.

<code>
namespace BcMath;

class Number
{
    public readonly string $value;
    public readonly int $scale;
}
</code>

==== Methods ====
In addition to calculations using operators, Number also supports calculations using methods. This is because BcMath is arbitrary precision mathematics, so the use of scales must be taken into account.

We cannot specify scale when calculating using operators, so if want to specify scale, use a method to calculate it.

Basically, it corresponds to the bcXXX functions. See stub.

<code>
namespace BCMath;

class Number
{
    public function __construct(string|int $num, ?int $scale = null) {}

    public function add(Number|string|int $num, ?int $scale = null): Number {}

    public function sub(Number|string|int $num, ?int $scale = null): Number {}

    public function mul(Number|string|int $num, ?int $scale = null): Number {}

    public function div(Number|string|int $num, ?int $scale = null): Number {}

    public function mod(Number|string|int $num, ?int $scale = null): Number {}

    public function powmod(Number|string|int $exponent, string $modulus, ?int $scale = null): Number {}

    public function pow(Number|string|int $exponent, ?int $scale = null): Number {}

    public function sqrt(?int $scale = null): Number {}

    public function comp(Number|string|int $num, ?int $scale = null): int {}

    public function floor(): Number {}

    public function ceil(): Number {}

    public function round(int $precision = 0, int $mode = PHP_ROUND_HALF_UP): Number {}

    public function eq(Number|string|int $num, ?int $scale = null): bool {}

    public function gt(Number|string|int $num, ?int $scale = null): bool {}

    public function gte(Number|string|int $num, ?int $scale = null): bool {}

    public function lt(Number|string|int $num, ?int $scale = null): bool {}

    public function lte(Number|string|int $num, ?int $scale = null): bool {}

    public function withScale(int $scale): Number {}
}
</code>

The bcXXX functions accept numbers to calculate as string, while Number accepts Number instance, string, and int.

=== Major difference from bcXXX functions ===
I think the differences in arguments are easy to understand, so I will omit them.

**The notable difference here is "behavior when $scale is not specified".**

For example, if omit $scale in bcadd, it will look like this:
<code>
bcadd('1.23', '2.111'); // Global settings are used. If set to 0, '3' is returned.
</code>

With Number it works like this:
<code>
use BcMath\Number;

$num = new Number('1.23', 2);
$num2 = new Number('2.111', 3);

// If scale is omitted, the larger scale of $num and $num2 is used.
// In this example, the scale of $num2 is larger, so the calculation is done with $scale = 3.
$result = $num->add($num2); // A Number containing '3.341' will be returned.
</code>

In this way, **the calculation of Number does not use the global setting $scale.**

If $num2 is not Number, the following behavior:
<code>
use BcMath\Number;

// $num2 is int
$num->add(4); // Equivalent to "$num->add(new Number('4'));"

// $num2 is string
$num->add('2.3355'); // Equivalent to "$num->add(new Number('2.3355'));"
</code>

=== Comparison method ===

These are equivalent to the following operators:
^ method ^ operator ^
| comp | <=> |
| eq | == |
| gt | > |
| gte | >= |
| lt | < |
| lte | <= |

=== withScale ===

withScale() sets the new scale. However, note that Number is immutable, so a new instance will be returned.
<code>
use BcMath\Number;

$num = new Number('1.23', 2);
$newNum = $num->withScale(4);

$num->scale; // 2
$newNum->scale; // 4

$num->value; // '1.23'
$newNum->value; // '1.2300'
</code>

==== Operator overload ====

See the table below for supported operators.

^ type ^ support ^
| comparison | yes |
| add | yes |
| sub | yes |
| mul | yes |
| div | yes |
| mod | yes |
| pow | yes |
| bit shift | no |
| bit wise | no |

The calculation with the operator is equivalent to not specifying scale in the method.

Therefore, calculations such as the following are allowed:

<code>
use BcMath\Number;

$num = new Number('1.23', 2);
$result = $num + 2;
$result->value; // '3.23'

$num = new Number('1.23', 2);
$result = $num + '1.23456';
$result->value; // '2.46456'
$result->scale; // '5'
</code>

=== Increment and decrement ===

Incrementing and decrementing Number behaves similarly to GMP objects.

<code>
use BcMath\Number;

$num = new Number('1.23', 2);
$numA = $num;

$num++; // Here, $num will change to a new object.

$num->value; // '2.23'
$numA->value; // '1.23'
</code>

==== Exception ====
There are several times when you should throw an exception, such as division by 0. This is the same as the existing bcXXX functions. Therefore, we will not prepare a new exception class specifically for Number.

===== Backward Incompatible Changes =====
This is a new feature, so it doesn't break anything that already exists. The only concern is whether there is already a library that defines a class called "Number" without a namespace.

See search results on GitHub.
https://github.com/search?type=code&auto_enroll=true&q=%22new+Number%28%22+language%3APHP+

There's only one result, and it's my repository, so there's nothing wrong with it.

===== Proposed PHP Version(s) =====
I suggest implementing it in the next minor version (currently 8.4) or the next major version (currently 9.x).
Personally I'd like 8.4, but it might be worth a second vote on this. (Before that, it would be helpful if we could discuss this.)

===== RFC Impact =====
==== To SAPIs ====
Add BCMath\Number to all environments.

==== To Existing Extensions ====
Only BCMath is affected.

==== To Opcache ====
None;

==== New Constants ====
None.

==== php.ini Defaults ====
None.

===== Open Issues =====
None.

===== Unaffected PHP Functionality =====
There is no effect on anything other than BCMath.

===== Future Scope =====
None;

===== Proposed Voting Choices =====
There is a yes/no choice whether to accept this RFC and requires a 2/3 majority vote to be accepted.

(There may be a second vote on which PHP version to release.)

===== Patches and Tests =====
Prototype:
https://github.com/php/php-src/pull/13741

Not all features have been implemented yet.

===== Implementation =====
It's still a prototype.

===== References =====
https://externals.io/message/122651 (Mailing list thread before creating RFC)

===== Rejected Features =====
None;