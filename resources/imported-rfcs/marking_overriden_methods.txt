====== PHP RFC: Marking overridden methods (#[\Override]) ======
  * Version: 1.0
  * Date: 2023-05-06
  * Author: Tim DÃ¼sterhus, timwolla@php.net
  * Status: Draft
  * First Published at: https://wiki.php.net/rfc/marking_overriden_methods

===== Introduction =====
The elevator pitch for the RFC. The first paragraph of this section will be slightly larger to give it emphasis; please write a good introduction.

===== Proposal =====

A new <php>#[\Override]</php> attribute shall be added. If this attribute is added to a method, the engine shall validate that a method with the same name exists in a parent class or any of the implemented interfaces. If no such method exists a compile time error shall be emitted

==== Semantics ====

The rule of thumb is: If changing the method signature would result in the ''Fatal error: Declaration of X must be compatible with Y'' error message, the <php>#[\Override]</php> attribute is satisfied and does not emit an error.

  * Public and protected methods of a parent class or implemented interface satisfy <php>#[\Override]</php>.
    * Abstract methods satisfy <php>#[\Override]</php>.
  * Private methods of a parent class do not satisfy <php>#[\Override]</php>, because they are no part of the externally visible API.
  * The attribute is ignored on traits, but:
    * Abstract methods in a <php>use</php>d trait satisfy <php>#[\Override]</php>.
    * Methods from a <php>use</php> trait behave as if the method definition was copied and pasted into the target class. Specifically the <php>#[\Override]</php> attribute on a trait method requires the existence of a matching method in a parent class or implemented interface.
  * <php>#[\Override]</php> works as expected on enums and anonymous classes.
  * <php>#[\Override]</php> works as expected on interface. A matching method needs to exist in a parent interface.

==== Why an attribute and not a keyword? ====

This RFC proposes an attribute instead of a keyword, because contrary to other modifiers (e.g. visibility) that are part of the method signature, the attribute does not affect behavior or compatibility for users that further extend a given class and neither does it affect users that call the method. It is purely an assistance to the author of a given class.

Furthermore using an attribute improves backwards compatibility, because no parser changes are required. The attribute can be added to codebases that need to support older PHP versions and existing analysis tools and IDEs will be able to make sense of the code, even if they do not understand the semantics of the attribute.

==== Examples ====

=== Valid examples ===

<PHP>
class Foo implements IteratorAggregate
{
    #[\Override]
    public function getIterator(): Traversable
    {
        yield from [];
    }
}
</PHP>

<PHP>
trait T {
    #[\Override]
    public function t(): void {}
}
</PHP>

<PHP>
trait T {
    #[\Override]
    public function i(): void {}
}

interface I {
    public function i(): void;
}

class Foo implements I {
    use T;
}
</PHP>

<PHP>
class P {
    protected function p(): void {}
}

class C extends P {
    #[\Override]
    public function p(): void {}
}
</PHP>

=== Invalid examples ===

<PHP>
class C
{
    #[\Override]
    public function c(): void {} // Fatal error: C::c() has #[\Override] attribute, but no matching parent method exists
}
</PHP>

<PHP>
interface I {
    public function i(): void;
}

class P {
    #[\Override]
    public function i(): void {} // Fatal error: P::i() has #[\Override] attribute, but no matching parent method exists
}

class C extends P implements I {}
</PHP>

<PHP>
trait T {
    #[\Override]
    public function t(): void {}
}

class Foo {
    use T; // Fatal error: Foo::t() has #[\Override] attribute, but no matching parent method exists
}
</PHP>

<PHP>
class P {
    private function p(): void {}
}

class C extends P {
    #[\Override]
    public function p(): void {} // Fatal error: C::p() has #[\Override] attribute, but no matching parent method exists
}
</PHP>

<PHP>
trait T {
    public function t(): void {}
}

class C {
    use T;

    #[\Override]
    public function t(): void {} // Fatal error: C::t() has #[\Override] attribute, but no matching parent method exists
}
</PHP>

===== Backward Incompatible Changes =====

<php>Override</php> can no longer be used as a class name in the global namespace. A GitHub search for ''"class Override " language:php symbol:override'' revealed a total of 94 matches in source code. The majority of the matches are namespaced, but there are some occurrences in the global namespace.

===== Proposed PHP Version(s) =====

Next minor (8.3).

===== RFC Impact =====

==== To SAPIs ====

None.

==== To Existing Extensions ====

Extensions should possibly add the attribute to their methods where appropriate.

==== To Opcache ====

As the RFC touches inheritance and method definitions, Opcache is likely impacted. During development of the RFC CI pointed out a bug that was since fixed. CI of the current version of the implementation is green, any remaining issues will likely be pointed out during review.

==== New Constants ====

None.

==== php.ini Defaults ====

None.

===== Open Issues =====

  * Naming

===== Unaffected PHP Functionality =====

Any functionality that is not related to objects and classes is unaffected. Classes that do not leverage inheritance of implement interfaces are unaffected. The entire functionality is opt-in, so existing code is also unaffected.

===== Future Scope =====

n/a

===== Proposed Voting Choices =====

<doodle title="Implement the #[\Override] attribute as described?" auth="timwolla" voteType="single" closed="false" closeon="2022-01-01T00:00:00Z">
   * Yes
   * No
</doodle>

===== Patches and Tests =====

  * https://github.com/php/php-src/pull/9836

===== Implementation =====

n/a

===== References =====

  * Implementation: https://github.com/php/php-src/pull/9836

===== Rejected Features =====

n/a