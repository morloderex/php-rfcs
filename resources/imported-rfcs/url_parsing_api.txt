====== PHP RFC: Add WHATWG compliant URL parsing API ======
  * Version: 1.0
  * Date: 2024-06-11
  * Author: Máté Kocsis, kocsismate@php.net
  * Status: Under Discussion
  * First Published at: https://wiki.php.net/rfc/url_parsing_api
  * Implementation: https://github.com/php/php-src/pull/14461

===== Introduction =====

URLs are one of the most fundamental concepts of the web because they make it possible to reference specific resources on a network. URLs were originally defined by Tim Berners-Lee in [[https://datatracker.ietf.org/doc/html/rfc1738|RFC 1738]], but since then other specifications have also emerged, out of which [[https://url.spec.whatwg.org/#title|WHATWG URL]] is the most notable one, because it's implemented by most browsers nowadays.

Despite the ubiquitous nature of URLs, they are not so unequivocal as people may think, because different clients treat and parse them differently by either following one of the standards, or even worse, not following any at all. Unfortunately, PHP falls into the latter category: the ''parse_url()'' function is offered for parsing URLs, however, it isn't compliant with any standards. Even the PHP manual contains the following warning:

<blockquote>This function may not give correct results for relative or invalid URLs, and the results may not even match common behavior of HTTP clients. ...</blockquote>

Incompatibility with current standards is a serious issue, as it hinders interoperability with different tools (i.e. HTTP clients), or it can result in bugs which are difficult to notice.

===== Proposal =====

In order to address the above mentioned problems, a new, always available ''URL'' extension is to be added to the standard library.  Initially, it would only support the WHATWG URL specification, with the explicit intention of adding support for other standards when the need arises.

The extension would support parsing, as well as manipulating URLs. For this purpose, the following internal classes and methods are added:

<code php>
namespace Uri;

readonly abstract class Uri implements Stringable
{
    private ?string $scheme;
    private ?string $user;
    private ?string $password;
    private ?string $host;
    private ?int $port;
    private ?string $path;
    private ?string $query;
    private ?string $fragment;

    public static function fromRfc3986(string $uri, ?string $baseUrl = null): ?static {}

    /** @param array<int, WhatWgError> $errors */
    public static function fromWhatWg(string $uri, ?string $baseUrl = null, &$errors = null): ?static {}

    public function getScheme(): ?string {}

    public function getUser(): ?string {}

    public function getPassword(): ?string {}

    public function getHost(): ?string {}

    public function getPort(): ?int {}

    public function getPath(): ?string {}

    public function getQuery(): ?string {}

    public function getFragment(): ?string {}

    public function __toString(): string {}
}

readonly class Rfc3986Uri extends Uri
{
    public function __construct(string $uri, ?string $baseUrl = null) {}
}

readonly class WhatWgUri extends Uri
{
    /** @param array<int, WhatWgError> $errors */
    public function __construct(string $uri, ?string $baseUrl = null, &$errors = null) {}
}

final readonly class WhatWgError
{
    public const int ERROR_TYPE_DOMAIN_TO_ASCII = UNKNOWN;
    public const int ERROR_TYPE_DOMAIN_TO_UNICODE = UNKNOWN;
    public const int ERROR_TYPE_DOMAIN_INVALID_CODE_POINT = UNKNOWN;
    public const int ERROR_TYPE_HOST_INVALID_CODE_POINT = UNKNOWN;
    public const int ERROR_TYPE_IPV4_EMPTY_PART = UNKNOWN;
    public const int ERROR_TYPE_IPV4_TOO_MANY_PARTS = UNKNOWN;
    public const int ERROR_TYPE_IPV4_NON_NUMERIC_PART = UNKNOWN;
    public const int ERROR_TYPE_IPV4_NON_DECIMAL_PART = UNKNOWN;
    public const int ERROR_TYPE_IPV4_OUT_OF_RANGE_PART = UNKNOWN;
    public const int ERROR_TYPE_IPV6_UNCLOSED = UNKNOWN;
    public const int ERROR_TYPE_IPV6_INVALID_COMPRESSION = UNKNOWN;
    public const int ERROR_TYPE_IPV6_TOO_MANY_PIECES = UNKNOWN;
    public const int ERROR_TYPE_IPV6_MULTIPLE_COMPRESSION = UNKNOWN;
    public const int ERROR_TYPE_IPV6_INVALID_CODE_POINT = UNKNOWN;
    public const int ERROR_TYPE_IPV6_TOO_FEW_PIECES = UNKNOWN;
    public const int ERROR_TYPE_IPV4_IN_IPV6_TOO_MANY_PIECES = UNKNOWN;
    public const int ERROR_TYPE_IPV4_IN_IPV6_INVALID_CODE_POINT = UNKNOWN;
    public const int ERROR_TYPE_IPV4_IN_IPV6_OUT_OF_RANGE_PART = UNKNOWN;
    public const int ERROR_TYPE_IPV4_IN_IPV6_TOO_FEW_PARTS = UNKNOWN;
    public const int ERROR_TYPE_INVALID_URL_UNIT = UNKNOWN;
    public const int ERROR_TYPE_SPECIAL_SCHEME_MISSING_FOLLOWING_SOLIDUS = UNKNOWN;
    public const int ERROR_TYPE_MISSING_SCHEME_NON_RELATIVE_URL = UNKNOWN;
    public const int ERROR_TYPE_INVALID_REVERSE_SOLIDUS = UNKNOWN;
    public const int ERROR_TYPE_INVALID_CREDENTIALS = UNKNOWN;
    public const int ERROR_TYPE_HOST_MISSING = UNKNOWN;
    public const int ERROR_TYPE_PORT_OUT_OF_RANGE = UNKNOWN;
    public const int ERROR_TYPE_PORT_INVALID = UNKNOWN;
    public const int ERROR_TYPE_FILE_INVALID_WINDOWS_DRIVE_LETTER = UNKNOWN;
    public const int ERROR_TYPE_FILE_INVALID_WINDOWS_DRIVE_LETTER_HOST = UNKNOWN;

    public string $position;
    public int $errorCode;

    public function __construct(string $position, int $errorCode) {}
}
</code>

===== Parser Library Choice =====

Adding a WHATWG compliant URL parser to the standard library [[https://github.com/php/php-src/pull/11315|was originally attempted in 2023]]. The implementation used [[https://www.ada-url.com|ADA URL parser]] as its parser backend which is known for its ultimate performance. At last, the proof of concept was abandoned due to some technical limitations that weren't possible to resolve.

Specifically, ADA is written in C++, and requires a compiler supporting C++17 at least. Despite the fact that it has a C wrapper,   its tight compiler requirements would make it unprecedented, and practically impossible to add the ''URL'' extension to PHP as a required extension, because PHP has never had a C++ compiler dependency for the always enabled extensions, only optional extensions (like ''Intl'') can be written in C++.

The firm position of this RFC is that a WHATWG compliant URL parser extension should be always available, therefore a different parser backend written in pure C should be found. Fortunately, Niels Dossche proposed [[rfc:domdocument_html5_parser|PHP RFC: DOM HTML5 parsing and serialization]] not long after the experiment with ADA, and his work required bundling the [[https://lexbor.com/|Lexbor]] browser engine. This library is written in C, and coincidentally contains a WHATWG compliant URL parsing submodule, therefore it makes it suitable to be used as the library of choice.

===== Plugability =====

The capability provided by ''parse_url()'' is used for multiple purposes in the internal PHP source:

  * ''SoapClient::__doRequest()'': the ''$location'' parameter as well as the value of the ''Location'' header are parsed
  * FTP/FTPS stream wrapper: ''parse_url()'' is used for connecting to an URL, renaming a file, following the ''Location'' header
  * ''FILTER_VALIDATE_URL'': Validating URLs
  * SSL/TLS socket communication: The URL is parsed
  * GET/POST session: Sending the session ID as a query string ([[rfc:deprecate-get-post-sessions|PHP RFC: Deprecate GET/POST sessions]]

===== Performance Considerations =====

The implementation of ''parse_url()'' is optimized for performance. This also means that it doesn't deal with validation properly and disregards some edge cases. A WHATWG compliant parser will always be slower than ''parse_url()'', because it has to execute more code. According to the initial benchmarks, ''Url\UrlParser::parseUrl()'' is ~3.6x, while ''Url\UrlParser::parseUrlToArray()'' is ~3x slower than ''parse_url()''. The new functions still have some room for performance optimizations, but we shouldn't expect a significant performance improvement.

===== API Design =====

The new URL parsing API consists of two classes: ''Url\UrlParser'' and ''Url\Url''. It's a deliberate design decision to separate parsing from representation: this way URLs can be parsed into multiple representations (class, array, scalar values). However, it's still to be decided which representations are really necessary to have.

Additionally, this design makes it easier to support custom parser backends. For example, one can then create an extension which uses the [[https://www.ada-url.com|ADA URL parser]] library to parse URLs.

===== Relation to PSR-7 =====

The ''Url\Url'' class is intentionally compatible with the [[https://www.php-fig.org/psr/psr-7/#35-psrhttpmessageuriinterface|PSR-7 UriInterface]]. This makes it possible for a next iteration of the PSR-7 standard to use ''Url\Url'' directly instead of requiring implementations to provide their own ''Psr\Http\Message\UriInterface'' implementation.

===== Examples in Other Languages =====

==== Go ====

Even though Go's standard library ships with a ''net/url'' package containing a ''url.Parse()'' function along with some utility functions, unfortunately it's not highlighted in the documentation which standard it conforms to. However, it's not very promising that the manual mentions the following sentence:

<blockquote>Trying to parse a hostname and path without a scheme is invalid but may not necessarily return an error, due to parsing ambiguities.</blockquote>

==== Java ====

In Java, a [[https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/net/URL.html|URL]] class has been available from the beginning. Unfortunately, it's unclear whether it adheres to any URL standards. Speaking about its design, ''URL'' itself is immutable, and somewhat peculiarly, it contains some methods which can open a connection to the URL, or get its content.

Since Java 20, all of the ''URL'' constructors are deprecated in favor of using ''URI.toURL()''. The [[https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/net/URI.html|URI]] class conforms to [[https://datatracker.ietf.org/doc/html/rfc2396|RFC 2396]] standard.

==== NodeJS ====

NodeJS recently added support for a decent WHATWG URL compliant [[https://nodejs.org/api/url.html#the-whatwg-url-api|URL parser]], built on top of the ADA URL parser project.

==== Python ====

Python also comes with built-in support for parsing URLs, made available by the [[https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urlparse|urllib.parse.urlparse]] and [[https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urlsplit|urllib.parse.urlsplit]] functions. According to the documentation, "these functions incorporate some aspects of both, but cannot be claimed compliant with either [the WHATWG URL or the RFC 3986 specifications]".

===== Backward Incompatible Changes =====

None.

===== Proposed PHP Version(s) =====

Either PHP 8.5 or 9.0.

===== Future Scope =====

Support for other parser backends may be added so that other libraries (like [[https://www.ada-url.com/|Ada URL]]) could be also used in addition to Lexbor.

The ''parse_url()'' function can be deprecated at some distant point of time.

===== References =====

Discussion thread: https://externals.io/message/123997

===== Vote =====

The vote requires 2/3 majority in order to be accepted.

<doodle title="Add the WHATWG compliant URL API described above?" auth="kocsismate" voteType="single" closed="yes" closeon="2024-05-30T10:00:00Z">
   * yes
   * no
</doodle>
