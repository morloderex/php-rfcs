====== PHP RFC: Property hooks ======
  * Version: 0.9
  * Date: 2022-12-01
  * Author:  Ilija Tovilo (tovilo.ilija@gmail.com), Larry Garfield (larry@garfieldtech.com)
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/property-hooks
  * Implementation: Pending

===== Introduction =====

Developers often use methods to wrap and guard access to object properties. There are several highly common patterns for such logic, which in practice may be verbose to implement repeatedly.  Alternatively, developers may use <php>__get</php> and <php>__set</php> to intercept reads and writes generically, but that is a sledge-hammer approach that intercepts all undefined (and some defined) properties unconditionally.  Property hooks provide a more targeted, purpose-built took for common property interactions.

The combination of this RFC and the [[rfc:asymmetric-visibility|Asymmetric Visibility]] RFC effectively replicate and replace the previous [[rfc:property_accessors|Property Accessors]] RFC.  Much of the implementation is derived from Nikita's original work on that RFC.

The design and syntax below is derived primarily from Swift with some C# influence as well, although not an exact copy of either.  The scope of functionality in this RFC is approximately equivalent to that of C; future additions could expand it to the larger feature set of Swift if desired.

A primary use case for hooks is actually to **not** use them, but retain the ability to do so in the future, should it become necessary. In particular, developers often implement getFoo/setFoo methods on a property not because they are necessary, but because they might become necessary in a hypothetical future, and changing from a property to a method at that point becomes an API change.

By allowing most common getFoo/setFoo patterns to be attached to properties directly, such behavior can be added to a property later without an API change and without the extra boilerplate of two mostly-meaningless methods for every property, "just in case."

Methods that are not just variations on getFoo/setFoo behavior, of course, are still valuable in their own right.

Consider the following class declaration, which might have been considered idiomatic prior to PHP 7.4:

<PHP>
class User 
{
    private $name;

    public function __construct(string $name) {
        $this->name = $name;
    }

    public function getName(): string {
        return $this->name;
    }

    public function setName(string $name): void {
        $this->name = $name;
    }
}
</PHP>

As of PHP 8.2, if type enforcement is the only need, that can be abbreviated all the way down to:

<PHP>
class User 
{
    public function __construct(public string $name) {}
}
</PHP>

That is much nicer, but comes at a cost: If we later want to add additional behavior (such as validation or pre-processing), there's nowhere to do so.  That currently leaves two options:

  - Re-add ''getName()'' and ''setName()'' methods, making the property private or protected.  This would be an API break.
  - Use <php>__get</php> and <php>__set</php>.  As shown below, this is verbose, ugly, error prone, and breaks static analysis tools.

<PHP>
class User 
{
    private string $_name;

    public function __construct(string $name) {
        $this->_name = $name;
    }

    public function __get(string $propName): mixed {
        return match ($propName) {
            'name' => $this->_name,
            default => throw new Error("Attempt to read undefined property $propName"),
        };
    }

    public function __set(string $propName, $value): void {
        switch ($propName) {
            case 'name':
                if (!is_string($value)) {
                    throw new TypeError("Name must be a string");
                }
                if (strlen($value) === 0) {
                    throw new ValueError("Name must be non-empty");
                }
                $this->_name = $value;
                break;
            default:
                throw new Error("Attempt to write undefined property $propName");
        }
    }

    public function __isset(string $propName): bool {
        return $propName === 'name';
    }
}
</PHP>

Property hooks allow developers to introduce additional behavior in a way that is specific to a single property while respecting all other existing aspects of PHP and its tooling.

<PHP>
class User 
{
    private $nameReal;
    public string $name {
        get => $this->nameReal;
        set {
            if (strlen($value) === 0) {
                throw new ValueError("Name must be non-empty");
            }
            $this->nameReal = $value;
        }
    }

    public function __construct(string $name) {
        $this->name = $name;
    }
}
</PHP>

This code introduces a new non-empty requirement, but does not change the outward syntax of reading or writing to ''$name'', does not hinder static analysis, and does not fold multiple properties into a single hard-to-follow method.

===== Proposal Summary =====

This RFC introduces two "hooks" to override the default "get" and "set" behavior of a property.  Although not included in this initial version, the design includes the ability to support more hooks in the future.  (See the Future Scope section below.)  Taken together, they allow for a majority of common reasons to add "just in case" methods to a property to be implemented without methods, leading to shorter code and more flexibility to improve the code without a hard API break.  

<PHP>
class User implements Named
{
    private bool $isModified = false;

    public function __construct(private string $first, private string $last) {}
    
    public string $fullName {
        // Overwrite the "read" action with arbitrary logic.
        get => $this->first . " " . $this->last;
        
        // Overwrite the "write" action with arbitrary logic.
        set($value) => [$this->first, $this->last] = explode(' ', $value);
    }
}
</PHP>

Additionally, as this functionality makes it natural to use a public property as part of an API, this RFC allows interfaces to declare properties and whether they should be readable, writeable, or both.

<PHP>
interface Named
{
    // Objects implementing this interface must have a readable
    // $fullName property.  That could be satisfied with a traditional
    // property or a property with a "get" hook.
    public string $fullName { get; }
}

// The "User" class above satisfies this interface, but so does:

class SimpleUser implements Named
{
    public function __construct(public readonly string $fullName) {}
}
</PHP>

Taken together, these behaviors allow for much shorter, more robust code.

===== Detailed Proposal =====

This RFC applies to object properties only, not static properties.  Static properties are unaffected by this RFC.

For a property to use a hook, it must replace its trailing '';'' with a code block denoted by ''{ }''.  Inside the block are one or more hook implementations, for which the order is explicitly irrelevant.  It is a compile error to have an empty hook block.

The ''get'' and ''set'' hooks overwrite the PHP default read and write behavior.  They may be implemented individually or together.  If either one is implemented, PHP will not create any storage property on the object.  The developer is on their own to implement whatever storage behavior is appropriate.

A property that implements either a ''get'' or ''set'' hook is known as a "virtual property", as it has no materialized stored value by default.

==== get ====

If a ''get'' hook is implemented, then PHP will create no automatic storage for that property.  Instead, reads of that property will invoke the defined hook.

<code php>
class User
{
    public function __construct(private string $first, private string $last) {}
    
    public string $fullName {
        get { 
            return $this->first . " " . $this->last;
        }
    }
}

$u = new User('Larry', 'Garfield');

// prints "Larry Garfield"
print $u->fullName;
</code>

The ''get'' hook body is an arbitrarily complex method body, which MUST return a value that is type compatible with the property.

If a ''get'' hook is defined but no ''set'' hook, then any attempt to write to the property will result in an <php>Error</php> being thrown.

==== set ====

If a ''set'' hook is implemented, then PHP will create no automatic storage for that property.  Instead, writes to that property will invoke the defined hook.

<code php>
class User
{
    public function __construct(private string $first, private string $last) {}
    
    public string $fullName {
        set ($value) {
            [$this->first, $this->last] = explode(' ', $value);
        }
    }
    
    public function getFirst(): string
    {
        return $this->first;
    }
}

$u = new User('Larry', 'Garfield');

$u->fullName = 'Ilija Tovilo';

// prints "Ilija"
print $u->getFirst();
</code>

The ''set'' hook body is an arbitrarily complex method body, which accepts one argument.  The argument is implicitly typed to the same type as the property.  Its return type is unspecified, and will be silently discarded.

Specifying the argument name is optional.  If not specified, it defaults to ''$value''.  That is, the following ''set'' hook is identical to the previous:

<code php>
    public string $fullName {
        set {
            [$this->first, $this->last] = explode(' ', $value);
        }
    }
</code>


A ''set'' hook may also be used for validation by throwing an exception should the value not meet some arbitrary criteria.

<code php>
class User {
    private string $validUsername;
    public string $username {
        get => $this->validUsername;
        set($value) {
            if (strlen($value) > 10) throw new \InvalidArgumentException('Too long');
            $this->validUsername = strtolower($value);
        }
    }
}
</code>

A <php>set</php> hook may optionally declare an argument type that is contravariant (wider) from the type of the property.  That allows the <php>set</php> body to accept a more permissive set of values.  The type of the value returned by <php>get</php> must still conform to the declared type, however.

That allows, for example, behavior like this:

<PHP>
use Symfony\Component\String\UnicodeString;

class Person
{
    private UnicodeString $unicodeName;
    public UnicodeString $name {
        get {
            return $this->unicodeName;
        }
        set(string|UnicodeString $value) {
            $this->unicodeName = $value instanceof UnicodeString ? $value : new UnicodeString($value);        
        }
    }
}
</PHP>

That allows both strings and <php>UnicodeString</php> objects to be passed in, but normalizes the value to <php>UnicodeString</php> to enforce a consistent and reliable type when reading it (either internally or externally).

Due to technical limitations, type variance of the <php>set</php> parameter is not checked, so an incompatible "set" type is possible.  This behavior is not recommended, however.

Although it is not often used, the <php>=</php> assignment operator is an expression that returns a value. The value returned is already slightly inconsistent, however.  In the case of typed properties, that is the value the property holds after the assignment, which may include type coercion. For a property assignment that triggers <php>__set</php>, there is no reasonably defined "value the property holds", so the value returned is always the right-hand-side of the expression.  The <php>set</php> hook has the same behavior as <php>__set</php>, for the same reason.

<PHP>
class C {
    public array $_names;
    public string $names {
        set {
            $this->_prop = explode(',', $value);
        }
    }
}
$c = new C();
var_dump($c->names = 'Ilija,Larry'); // 'Ilija,Larry'
var_dump($c->_names); // ['Ilija', 'Larry']
</PHP>

This also implies that adding a <php>set</php> hook to a property cannot change the result of the <php>=</php> operator, which is a desirable feature to avoid unintentional BC breaks.

If a ''set'' hook is defined but no ''get'' hook, then any attempt to read from the property will result in an error.  Such "write only" properties are of limited (but probably non-zero) value, but do not cause any issues for other functionality.

In practice, most ''set'' implementations will also include a ''get'', but not all ''get'' implementations will include a ''set''.

==== Abbreviated forms ====

There are two shorthand notations supported, beyond the optional argument to ''set''.

First, if a hook's body is a single expression, then the ''{ }'' and ''return'' statement may be omitted and replaced with ''=>'', just like with arrow functions.

Second, if there is one and only one hook, and that hook is ''get'', then the hook name and wrapping ''{}'' may be omitted and replaced with ''=>''.

That means the following three examples are all semantically identical:

<code php>
class User
{
    public function __construct(private string $first, private string $last) {}
    
    public string $fullName {
        get { 
            return $this->first . " " . $this->last;
        }
    }
}

class User
{
    public function __construct(private string $first, private string $last) {}
    
    public string $fullName {
        get => $this->first . " " . $this->last;
    }
}

class User
{
    public function __construct(private string $first, private string $last) {}
    
    public string $fullName => $this->first . " " . $this->last;
}
</code>

As noted, the return value of ''set'', if any, is discarded.  That means it may also use the short-hand syntax, as whatever value the expression evaluates to will be ignored.  That is, the following is an example of legal syntax:

<code php>
class User
{

    private array $modified = [];

    public string $fullName {
        get => $this->first . " " . $this->last;
        set => [$this->first, $this->last] = explode(' ', $value);
    }

    public function __construct(private string $first, private string $last) {}
}
</code>

By way of comparison, here is the same logic implemented via methods in PHP 8.2:

<code php>
class User
{
    private array $modified = [];
    
    public function __construct(private string $first, private string $last) {}
    
    public function getFullName(): string
    {
        return $this->first . " " . $this->last;
    }
    
    public function setFullName(string $value): void
    {
        $value = \ucfirst($value);
        [$this->first, $this->last] = explode(' ', $value);
    }
}
</code>

==== Scoping ====

All hooks operate in the scope of the object being modified.  That means they have access to all public, private, or protected methods of the object, as well as any public, private, or protected properties, including properties that may have their own property hooks.  Accessing another property from within a hook does not bypass the hooks defined on that property.

The most notable implication of this is that non-trivial hooks may sub-call to an arbitrarily complex method if they wish.  For example:

<code php>
class Person {
    private string $validatedPhone;
    
    public string $phone {
        get => $this->validatedPhone;
        set => $this->validatedPhone = $this->sanitizePhone($value);
    }
    
    private function sanitizePhone(string $value): string
    {
        $value = ltrim($value, '+');
        $value = ltrim($value, '1');

        if (!preg_match('/\d\d\d\-\d\d\d\-\d\d\d\d/', $value)) {
            throw new \InvalidArgumentException();
        }
        return $value;
    }
}
</code>

==== References and arrays ====

Because the presence of hooks intercept the read and write process for properties, they cause issues when acquiring a reference to a property or with indirect modification (such as ''$this->arrayProp['key'] = 'value';'').  For that reason, the presence of any hook must necessarily also disallow acquiring a reference to a property or indirect modification on a property.

For example:

<PHP>
class Foo
{
    public int $bar;

    private int $_baz;
    public int $baz {
        get => $this->_baz;
        set => $this->_baz = $value;
    }
}

$x = 42;

$foo = new Foo();
// This is fine; as $bar is a normal property.
$foo->bar = &$x;

// This will error, as $baz is a 
// hooked property and so references are not allowed.
$foo->baz = &$x;
</PHP>

For the vast majority of properties this causes no issue, as reading or writing to properties by reference is extremely rare.  The one exception is ''array'' properties.  Assigning a value to an array property consists of obtaining a pointer to that property and modifying it in place without knowledge of whether that array came from a property with hooks. It is also common in some systems to acquire references to arrays and modify them in some other place.  That would, as above, bypass any hooks that have been defined.

Furthermore, providing a good API for an array modification seems impossible. The simplest approach would be to copy the array, modify it accordingly, and pass it to ''set'' hook. This would have a large and obscure performance penalty, and a ''set'' implementation would have no way of knowing which values had changed, leading to, for instance, code needing to revalidate all elements even if only one has changed.

Another approach might be a separate hook, e.g. ''setOffset(array $keys, $value)'' where $keys is a list of keys. Assuming the user would like to apply the change to the array, they would need to iterate the keys, fetch the offset by-reference, and at the end assign the value to the last reference. This has terrible performance characteristics and is non-trivial to implement for the end-user.

Both of these possible approaches also handle only explicit additions and modification.  They would not address appending (''[]'') or operations such as ''unset'', which would introduce even more complexity.

Because all API solutions that come to mind are bad it is the opinion of the authors that for arrays, dedicated mutator methods are always the superior API choice.  Therefore, while hooks may be applied to array properties the use of ''[]'' on any property (with or without a key) will result in a runtime error being thrown.  This applies both to arrays and objects implementing ''ArrayAccess''.

This check cannot be done at compile time, as we cannot reliably tell at compile time whether a property is an array or not, as it could be an iterable or mixed, so runtime enforcement would be required anyway.  There are also valid usecases for arrays with some hooks, such as a ''get''-only virtual array, which make forbidding hooks entirely undesireable.

It is possible to change the whole array, like so:

<code php>
class MyList {
    private array $truthyValues = [];
    public array $values = [] {
        get => $this->truthyValues;
        
        // Ensure no empty values.
        set {
            if (array_filter($value) != $value) {
                throw new \InvalidArgumentException('Only truthy values allowed');
            }
            $this->truthyValues = $value;
        }
    }
    
    public function addValue($key, $value): void
    {
        // This is easily encapsulated in a method.
        $values = $this->values;
        $values[$key] = $value;
        $this->values = $values;
    }
}

$l = new MyList();

// This will fail.
$l->values[] = 1;

// But this is allowed.
$a = $l->values;
$a[] = 1;
$l->values = $a;

// This is fine.
$a->addValue('foo', 'bar');

// This will throw an exception due to the hook.
$a = $l->values;
$a[] = false;
$l->values = $a;
</code>

In practice, a more appropriate and idiomatic usage of hooked arrays would be like so:

<PHP>
class C {
    private array $_elements;
    public array $elements {
        get => $this->_elements;
    }
    public function addElement(string $element): void {
        $this->_elements[] = $element;
    }
}
</PHP>

Additionally, iterating an object's properties by reference will throw an error if any of the properties have hooks defined.  (Note: We are still confirming that this can be caught properly.)

<PHP>
foreach ($someObjectWithHooks as $key => $value) {
    // Works as expected.
}

foreach ($someObjectWithHooks as $key => &$value) {
    // Throws an error
}

</PHP>

==== Inheritance ====

A child class may define or redefine individual hooks on a property by redefining the property and just the hooks it wishes to override.  The type and visibility of the property are subject to their own rules independently of this RFC.

A child class may also add hooks to a property that had none.

<code php>
class Point
{
    public int $x;
    public int $y;
}

class PositivePoint extends Point
{
    private int $positiveX;
    public int $x {
        get => $this->positiveX;
        set($x) => $x >= 0 ? $this->positiveX = $x : throw new \InvalidArgumentException('Too small');
    }
}
</code>

Each hook overrides parent implementations independently of each other.

If a child class adds hooks, any default set on the property is removed.  That is consistent with how inheritance works already; if a property is redeclared in a child, its default is removed or must be re-assigned.  Since hooked properties may not have default values, the default is omitted.  It may be re-assigned in the class's constructor if desired (in which case it would call the ''set'' hook).

=== Accessing parent hooks ===

A hook in a child class may access the parent class's hook it is overriding by using the ''parent::$prop'' keyword.  If not accessed this way, the parent class's hook is ignored.  This behavior is consistent with how all methods work.  This also offers a way to access the parent class's storage, if any.  That is, the above example could be rewritten:

<PHP>
class Point
{
    public int $x;
    public int $y;
}

class PositivePoint extends Point
{
  private int $positiveX;
  public int $x {
      set($x) => $x >= 0 ? parent::$x::set($x) : throw new \InvalidArgumentException('Too small');
  }
}
</PHP>

An example of overriding only a <php>get</php> hook could be:

<PHP>
class Strings
{
    public string $val;
}

class CaseFoldingStrings extends Strings
{
    public bool $uppercase = true;

    public string $val {
        get => $this->uppercase 
          ? strtoupper(parent::$val::get()) 
          : strtolower(parent::$val::get());
    }
}
</PHP>

Hooks may not access any other hook except their own parent on their own property.

==== Interfaces ====

A key goal for property hooks is to obviate the need for getter/setter methods in the majority case.  While straightforward for classes, many value objects also conform to an interface.  That interface, therefore, also needs to be able to specify what properties it includes.

This RFC therefore also adds the ability for interfaces to declare public properties, asymmetrically.  An implementing class may provide the property via a normal property or a virtual property (with ''get''/''set'' hooks).  Either one is sufficient to satisfy the interface.

<PHP>
interface I
{
    // An implementing class MUST have a publicly-readable property,
    // but whether or not it's publicly settable is unrestricted.
    public string $readable { get; }
    
    // An implementing class MUST have a publicly-writeable property,
    // but whether or not it's publicly readable is unrestricted.
    public string $writeable { set; }
    
    // An implementing class MUST have a property that is both publicly
    // readable and publicly writeable.
    public string $both { get; set; }
}

// This class implements all three properties as traditional, un-hooked
// properties. That's entirely valid.
class C1 implements I
{
    public string $readable;
    
    public string $writeable;
    
    public string $both;
}

// This class implements all three properties using just the hooks
// that are requested.  This is also entirely valid.
class C2 implements I
{
    private string $written = '';
    private string $all = '';

    // Uses only a get hook to create a virtual property.
    // This satisfies the "public get" requirement. It is not
    // writeable, but that is not required by the interface.
    public string $readable => strtoupper($this->writeable);
  
    // The interface only requires the property be settable,
    // but also including get operations is entirely valid.
    public string $writeable {
        get => $this->written;
        set => $this->written = $value;
    }
  
    // This property requires both read and write be possible,
    // so we need to either implement both, or allow it to have
    // the default behavior.
    public string $both {
        get => $this->all;
        set => $this->all = $value;
    
    }
}
</PHP>

Interfaces are only concerned with public access, so the presence of non-public properties is both unaffected by an interface and cannot satisfy an interface.  This is the same relationship as for methods.  The ''public'' keyword on the property is required for syntax consistency, but other visibilities are not supported.

==== Abstract properties ====

An abstract class may declare an ''abstract'' property, for all the same reasons as an interface.  However, abstract properties may also be declared ''protected'', just as with abstract methods.  In that case, it may be satisfied by a property that is readable/writeable from either ''protected'' or ''public'' scope.  Abstract ''private'' properties are not allowed and will result in a compile-time error, just as with methods.

<PHP>
abstract class A
{
    // Extending classes must have a publicly-gettable property.
    abstract public string $readable { get; }
    
    // Extending classes must have a protected- or public-writeable property.
    abstract protected string $writeable { set; }
    
    // Extending classes must have a protected or public symmetric property.
    abstract protected string $both { get; set; }   
}

class C extends A
{
    private string $written = '';

    // This satisfies the requirement and also makes it settable, which is valid.
    public string $readable;
    
    // This would NOT satisfy the requirement, as it is not publicly readable.
    protected string $readable;

    // This satisfies the requirement exactly, so is sufficient. It may only
    // be written to, and only from protected scope.    
    protected string $writeable {
      set => $this->written = $value;
    }
  
    // This expands the visibility from protected to public, which is fine.
    public string $both;
}
</PHP>

An abstract property on an abstract class may provide implementations for any hook, but must have either <php>get</php> or <php>set</php> declared but not defined (as in the example above).  A property on an interface may not implement any hooks.

==== Abstract property types ====

Normal properties are neither covariant nor contravariant; their type may not change in a subclass.  The reason for that is "get" operations MUST be covariant, and "set" operations MUST be contravariant.  The only way for a property to satisfy both requirements is to be invariant.

With abstract properties (on an interface or abstract class) it is possible to declare a property that has only a get or set operation.  As a result, abstract properties that have only a ''get'' operation required MAY be covariant.  Similarly, an abstract property that has only a ''set'' operation required MAY be contravariant.

Once a property has both a ''get'' and ''set'' operation, however, it is no longer covariant or contravariant for further extension.

<PHP>
class Animal {}
class Dog extends Animal {}
class Poodle extends Dog {}

interface PetOwner 
{
    // Only a get operation is required, so this may be covariant.
    public Animal $pet { get; }
}

class DogOwner implements PetOwner 
{
    // This may be a more restrictive type since the "get" side
    // still returns an Animal.  However, as a native property
    // children of this class may not change the type anymore.
    public Dog $pet;
}

class PoodleOwner extends DogOwner 
{
    // This is NOT ALLOWED, because DogOwner::$pet has both
    // get and set operations defined and required.
    public Poodle $pet;
}
</PHP>

==== Property magic constant ====

Within a property hook, the special constant <php>__PROPERTY__</php> is automatically defined.  Its value will be set to the name of the property.  This is mainly useful for repeating self-referential code.  See the "[[https://github.com/Crell/php-rfcs/blob/master/property-hooks/examples.md|cached derived property]]" example linked below for a complete use case.

==== Interaction with traits ====

Properties in traits may declare hooks, just like any other property.  However, as with normal properties, there is no conflict resolution mechanism provided the way methods have.  If a trait and a class where it is used both declare the same property with hooks, an error is issued.

We anticipate that being a very rare edge case, and thus no additional resolution machinery is necessary.

==== Interaction with asymmetric visibility ====

Swift and C#, the languages on which this design is modeled, both support asymmetric visibility in addition to property hooks (by whatever name).  However, they use different syntaxes.  The C# syntax in particular includes the visibility on the ''get'' or ''set'' hook.

That would cause a problem for PHP.  As noted above, property hooks are incompatible with ''array'' properties.  However, there is no conceptual reason for asymmetric visibility to be incompatible with array properties, and there are ample use cases for wanting to support that.

However, using the C#-style syntax for visibility would either inherently forbid asymmetric visibility on arrays (undesirable), or necessitate more complex syntax to determine if references should or should not be disabled on a property.  Both are poor options.

For that reason, any concept of asymmetric visibility has been omitted from this RFC.  Should asymmetric visibility be determined a desirable feature in the future, a left-side syntax as used by Swift and as demonstrated in the original [[rfc:asymmetric-visibility|Asymmetric Visibility]] RFC would be a complementary addition, and the best option in practice.

==== Interaction with readonly ====

''readonly'' properties work by checking if the backing store value is uninitialized.  A virtual property has no backing store value to check.  While technically an inherited <php>readonly</php> property would allow accessing its parent's stored value, in practice it would be non-obvious when readonly works on properties with hooks. Moreover, providing a <php>get</php> hook on an overridden property would further complicate the notion of a "initialized" value.

For that reason, a ''readonly'' property with a ''get'' or ''set'' hook is disallowed and will throw a syntax error.  That also means that a child class may not redeclare and add hooks to a <php>readonly property</php>, either.

==== Interaction with magic methods ====

PHP 8.2 will invoke the <php>__get</php> or <php>__set</php> magic methods if a property is accessed and it is either not defined, OR it is defined but not visible from the calling scope.  The presence of hooks on a defined property does not change that behavior.  Naturally the property will be defined if it has hooks; however, if the property is not visible in the calling scope then <php>__get</php> or <php>__set</php> will be called just as if there were no hooks.

Within the <php>__get</php> or <php>__set</php> methods, the property will be visible and therefore accessible.  Reads or writes to a hooked property will behave the same as from any other method, and thus hooks will still be invoked as normal.

<PHP>
class C
{
    private string $normalizedName;
    private string $name {
        get => $this->normalizedName;
        set => $this->normalizedName = ucfirst($value);
    }
    
    public function __set($var, $val)
    {
        print "In __set\n";
        $this->$var = $val;
    }
}

$c = new C();

$c->name = 'picard';

// prints "In __set"
// $c->name now has the value "Picard"
</PHP>

==== Interaction with isset() and unset() ====

If a property implements ''get'', then ''isset()'' will invoke the ''get'' hook and return true if the value is non-null.  That is, ''isset($o->foo)'', where ''$foo'' has a ''get'' hook, is equivalent to ''!is_null($o->foo)''.  This behavior is consistent with how ''isset()'' interacts with <php>__get</php> today.

If a property implements any hook, then ''unset()'' is disallowed and will result in an error.  Its semantics are unclear, and it rarely has a logical meaning anyway.

==== Interaction with constructor property promotion ====

As of PHP 8.0, properties may be declared inline with the constructor.  That creates an interesting potential for complexity if the property also includes hooks, as the hooks may be arbitrarily complex, and therefore long, leading to potentially tens of lines of code technically within the constructor's method signature.

This issue is somewhat obviated by the fact that use cases for promoted virtual properties are not common.  The primary use case would be a <php>set</php> hook that just does validation and nothing else.  With the current set of hooks that would still be rather clunky to implement and to read.

Swift has another hook which it calls ''willSet'', that triggers before the value is set but does not make the property virtual.  We believe this is a useful extension to the hooks proposal (see below).  At that time, we believe it would be sensible to allow hooks in constructors only to support a ''beforeSet'' hook or similar for validation.

For the time being, however, we have opted to disallow mixing hooks with constructor property promotion.  This decision can and should be revisited in the future as more hooks are made available.

==== Default values ====

Default values on properties that implement hooks are not supported.  The main reason is the confusion and complexity around the question of when hooks should run; before or after the value is assigned?  Running hooks on object creation results in similar order-of-actions questions as [[https://wiki.php.net/rfc/new_in_initializers#unsupported_positions|non-static initializers on properties]].  In short, since hook bodies can be arbitrary code they could cause arbitrary side effects, and it is not at all clear what the lest-surprising way of handling that is.  The new-in-intializers RFC opted to avoid the issue entirely, and we believe that is the best course of action here as well.

In practice, we do not expect this to be a significant issue, for a number of reasons.

  - Default values make little logical sense on properties that implement a <php>get</php> and <php>set</php> hook.
  - Default values may still be assigned in a constructor, in which case the order-of-actions question is self-evident and obvious.

==== Interaction with serialization ====

The authors are not yet certain of the best approach for serializing properties that implement ''get'' hooks.  (The ''set'' side doesn't really matter.)  See below.

===== Reflection =====

The ''\ReflectionProperty'' object is given a new method ''getHooks(): hooks''.  ''getHooks()'' returns an array of ''\ReflectionMethod'' objects keyed by the hook they are for.  So for example, a property with both ''get'' and ''set'' hook will return a 2 element array with keys ''get'' and ''get'', each of which are a ''\ReflectionMethod'' object.  The order in which they are returned is explicitly undefined.

If an empty array is returned, it means there are no hooks defined.

''\ReflectionProperty'' also has a method ''getHook(string $hook): ?\ReflectionMethod'', which will return the corresponding ''\ReflectionMethod'' object, or null if it is not defined.

The returned ''\ReflectionMethod'' objects will have the class the property is on as its declaring class (returned by ''getDeclaringClass()'').  Its return and parameter types will be as defined by the rules above in the hooks section.

Hooks defined by a parent class's property will be included and available in both cases, the same as if they were defined on the property directly, unless overridden in the child class.

Additionally, ''\ReflectionProperty'' is given a new method ''isVirtual(): bool'', which returns ''true'' if the property has no backing value, and ''false'' if it does.  (That is, all existing properties without hooks will return ''false''.)

==== Attributes ====

Hook implementations are internally implemented as methods.  That means hooks may accept method-targeted attributes.  They may be accessed via reflection in the usual way, once the <php>\ReflectionMethod</php> object is obtained.

<PHP>
#[Attribute(Attribute::TARGET_METHOD]
class A {}

#[Attribute(Attribute::TARGET_METHOD]
class B {}

class C {
    public $prop { 
        #[A] get {}
        #[B] set {}
    }
}

$getAttr = (new ReflectionProperty(C::class, 'prop'))
    ->getHook('get')
    ->getAttributes()[0];
$aAttrib = $getAttr->getInstance();

// $aAttrib is an instance of A.
</PHP>

===== Usage examples =====

We have collected a series of examples that show what we expect to be typical hook usage.  (Or, arguably, the kind of things one could do that wouldn't require adding a method for in case you want to do them in the future.)  It is non-normative, but gives a sense of how hooks can be used to improve a code base (or things that can be added later without needing to create methods "just in case").

In the interest of brevity, we have placed the examples in an external document, available here: [[https://github.com/Crell/php-rfcs/blob/master/property-hooks/examples.md|Usage examples]]

===== Backward Incompatible Changes =====

There is one subtle BC break due to accessing parent property hooks.  Specifically, in this code:

<PHP>
class A {
    public static $prop = 'C';
}

class B extends A {
    public function test() {
        return parent::$prop::get();
    }
}

class C {
    public static function get() {
        return 'Hello from C::get';
    }
}
</PHP>

Currently, <php>parent::$prop</php> would resolve to <php>"C"</php>, and then the <php>C::get()</php> method would be called.

With this RFC, *if* the method name is the same as a hook, then the above code would error out with a message about trying to access a parent hook when not in a hook.  If the method is not the same name as a hook, there is no change in behavior.

The previous logic could be achieved by using a temporary variable:

<PHP>
class B extends A {
    public function test() {
        $class = parent::$prop;
        return $class::get();
    }
}
</PHP>

As the above code is very rare in the wild and rather contrived, and easily worked around, we feel this edge case is acceptable.

===== Open questions =====

==== Serialization ====

There are several serialization contexts to consider:

  * var_dump()
  * var_export()
  * serialize()
  * JsonSerializable

The options are to include a virtual property or not.  It may also make sense for each to have different behavior.

An additional wrinkle is what to do with extended properties that have hooks.  Eg:

<PHP>
class P {
    public int $prop = 42;
}
class C extends P {
    public int $prop {
        get => parent::$prop::get() * 2;
    }
}
$c = new C();
var_dump($c); // C { prop: 42 }
var_dump($c->prop); // 84
</PHP>

The authors request recommendations for how this should be handled.

===== Proposed PHP Version(s) =====

PHP 8.3.

===== Unaffected PHP Functionality =====


===== Future Scope =====

==== beforeSet ====

Swift includes a property hook that runs prior to the set action.  We believe PHP would benefit from such a hook, as that is the most common use case for implementing a <php>set</php> hook.  Such a hook would allow the developer to modify the value before it gets saved, or throw an exception if it fails for some reason.  While both behaviors could be implemented by a <php>set</php> hook, this would avoid the need to create a stub <php>get</php> hook and side variable, as the examples above use.

While the behavior of <php>beforeSet</php> would be fairly straightforward, its implementation is more intricate due to existing optimizations in the engine; there are numerous logic paths that would need to be accounted for.  For that reason it has been omitted from this initial scope.

==== afterSet ====

Swift also includes a property hook that runs after the set action, and is provided with the old value of the property.  That is mainly useful for auditing and logging, such as tracking which properties of an object have been modified.  There are complications in PHP to such a hook, mainly due to the uninitialized state of properties and what should be passed to the hook in that case.  If that problem can be sorted out, we believe it would be a useful addition.

==== isset and unset hooks ====

PHP supports magic methods for <php>__isset</php> and <php>__unset</php>.  While it is tempting to allow those as hooks as well, the authors feel their use is limited and could result in wacky, inconsistent behavior.  They have therefore been omitted.  However, it is possible to reintroduce them in a future RFC should valid use cases be shown.

==== Final hooks ====

As hooks are effectively methods, it's logical to consider whether it should be possible to declare them as "final" the same way, to prevent child classes from adding or overriding hooks on certain properties.  At this time we have omitted that functionality in order to minimize the scope.  Such logic would be straightforward to add in the future, however, if desired.  It would likely be more compelling once additional hooks (such as those above) are added.

==== Reusable hooks ====

Swift has the ability to declare hook "packages" that can be applied to multiple properties, even in separate classes.  That further helps reduce boilerplate, without having to pack even more logic into the type system.  In a sense, it does for hooks what PHP traits do for methods and properties.  While that is potentially useful, it would be a whole big feature unto itself.  The authors therefore opted to avoid that for now.  It is an addition that could be pursued in the future if it's found to be useful.

===== Proposed Voting Choices =====

This is a simple yes-or-no vote to include this feature. 2/3 majority required to pass. 


===== Implementation =====
After the project is implemented, this section should contain 
  - the version(s) it was merged into
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature
  - a link to the language specification section (if any)

===== References =====
Links to external references, discussions or RFCs

===== Rejected Features =====
Keep this updated with features that were discussed on the mail lists.