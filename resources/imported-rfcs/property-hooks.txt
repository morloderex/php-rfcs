====== PHP RFC: Property hooks ======
  * Version: 0.9
  * Date: 2022-12-01
  * Author:  Ilija Tovilo (tovilo.ilija@gmail.com), Larry Garfield (larry@garfieldtech.com)
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/property-hooks
  * Implementation: Pending

===== Introduction =====

Developers often use methods to wrap and guard access to object properties. There are several highly common patterns for such logic, which in practice may be verbose to implement repeatedly.  Alternatively, developers may use <php>__get</php> and <php>__set</php> to intercept reads and writes generically, but that is a sledge-hammer approach that intercepts all undefined (and some defined) properties unconditionally.  Property hooks provide a more targeted, purpose-built took for common property interactions.

The combination of this RFC and the [[rfc:asymmetric-visibility|Asymmetric Visibility]] RFC effectively replicate and replace the previous [[rfc:property_accessors|Property Accessors]] RFC.

The design and syntax below is derived from both Swift and C#, although not an exact copy of either.

===== Proposal =====

This RFC allows attaching one or more of a fixed set of "hooks" to declared properties.  Some hooks are mutually-dependent, while others are effectively independent.  The hooks proposed by this RFC cover most common cases, but in concept more could be added in the future.

The sections below attempt to "build up" the hook design piece by piece.  Some common expected patterns are also included later; this section attempts to be a complete description of the semantic logic.

==== Enabling hooks ====

Because the presence of hooks intercept the read and write process for properties, they cause issues when acquiring a reference to a property.  For that reason, the presence of any hook must necessarily also disallow acquiring a reference to a property.  However, that may technically count as a BC break when adding a hook to a previously-defined property.  For that reason, the syntax allows enabling hooks without defining any; the only effect of doing so is to disallow acquiring a reference to the property.

A property may enable hooks by replacing its '';'' with ''{}'', indicating that zero or more hooks may be included in the brackets in the future.

<code php>
class Point {
    public int $x {}
    public int $y;
}
</code>

In this case, the ''$x'' parameter has enabled hooks, and therefore no reference to it may be obtained.  The ''$y'' parameter has not, and so a reference to it may be obtained.  Otherwise there is no difference in behavior.

The hook block may also be used in constructor property promotion.

<code php>
class Point {
    public function __construct(public int $x {}, public int $y {})
}
</code>

To simplify the implementation, hooks may only be implemented on typed properties.  Additionally, hooks may only be used on object properties.  They may not be used on static class properties.  Nothing in this RFC affects static class properties.

As an important effect of this change, array properties may not be assigned to in-place if hooks are enabled.  That's because doing so requires directly modifying the property without going through a place where hooks can be implemented.  However, the array may be requested, modified, and reassigned.  In code:

<code php>
class MyList {
    public array $values = [] {}
}

$l = new MyList();

// This will fail.
$l->values[] = 1;

// But this is allowed.
$a = $l->values;
$a[] = 1;
$l->values = $a;
</code>

While not ideal, it is an unavoidable impact of disabling direct access to a property.

==== get and set ====

The ''get'' and ''set'' hooks overwrite the PHP default read and write behavior.  They may be implemented individually or together.  If either one is implemented, PHP will not create any storage property on the object.  The developer is on their own to implement whatever storage behavior is appropriate.

=== get ===

If a ''get'' hook is implemented, then PHP will create no automatic storage for that property.  Instead, reads of that property will invoke the defined hook.

<code php>
class User
{
    public function __construct(private string $first, private string $last) {}
    
    public string $fullName {
        get { 
            return $this->first . " " . $this->last;
        }
    }
}

$u = new User('Larry', 'Garfield');

// prints "Larry Garfield"
print $u->fullName;
</code>

The ''get'' hook body is an arbitrarily complex method body, which MUST return a value that is type compatible with the property.

If a ''get'' hook is defined but no ''set'' hook, then any attempt to write to the property will result in an error.

=== set ===

If a ''set'' hook is implemented, then PHP will create no automatic storage for that property.  Instead, writes to that property will invoke the defined hook.

<code php>
class User
{
    public function __construct(private string $first, private string $last) {}
    
    public string $fullName {
        get { 
            return $this->first . " " . $this->last;
        }
        set ($value) {
            [$this->first, $this->last] = explode(' ', $value);
        }
    }
    
    public function getFirst(): string
    {
        return $this->first;
    }
}

$u = new User('Larry', 'Garfield');

$u->fullName = 'Ilija Tovilo';

// prints "Ilija"
print $u->getFirst();
</code>

The ''set'' hook body is an arbitrarily complex method body, which accepts one argument and has a void return.  The argument is not typed, but PHP will throw a TypeError if the value provided is not of the same type defined on the property.

ILIJA: I'm still open to allowing this to be enforced on return, not on set, so that the set hook can type-normalize a value.  Is that doable? Can I convince you to allow that?

Specifying the argument name is optional.  If not specified, it defaults to ''$value''.  That is, the following ''set'' hook is identical to the previous:

<code php>
    public string $fullName {
        get { 
            return $this->first . " " . $this->last;
        }
        set {
            [$this->first, $this->last] = explode(' ', $value);
        }
    }
</code>

If a ''set'' hook is defined but no ''get'' hook, then any attempt to read from the property will result in an error.  Such "write only" properties are of limited (but probably non-zero) value, but do not cause any issues for other functionality.

In practice, most ''set'' implementations will also include a ''get'', but not all ''get'' implementations will include a ''set''.

==== beforeSet ====

The ''beforeSet'' hook intercepts values before they are assigned to a property, and optionally modifies them.  It does not affect PHP's storage of the value; that is, if only ''beforeSet'' is implemented, there will still be a real value stored on a real property on the object.  ''beforeSet'' may be used for validation or sanitization.

<code php>
class User {
    
    public string $username {
        beforeSet($value) {
            return strtolower($value);
        }
    }
}

$u = new User();

$u->username = "JamesKirk";

// prints "jameskirk"
print $u->username;
</code>

The ''beforeSet'' hook body is an arbitrarily complex method body, which accepts one untyped argument.  It MUST return a value, and that value MUST be type-compatible with the property.  In this example, the value is being sanitized to lowercase.  If the hook wishes to modify the value being saved conditionally, it may do so and sometimes return ''$value'' unmodified.

Specifying the argument name is optional.  If not specified, it defaults to ''$value''.

A ''beforeSet'' hook may also be used for validation by throwing an exception should the value not meet some arbitrary criteria.

<code php>
class User {
    
    public string $username {
        beforeSet($value) {
            if (strlen($value) > 10) throw new \InvalidArgumentException('Too long');
            return strtolower($value);
        }
    }
}
</code>

Whatever value is returned from ''beforeSet'' will be assigned to the property, either directly or through a defined ''set'' hook.

==== afterSet ====

The ''afterSet'' hook intercepts values after they are assigned to a property.  They may not modify the property, but may read from it.  If a ''get'' hook is defined, the read attempt will invoke the ''get'' hook.  The ''afterSet'' hook is mainly useful for logging or change tracking.

<code php>
class Person {
    private array $modified = [];
    
    public string $name {
        afterSet($value) {
            $this->modified['name'] = $value;
        }
    }

    public int $age {
        afterSet($value) {
            $this->modified['age'] = $value;
        }
    }
    
    public function save(): void
    {
        foreach (array_keys($this->isModified) as $prop => $val) {
            print "$prop was set to $val\n";
        }
    }
}

$p = =new Person();

$p->name = 'Larry';

// prints: name was set to Larry
$p->save();
</code>

The ''afterSet'' hook body is an arbitrarily complex method body, which accepts one untyped argument and is return void.

Specifying the argument name is optional.  If not specified, it defaults to ''$value''.

==== Scoping ====

All hooks operate in the scope of the object being modified.  That means they have access to all public, private, or protected methods of the object, as well as any public, private, or protected properties, including properties that may have their own property hooks.  Accessing another property from within a hook does not bypass the hooks defined on that property.

The most notable implication of this is that non-trivial hooks may stub out to an arbitrarily complex method if they wish.  For example:

<code php>
class Person {
    public string $phone {
        beforeSet { return $this->sanitizePhone($value); }
    }
    
    private function sanitizePhone(string $value): string
    {
        $value = ltrim($value, '+');
        $value = ltrim($value, '1');

        if (!preg_match('/\d\d\d\-\d\d\d\-\d\d\d\d/', $new)) {
            throw new \InvalidArgumentException();
        }
        return $new;
    }
}
</code>

==== Abbreviated forms ====

There are two shorthand notations supported, beyond the optional argument to ''set'', ''beforeSet'', and ''afterSet''.

First, if a hook's body is a single expression, then the ''{ }'' and ''return'' statement may be omitted and replaced with ''=>'', just like with arrow functions.

Second, if there is one and only one hook, and that hook is ''get'', then the hook name and wrapping ''{}'' may be omitted and replaced with ''=>''.

That means the following three examples are all semantically identical:

<code php>
class User
{
    public function __construct(private string $first, private string $last) {}
    
    public string $fullName {
        get { 
            return $this->first . " " . $this->last;
        }
    }
}

class User
{
    public function __construct(private string $first, private string $last) {}
    
    public string $fullName {
        get => $this->first . " " . $this->last;
    }
}

class User
{
    public function __construct(private string $first, private string $last) {}
    
    public string $fullName => $this->first . " " . $this->last;
}
</code>

For void-return hooks, if the single-expression results in a value it will be silently discarded.  That is, the following is an example of legal syntax:

<code php>
class User
{

    private array $modified = [];

    public string $fullName {
        get => $this->first . " " . $this->last;
        set => [$this->first, $this->last] = explode(' ', $value);
        beforeSet => \ucfirst($value);
        afterSet => $this->modified['first'] = true && $this->modified['last'] = true;
    }

    public function __construct(private string $first, private string $last) {}
}
</code>

By way of comparison, here is the same logic implemented via methods in PHP 8.2:

<code php>
class User
{
    private array $modified = [];
    
    public function __construct(private string $first, private string $last) {}
    
    public function getFullName(): string
    {
        return $this->first . " " . $this->last;
    }
    
    public function setFullName(string $value): void
    {
        $value = \ucfirst($value);
        [$this->first, $this->last] = explode(' ', $value);
        $this->modified['first'] = true;
        $this->modified['last'] = true;
    }
}
</code>

==== Interaction with asymmetric visibility ====

The [[rfc:asymmetric-visibility|Asymmetric Visibility]] introduces separate access control for ''get'' and ''set'' operations.  That visibility applies the same regardless of what if any hooks are implemented.  As the syntax for asymmetric visibility is confined to the left side of the property and hooks to the right, they do not interact syntactically at all.

==== Interaction with readonly ====

''readonly'' properties have the effect of forcing private ''set'' scope, and limiting the property to a single ''set'' operation.  That behavior is independent of hooks, and therefore the two are compatible.

The one caveat is if a ''get'' hook is implemented.  It is entirely possible for a ''get'' hook to return different values at different times (say, if the ''$first'' property were modified, as in the examples above).  That may give the appearance of a property being non-readonly when it actually is.

ILIJA: I don't actually know what we should do here.  Make ''readonly'' mean cache?  Disallow it?  Say "caveat coder?"  I'm not sure.

==== Interaction with magic methods ====

If a class has properties that implement hooks, they are therefore defined, and cannot be "unset".  Therefore, a <php>__get</php> or <php>__set</php> method will never be called for those properties.  They will be called for truly undefined properties just as they always have been.

==== Interaction with isset() and unset() ====

If a property implements hooks other than ''get'' or ''set'', then ''isset()'' is unaffected.  Additionally, ''afterSet'' and ''beforeSet'' will not be called if a property is ''unset()''.

If a property implements ''get'', then ''isset()'' will invoke the ''get'' hook and return true if the value is non-null.  That is, ''isset($o->foo)'', where ''$foo'' has a ''get'' hook, is equivalent to ''!is_null($o->foo)''.  This behavior is consistent with how ''isset()'' interacts with <php>__get</php> today.

If a property implements ''get'' or ''set'', then ''unset()'' may not be invoked on the property.  Doing so will result in an error.  As there is no stored property by that name to unset, the operation is meaningless.

ILIJA: Check this section.  Does this make logical sense?

==== Interaction with constructor property promotion ====

As of PHP 8.0, properties may be declared inline with the constructor.  That creates an interesting potential for complexity if the property also includes hooks, as the hooks may be arbitrarily complex, and therefore long, leading to potentially tens of lines of code technically within the constructor's method signature.

On the other hand, the ''beforeSet'' hook in particular is extremely useful for validation, including validation on promoted properties.  Making them incompatible would undercut the value of both tremendously.  That is true to a lesser extent for ''afterSet''.  (Properties with ''get'' and ''set'' hooks make little sense to include in promotion.)

After much consideration, the authors have opted to allow hooks to be implemented within constructor property promotion.  While pathological examples could certainly be shown, we anticipate in practice that the impact will be far less.  In particular, the shorthand version of hook bodies and the ability to call out to private methods if they get complicated partially obviate the concern about syntactic complexity.

For example, we predict the following to be the extent of most combinations of hooks and promotion:

<code php>
class User
{
  public function __construct(
    public string $username { beforeSet => strtolower($username); }
  ) {}
}
</code>

Which is, all things considered, not too bad for the level of power it gives.

==== Inheritance ====

A child class may define or redefine individual hooks on a property by redefining the property and just the hooks it wishes to override.  The type and visibility of the property are subject to their own rules independently of this RFC.

A child class may also add hooks to a property that had none, nor opted in to hooks.

ILIJA: Not sure about this one, as it could be an LSP issue the same as disabling references is.  Thoughts?

<code php>
class Point
{
    public int $x {}
    public int $y {}
}

class PositivePoint extends Point
{
  public int $x {
      beforeSet($x) => $x >= 0 ? $x : throw new \InvalidArgumentException('Too small');
  }
}
</code>

Each hook overrides parent class implementations independently of each other.

Hooks may also be declared ''final'', in which case they may not be overridden.

<code php>
class User 
{
    
    public string $username {
        final beforeSet($value) => strtolower($value);
    }
}

class Manager extends User
{
    public string $username {
        // This is allowed
        afterSet => $this->modifications['username'] => true;
        // But this is NOT allowed, because beforeSet is final in the parent.
        beforeSet => strtoupper($value);
    }
}
</code>

If the property itself is declared ''final'', then hooks could not be overridden anyway.  Therefore, declaring hooks ''final'' on a property that is declared ''final'' will throw an error.

ILIJA: Do we also want abstract hooks?  Nikita's RFC had it, but I'm not sure if they make sense. 

===== Reflection =====

ILIJA: Oh dear oh dear...

===== Usage examples =====

TODO: LARRY

===== Backward Incompatible Changes =====

None.  

===== Proposed PHP Version(s) =====

PHP 8.3.

===== RFC Impact =====

===== Open Issues =====
Make sure there are no open issues when the vote starts!

===== Unaffected PHP Functionality =====

This RFC has been designed alongside asymmetric visibility in such a way that either one can pass or fail on its own, and whatever passes is still useful.  Both may also pass, and they will naturally dovetail together.

===== Future Scope =====

==== Properties in interfaces ====

Nikita's original property accessor RFC included the ability to define properties as part of an interface, and specifically that a property needed to be readable and/or writeable.  The authors of this RFC have omitted that feature for now.  It is a good and useful feature that would be valuable to add, but it's better to keep this RFC focused on just the hooks themselves.  The authors would support such an RFC in the future, and time permitting may consider it themselves.

==== isset and unset hooks ====

PHP supports magic methods for <php>__isset</php> and <php>__unset</php>.  While it is tempting to allow those as hooks as well, the authors feel their use is limited and could result in wacky, inconsistent behavior.  They have therefore been omitted.  However, it is possible to reintroduce them in a future RFC should valid use cases be shown.

==== readonly ====

It may be feasible to further integrate ''readonly'' with hooks in the future.  That is a task for a future RFC.

===== Proposed Voting Choices =====

This is a simple yes-or-no vote to include this feature. 2/3 majority required to pass. 


===== Implementation =====
After the project is implemented, this section should contain 
  - the version(s) it was merged into
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature
  - a link to the language specification section (if any)

===== References =====
Links to external references, discussions or RFCs

===== Rejected Features =====
Keep this updated with features that were discussed on the mail lists.