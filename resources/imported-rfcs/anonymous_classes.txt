
====== PHP RFC: Anonymous Classes ======
  * Version: 0.1
  * Date: 2013-09-22
  * Author: Joe Watkins, krakjoe@php.net
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/anonymous_classes

===== Introduction =====

For some time PHP has featured anonymous function support in the shape of Closures; this patch introduces the same kind of functionality for objects of an anonymous class.

The ability to create objects of an anonymous class is an established and well used part of Object Orientated programming in other languages.

An anonymous class might be used over a named class:
  * when the class does not need to be documented
  * when the class is used only once during execution

The scope for use is so wide, it is hard to suggest specific use cases; the general use case is throw away implementation of interfaces and abstracts that meet the criteria above.

An anonymous class is a class without a (programmer declared) name, the functionality of the object is no different from that of an object of a named class.
===== Backward Incompatible Changes =====

New syntax that will fail to parse in previous versions, so no BC breaks.

===== Proposed PHP Version(s) =====

5.6

===== SAPIs Impacted =====

All

===== Impact to Existing Extensions =====

No impact on existing libraries




===== Open Issues =====

The question of whether or not to disable serialization for anonymous objects.

===== Future Scope =====

This patch opens the door for, or appears to go hand in hand with, (named) nested classes
   https://github.com/krakjoe/php-src/compare/anon_class_objects...nested_classes 
which opens the door for access modification on class declarations (no patch yet)
which all makes for more flexible/powerful OO.

Note: the patch above is buggy, a proof of concept is all ...
===== Proposed Voting Choices =====

Straight forward, we should have this, we should not have this.

===== Syntax =====

new class {definition} (arguments)

The above syntax is used to avoid conflicts with existing rules in the grammar file.

<code php>
<?php
/* implementing an anonymous console object from your framework maybe */
(new class extends ConsoleProgram {
    public function main() {
       /* ... */
    }
})->bootstrap();

/* return an anonymous implementation of a Page for your MVC framework */
return new class implements Page {
    public function __construct($controller) {
        /* ... */
    }
    /* ... */
} ($controller);

/* vs */
class MyPage implements Page {
    public function __construct($controller) {
        /* ... */
    }
    /* ... */
}
return new MyPage($controller);

/* return an anonymous extension of the DirectoryIterator class */
return new class extends DirectoryIterator {
   /* ... */
} ($path);

/* vs */
class MyDirectoryIterator {
    /* .. */
}
return new MyDirectoryIterator($path);

/* return an anon class from within another class (introduces the first kind of nested class in PHP) */
class MyObject extends MyStuff {
    public function getInterface() {
        return new class implements MyInterface {
            /* ... */
        };
    }
}
?>
</code>

Note: the ability to declare and use a constructor in an anonymous class is necessary where control over construction must be exercised.

===== Code Paths =====

Code such as:

<code php>
while ($i++<10) {
    class myNamedClass {
        /* ... */
    }
}
</code>

will fail to execute, however code such as:

<code php>
while ($i++<10) {
  new class {};
}
</code>

will work as expected: the definition will be re-used, creating a new object.

===== Inheritance =====

Some have queried how inheritance might work and suggested the utilization of the "use" statement.

This doesn't appear to be necessary:

<code php>
<?php
class Outer {
    protected $data;
    
    public function __construct($data) {
        /* array access will be implemented by the time we get to here */
        $this->data = $data;
    }
    
    public function getDataProxy() {
        /* create a proxy object implementing array access */
        return new class extends Outer implements ArrayAccess {
            public function offsetGet($offset) { return $this->data[$offset]; }
            public function offsetSet($offset, $data) { return ($this->data[$offset] = $data); }
            public function offsetUnset($offset) { unset($this->data[$offset]); }
            public function offsetExists($offset) { return isset($this->data[$offset]); }
        }($this->data);
    }
}

$outer = new Outer($_SERVER);
$proxy = $outer->getDataProxy();

var_dump($proxy["argv"]);
var_dump($proxy["argc"]);
?>
</code>

The code above will work as expected with the current implementation, and introduces the first kind of inner/private class, at no extra cost, co-incidentally they are anonymous.

Note: anonymous classes are compiled once during compilation, multiple calls to publicMethod at execution time will result in the same anonymous definition being used multiple times.
===== Implementation =====

https://github.com/php/php-src/pull/470

===== Rejected Features =====

N/A