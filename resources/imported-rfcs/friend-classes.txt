====== PHP RFC: Class Friendship ======
  * Version: 0.1
  * Date: 2015-12-10
  * Author: Dustin Wheeler, mdwheele@ncsu.edu
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/friend-classes



===== Introduction =====
Class Friendship allows a class to be better encapsulated by granting per-class access to protected properties that would otherwise have to be marked public. This affords developers an opportunity to better-model objects as behavioural units while making-explicit presentation concerns through friendship. Class Friendship is a valuable expression for object modeling when used properly. It also has value in Characterization Testing as a short-term strategy for refactoring legacy applications. It provides a natural marker / target for further work through explicit friend relationships between Systems Under Test and their test cases.

There have been discussions around the topic of limited-visibility collaborators amongst the PHP community. Among these, an effort for "package-private" or otherwise vendor-namespaced private collaborators has been suggested as a solution to a class of problem that is currently solved through convention; exposing implementation details and using doc-block "@internal" tags to mark properties as "package-private"! This is sometimes a necessary evil in frameworks and other core components. This convention could be alleviated through use of class friendship, but is not necessarily an appropriate use of the feature. Vendor namespacing or true package private classes are a better fit, albeit possibly in the same problem-space.

===== Proposal =====
Support for class friendship is added through a new keyword, ''friend''. It allows per-class access to protected properties as follows:

==== Basic Usage ====
A subject class may declare another class a friend through the use of a new ''friend'' keyword similar to how Traits are implemented. This enables the named friend class access to protected properties of the subject. There are other properties of Class Friendship, as implemented in C++. These properties are described below. 

C++ implements Class Friendship such that friends have access to both private and protected properties. In discussing this implementation detail, there was concern that allowing unfettered access to all properties risked exposing intentionally hidden implementation details local to a given unit whereby a developer absolutely did not want the given property accessible by any means other than the subject class. This RFC suggests that friend classes in PHP only have access to protected and higher properties. 

Below, a class ''Person'' declares ''PersonFormatter'' as a friend for the purposes of separating presentation concerns:

<code php>
class Person
{
    friend PersonFormatter;
    
    protected $firstName;
    protected $lastName;

    public function __construct($firstName, $lastName)
    {
        $this->firstName = $firstName;
        $this->lastName = $lastName;
    }

    public function format()
    {
        return new PersonFormatter($this);
    }
}
</code>

<code php>
class PersonFormatter
{
    private $person;
    
    public function __construct(Person $person)
    {
        $this->person = $person;
    }

    public function getFullName()
    {
        // PersonFormatter would not have access to protected properties
        // of Person if not explicitly listed as a friend.
        return $this->person->firstName . ' ' . $this->person->lastName;
    }
}
</code>

<code php>
$person = new Person('Alice', 'Wonderland');
$formatter = $person->format();

var_dump($formatter->getFullName()); // string(16) "Alice Wonderland"
</code>

Class friendship can also be used to implement characterization tests as part of a refactoring project for legacy applications. Consider the following class responsible for executing a Fibonacci sequence:

<code php>
class Fibonacci
{
    friend FibonacciTest;

    protected $previous;
    protected $current;
    
    public function __construct()
    {
        $this->previous = 0;
        $this->current = 0;
    }
    
    public function next()
    {
        $current = $this->current;
        $next = $this->previous + $this->current;
        
        if ($next == 0) { 
            $next = 1; 
        }

        $this->previous = $this->current;
        $this->current = $next;
        
        return $current;
    }
}
</code>

<code php>
class FibonacciTest
{
    public function testAssignmentAlgoForStateIsCorrect()
    {
        $fibo = new Fibonacci();
        
        $this->assertEquals(0, $fibo->previous);
        $this->assertEquals(0, $fibo->current);
        
        $n0 = $fibo->next();
        
        $this->assertEquals(0, $n0);
        $this->assertEquals(0, $fibo->previous);
        $this->assertEquals(1, $fibo->current);
        
        // ... and so on ...
    }
}
</code>

Characterization Tests are a form of white-box test useful for describing the **current actual** behaviour of a unit. They are usually a temporary measure used to verify that modifications made to a system to not have unintended or undesirable changes in **how** the system works. These tests are useful to initiate a refactoring loop. Friend designations are also a good marker for follow-up work to improve units. This may possibly eliminate the need for white-box tests after improving the behavioural API of the system under test.

Currently, in many examples, we have to either change visibility of properties that only exist for implementation, provide meaningless getters to these properties (thus polluting the public API of the object and risking abuse by other objects) or navigate the Reflection API or Proxy implementations. We really want to declare a limited set of collaborators privileged access to these properties for a single purpose in the use-case for Characterization Tests.

==== Other Properties ====
There are several rules of class friendship that clarify how the feature works with regard to direction, transitivity and inheritance. 
 
=== Friendships are not symmetric ===
If class ''A'' is a friend of class ''B'', class ''B'' is **NOT** automatically a friend of class ''A''.

=== Friendships are not transitive ===
If class ''A'' is a friend of class ''B'', and class ''B'' is a friend of class ''C'', class ''A'' is not automatically a friend of class ''C''.

=== Friendships are not inherited ===
A friend of class ''Base'' is not automatically a friend of class ''Derived'' and vice versa; equally if ''Base'' is a friend of another class, ''Derived'' is not automatically a friend and vice versa.

=== Access due to friendship is inherited ===
A friend of ''Derived'' can access the protected members of ''Derived'' that were inherited from ''Base''. Note, however, that a friend of ''Derived'' only has access to members inherited from ''Base'' to which ''Derived'' has access, itself, (e.g. if ''Derived'' inherits from ''Base'', ''Derived'' only has access to the protected (and public) members inherited from ''Base'', not private members, so neither does a friend.)

<code php>
class Base
{
    private $secret = 'to everyone but Base';
    protected $accessible = 'to child classes of Base';
    
    public function touch()
    {
        echo $this->secret . PHP_EOL;
    }
}
</code>

<code php>
class Derived extends Base
{
    friend Friendly;

    protected $someProperty = 'that will be accessed via normal Friend functionality';
}
</code>

<code php>
class Friendly
{
    public function touch(Derived $derived)
    {
        var_dump($derived->someProperty); // string(%d) "that will be accessed ... functionality"
        
        var_dump($derived->accessible);   // string(%d) "to child classes of Base"
                                          // While Friendly is not a friend of Base, it can still access this 
                                          // property because it is accessible to Derived, for which it *is* 
                                          // a friend.
                                                                       
        var_dump($derived->secret);       // Notice: Undefined property: Derived::$secret ...
    }
}
</code>

<code php>
$derived = new Derived();
$friendly = new Friendly

$derived->touch(); // Output: "to everyone but Base"
$friendly->touch($derived);
</code>

==== Errors ====
In all cases above, the error message received is no different than if you attempted to access private or protected properties of a class through traditional means. That is to say, the error message will not hint ''"Whoops! You don't have access to this property because friendship isn't symmetric."''. 

==== Additional Thoughts ====
I have purposely kept this RFC fairly slim for a number of reasons. First and foremost, I want to make it clear that I do **not** see this feature in competition with any other RFC or suggestion for limited-visibility collaborators. Rather, I see it working in concert with something like namespace visibility or package-privacy. I feel that class friendship is about object modeling and making explicit privileged relationships between two or more classes. It is a form of tighter coupling to achieve better encapsulation of behaviour.

Secondly, the RFC is purposefully (yet still usefully) slim to "test the waters" on such a feature for inclusion in PHP. This may not be the most popular feature in the world, but I believe that it does scratch a considerable itch for the testing and object modeling communities overlapping the PHP community. This RFC fulfills an 80% use-case (80/20) for the spirit of class friendship and paves the way for further implementation of:

  * Friendship to global function
  * Friendship to a single class method
  * Friendship to a namespace (caveat)

While namespace friendship might seem like a good idea, it is actually more "in the vein" of "package-privacy" or "namespace visibility" and begins to leave what many consider the spirit of class friendship. There are uses where this is not the case, which is why I have included it. 

===== Proposed PHP Version(s) =====
This proposal targets the next minor version of PHP, which at the time of this writing is PHP 7.1.

===== RFC Impact =====
==== To Opcache ====
This is an open issue pending code review. I am unfamiliar-enough with Opcache implementation to be able to appropriately assess impact.

==== To Reflection API ====
New methods are added to ''ReflectionClass'':

  - ''public array ReflectionClass::getTraitNames(void)'' - Returns an array of friend names on current class. Returns ''NULL'' in case of error.
  - "public array ReflectionClass::getTraits(void)'' - Returns associative array of friend names in keys and instances of friend's ''ReflectionClass'' in values. Returns ''NULL'' in case of error.

===== Open Issues =====
==== Policy ====
  * Implementation requires code review to advise on improvements as well as inform that opcache was appropriately considered
  * Verify current PHP functionality around class property visibility is undisturbed
  * Add example for access inheritance

==== Reflection API ====
  * Implement addition of a ''getFriends'' method to ''ReflectionClass''

===== Future Scope =====
While this RFC specifies friendship between classes, there is opportunity to extend this implementation and syntax:

  * Friendship to global functions 
  * Friendship to class methods
  * Friendship to namespace(s)

===== Proposed Voting Choices =====

This RFC proposes two voting choices:

  - Should friend classes be added to PHP (yes / no)?
  - Should friends have access to private members (yes / no)?

As this is a language change, a 2/3 majority is required for whether to add Friend Classes to PHP. (see [[voting]])

===== Patches and Tests =====
I have implemented the RFC as described with tests to verify all usage examples above. I will link this as soon as I am able and will open a pull request against ''master'' to monitor TravisCI build status as I make changes.

As this is my first contribution to PHP, it is my opinion that my request should be placed under higher scrutiny and I am completely ready and willing to accept all feedback to improve implementation.

===== References =====
  - https://bugs.php.net/bug.php?id=34044
  - http://stackoverflow.com/questions/317835/php-equivalent-of-friend-or-internal
  - https://marc.info/?l=php-internals&m=144639394529142
  - http://ocramius.github.io/blog/accessing-private-php-class-members-without-reflection/
  - http://www.stroustrup.com/hopl2.pdf
  - http://tekwire.net/joomla/projects/ideas/php-friend

===== Changelog =====
  * v0.1 - Created