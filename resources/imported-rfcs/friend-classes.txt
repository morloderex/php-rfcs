====== PHP RFC: Class Friendship ======
  * Version: 0.1
  * Date: 2015-12-10
  * Author: Dustin Wheeler, mdwheele@ncsu.edu
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/friend-classes



===== Introduction =====
Class Friendship allows a class to be better encapsulated by granting per-class access to protected properties. Class Friendship is an explicit and concise expression of tight-coupling between collaborators that separates concerns delegated to a friended class for purposes of better encapsulation of behaviour. This affords developers an opportunity to better-model objects as behavioural "tell don't ask" units while explicating concerns like presentation through friendship. Class Friendship is a valuable expression for object modeling when used properly. It also has value in white-box testing as a tactical refactoring tool when approaching legacy applications. 

A common use-case for friendship here is separating presentation concerns from what would otherwise be a "tell don't ask" behavioral unit or write model. This can be applied in a variety of scenarios. Without this feature, developers are left with a trade-off of marking internal properties public to make them available and sacrificing design opportunities torwards the future. Another common occurrence is the addition of getters that simply proxy internal state and grow the public API of a unit by necessity. To be sure, this feature is not merely about pulling off "access to protected class members", but about modeling a semantic relationship between two collaborators. In fact, access to private and protected class properties is already possible through closure scope "juggling" or nasty use of `debug_backtrace`. Both of these are included in references below. While it is technically possible to execute friend-like features in user-land, it would be preferable to concisely represent the relationship with a known and well-documented concept supported by the language.

The purpose of the feature should not be conflated / confused with the goals of something like package-private classes or namespace visibility, in general. I feel those features apply more closely to the types of behaviors user-land sees in Symfony (and other framework) packages that mark properties as ''@internal'' but are forced to make them public to share access between internal data structures. I don't necessarily feel that class friendship is the "Right Answer TM" in this case, but I think that the dance package developers currently have to do to express "don't use this property, we use this internally to help you" is worth improving.

===== Proposal =====
Support for class friendship is added through a new keyword, ''friend''. It allows per-class access to protected properties as follows:

==== Basic Usage ====
A subject class may declare another class a friend through the use of a new ''friend'' keyword similar to how Traits are implemented. This enables the named friend class access to protected properties of the subject. There are other properties of Class Friendship, as implemented in C++. These properties are described below. 

C++ implements Class Friendship such that friends have access to both private and protected properties. [[https://marc.info/?l=php-internals&m=144972388219786&w=2|In discussing this implementation detail]], there was concern that allowing unfettered access to all properties risked exposing intentionally hidden implementation details local to a given unit whereby a developer absolutely did not want the given property accessible by any means other than the subject class. This RFC suggests that friend classes in PHP only have access to protected and higher properties. 

Below, a class ''Person'' declares ''HumanResourceReport'' as a friend for the purposes of separating presentation concerns:

<code php>
class Person
{
    friend HumanResourceReport;
    
    protected $id;
    protected $firstName;
    protected $lastName;

    public function __construct($id, $firstName, $lastName)
    {
        $this->id = $id;
        $this->firstName = $firstName;
        $this->lastName = $lastName;
    }

    public function makeReport()
    {
        return new HumanResourceReport($this);
    }
}
</code>

<code php>
class HumanResourceReport
{
    private $person;
    
    public function __construct(Person $person)
    {
        $this->person = $person;
    }

    public function getFullName()
    {
        // PersonFormatter would not have access to protected properties
        // of Person if not explicitly listed as a friend.
        return $this->person->firstName . ' ' . $this->person->lastName;
    }
    
    public function getReportIdentifier()
    {
        return "HR_REPORT_ID_{$this->person->id}";
    }
}
</code>

<code php>
$person = new Person(Uuid::uuid4(), 'Alice', 'Wonderland');
$report = $person->makeReport();

var_dump($report->getFullName()); // string(16) "Alice Wonderland"
var_dump($report->getReportIdentifier()); // string(49) "HR_REPORT_ID_3F2504E0-4F89-41D3-9A0C-0305E82C3301"
</code>

Class friendship can also be used to implement white-box (characterization) tests as part of a refactoring project for legacy applications. Consider the following class responsible for executing a Fibonacci sequence:

<code php>
class Fibonacci
{
    friend FibonacciTest;

    protected $previous;
    protected $current;
    
    public function __construct()
    {
        $this->previous = 0;
        $this->current = 0;
    }
    
    public function next()
    {
        $current = $this->current;
        $next = $this->previous + $this->current;
        
        if ($next == 0) { 
            $next = 1; 
        }

        $this->previous = $this->current;
        $this->current = $next;
        
        return $current;
    }
}
</code>

<code php>
class FibonacciTest
{
    public function testAssignmentAlgoForStateIsCorrect()
    {
        $fibo = new Fibonacci();
        
        $this->assertEquals(0, $fibo->previous);
        $this->assertEquals(0, $fibo->current);
        
        $n0 = $fibo->next();
        
        $this->assertEquals(0, $n0);
        $this->assertEquals(0, $fibo->previous);
        $this->assertEquals(1, $fibo->current);
        
        // ... and so on ...
    }
}
</code>

Characterization Tests are a form of white-box test useful for describing the **current actual** behaviour of a unit given knowledge of that unit's internals. They are usually a tactical measure used to verify that modifications made to a system to not have unintended or undesirable changes in **how** the system works. These tests are useful to initiate a refactoring loop. Friend designations are also a good marker for follow-up work to improve units. This may possibly eliminate the need for white-box tests after improving the behavioural API of the system under test.

Currently, in many examples, we have to either change visibility of properties that only exist for implementation, provide meaningless getters to these properties (thus polluting the public API of the object and risking abuse by other objects) or navigate the Reflection API or Proxy implementations. We really want to declare a limited set of collaborators privileged access to these properties for a single purpose in the use-case for these types of tests.

==== Other Properties ====
There are several rules of class friendship that clarify how the feature works with regard to direction, transitivity and inheritance. 
 
=== Friendships are not symmetric ===
If class ''A'' is a friend of class ''B'', class ''B'' is **NOT** automatically a friend of class ''A''.

=== Friendships are not transitive ===
If class ''A'' is a friend of class ''B'', and class ''B'' is a friend of class ''C'', class ''A'' is not automatically a friend of class ''C''.

=== Friendships are not inherited ===
A friend of class ''Base'' is not automatically a friend of class ''Derived'' and vice versa; equally if ''Base'' is a friend of another class, ''Derived'' is not automatically a friend and vice versa.

=== Access due to friendship is inherited ===
A friend of ''Derived'' can access the protected members of ''Derived'' that were inherited from ''Base''. Note, however, that a friend of ''Derived'' only has access to members inherited from ''Base'' to which ''Derived'' has access, itself, (e.g. if ''Derived'' inherits from ''Base'', ''Derived'' only has access to the protected (and public) members inherited from ''Base'', not private members, so neither does a friend.)

<code php>
class Base
{
    private $secret = 'to everyone but Base';
    protected $accessible = 'to child classes of Base';
    
    public function touch()
    {
        echo $this->secret . PHP_EOL;
    }
}
</code>

<code php>
class Derived extends Base
{
    friend Friendly;

    protected $someProperty = 'that will be accessed via normal Friend functionality';
}
</code>

<code php>
class Friendly
{
    public function touch(Derived $derived)
    {
        var_dump($derived->someProperty); // string(%d) "that will be accessed ... functionality"
        
        var_dump($derived->accessible);   // string(%d) "to child classes of Base"
                                          // While Friendly is not a friend of Base, it can still access this 
                                          // property because it is accessible to Derived, for which it *is* 
                                          // a friend.
                                                                       
        var_dump($derived->secret);       // Notice: Undefined property: Derived::$secret ...
    }
}
</code>

<code php>
$derived = new Derived();
$friendly = new Friendly

$derived->touch(); // Output: "to everyone but Base"
$friendly->touch($derived);
</code>

==== Errors ====
In all cases above, the error message received is no different than if you attempted to access private or protected properties of a class through traditional means. That is to say, the error message will not hint ''"Whoops! You don't have access to this property because friendship isn't symmetric."''. 

==== Additional Thoughts ====
I have purposely kept this RFC fairly slim for a number of reasons. First and foremost, I want to make it clear that I do **not** see this feature in competition with any other RFC or suggestion for limited-visibility collaborators. Rather, I see it working in concert with something like namespace visibility or package-privacy. I feel that class friendship is about object modeling and making explicit privileged relationships between two or more classes. It is a form of tighter coupling to achieve better encapsulation of behaviour.

Secondly, the RFC is purposefully (yet still usefully) slim to "test the waters" on such a feature for inclusion in PHP. This may not be the most popular feature in the world, but I believe that it does scratch a considerable itch for the testing and object modeling communities overlapping the PHP community. This RFC fulfills an 80% use-case (80/20) for the spirit of class friendship and paves the way for further implementation of:

  * Friendship to global function
  * Friendship to a single class method
  * Friendship to a namespace (caveat)

While namespace friendship might seem like a good idea, it is actually more "in the vein" of "package-privacy" or "namespace visibility" and begins to leave what many consider the spirit of class friendship. There are uses where this is not the case, which is why I have included it. 

===== Proposed PHP Version(s) =====
This proposal targets the next minor version of PHP, which at the time of this writing is PHP 7.1.

===== RFC Impact =====
==== To Opcache ====
This is an open issue pending code review. I am unfamiliar-enough with Opcache implementation to be able to appropriately assess impact.

==== To Reflection API ====
New methods are added to ''ReflectionClass'':

  - ''public array ReflectionClass::getTraitNames(void)'' - Returns an array of friend names on current class. Returns ''NULL'' in case of error.
  - ''public array ReflectionClass::getTraits(void)'' - Returns associative array of friend names in keys and instances of friend's ''ReflectionClass'' in values. Returns ''NULL'' in case of error.

===== Open Issues =====
==== Policy ====
  * Implementation requires code review to advise on improvements as well as inform that opcache was appropriately considered
  * Verify current PHP functionality around class property visibility is undisturbed
  * Add example for access inheritance

==== Reflection API ====
  * Implement addition of a ''getFriends'' method to ''ReflectionClass''

===== Future Scope =====
While this RFC specifies friendship between classes, there is opportunity to extend this implementation and syntax:

  * Friendship to global functions 
  * Friendship to class methods
  * Friendship to namespace(s)

===== Proposed Voting Choices =====

This RFC proposes two voting choices:

  - Should friend classes be added to PHP (yes / no)?
  - Should friends have access to private members (yes / no)?

As this is a language change, a 2/3 majority is required for whether to add Friend Classes to PHP. (see [[voting]])

===== Patches and Tests =====
I have implemented the RFC as described with tests to verify all usage examples above. I will link this as soon as I am able and will open a pull request against ''master'' to monitor TravisCI build status as I make changes.

As this is my first contribution to PHP, it is my opinion that my request should be placed under higher scrutiny and I am completely ready and willing to accept all feedback to improve implementation.

===== References =====
  - [[https://marc.info/?l=php-internals&m=144954699701305&w=2|Original Mailing List Discussion]]
  - https://bugs.php.net/bug.php?id=34044
  - http://stackoverflow.com/questions/317835/php-equivalent-of-friend-or-internal
  - https://marc.info/?l=php-internals&m=144639394529142
  - http://ocramius.github.io/blog/accessing-private-php-class-members-without-reflection/
  - http://www.stroustrup.com/hopl2.pdf
  - http://tekwire.net/joomla/projects/ideas/php-friend

===== Changelog =====
  * v0.1 - Created