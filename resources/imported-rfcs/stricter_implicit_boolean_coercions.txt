====== PHP RFC: Stricter implicit boolean coercions ======
  * Version: 1.3
  * Date: 2022-05-16
  * Author: Andreas Leathley, <a.leathley@gmx.net>
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/stricter_implicit_boolean_coercions

===== Introduction =====

When not using strict_types in PHP, scalar type coercions have become less lossy/surprising in the last years - non-number-strings cannot be passed to an int type (leads to a TypeError), floats (or float-strings) with a fractional part cannot be passed to an int type (leads to a deprecation notice since 8.1 because it loses information). The big exception so far are booleans: you can give a typed boolean any value and it will convert any non-zero (and non-empty-string) value to true without any notice.

Some examples where this might lead to unexpected outcomes:

<PHP>
function toBool(bool $a)
{
  var_dump($a);
}

toBool('0'); // bool(false)
toBool(-0); // bool(false)
toBool('-0'); // bool(true)
toBool(0.0); // bool(false)
toBool('0.0'); // bool(true)
toBool(0.1); // bool(true)
toBool('inactive'); // bool(true)
toBool('false'); // bool(true)
</PHP>

===== Proposal =====

In coercive typing mode, limit the allowed scalar values for typed boolean arguments, boolean return types and boolean class properties to the following:

  * 0 (and -0) integer (= false)
  * 0.0 (and -0.0) float (= false)
  * "0" string (= false)
  * "" (empty) string (= false)
  * 1 integer (= true)
  * 1.0 float (= true)
  * "1" string (= true)

Any other integers, floats and strings are always coerced to true (no behavior change) but will emit an ''E_DEPRECATED'' notice:

  * For coercions from string the deprecation notice is: Implicit conversion from string "%s" to true, only "", "0" or "1" are allowed
  * For coercions from int the deprecation notice is: Implicit conversion from int %d to true, only 0 or 1 are allowed
  * For coercions from float the deprecation notice is: Implicit conversion from float %f to true, only 0 or 1 are allowed

These would be the notices generated for the examples in the introduction:

<PHP>
toBool('0');
toBool(-0);
toBool('-0'); // Implicit conversion from string "-0" to true, only "", "0" or "1" are allowed
toBool(0.0);
toBool('0.0'); // Implicit conversion from string "0.0" to true, only "", "0" or "1" are allowed
toBool(0.1); // Implicit conversion from float 0.1 to true, only 0 or 1 are allowed
toBool('inactive'); // Implicit conversion from string "0.0" to true, only "", "0" or "1" are allowed
toBool('false'); // Implicit conversion from string "0.0" to true, only "", "0" or "1" are allowed
</PHP>

The long-term goal is to raise these deprecation notices to ''TypeError'', most likely in the next major version (PHP 9.0), but that will need to be discussed again in the PHP 9.0 development cycle. At that time there will have been multiple years of experience with these new deprecation notices, making it easier to decide whether raising them to a ''TypeError'' for 9.0 seems reasonable.

===== Rationale =====

When assigning values to objects, methods or functions the used data often comes from outside sources (HTTP request, database query, text file, etc.) and having reasonable type juggling behavior from PHP reduces the number of unexpected and unnoticed bugs. When boolean types accept any scalar value it is easy to introduce unintended errors.

When implementing this feature I found such an unintended error in PHPs test runner (which is written in PHP) which boiled down to:

<PHP>
function mail_qa_team(string $data, bool $status = false): bool
{
  // send $status within an URL, so it is coerced to a string
}

if ($sum_results['FAILED']) {
    $status = "failed";
} else {
    $status = "success";
}

// $status as a non-empty string is always coerced to true, and later converted to 1 within mail_qa_team
mail_qa_team($failed_tests_data, $status); 
</PHP>

This lead to the deprecation notice ''Implicit conversion from string "failed" to true, only "", "0" or "1" are allowed'' on TravisCI. Reading that notice makes it immediately obvious that converting "failed" to true must be a mistake. In current PHP codebases there are likely a few of these unintended conversions to booleans which would be easy to fix if a developer noticed that an unusual value is converted to true.

While using strict_types is an option to avoid unintended type coercions, the goal of this RFC is to make coercions less error-prone when not using strict_types. Silently coercing "failed" (or -37486, or 0.01) to true seems like an invitation to unexpected behavior. By introducing this deprecation notice users will have the chance of finding surprising boolean coercions in their code while the coercion behavior will remain the same.

===== Implementation notes =====

As this is my first RFC and my first contribution to php-src, I mimicked the code from the "Deprecate implicit non-integer-compatible float to int conversions" RFC (https://github.com/php/php-src/pull/6661). I added some tests and made sure the existing tests still pass. There might be some room for improvements on my implementation though, so any feedback is welcome!

===== Backward Incompatible Changes =====

The following operations will now emit an ''E_DEPRECATED'' if a non-boolean-compatible scalar value is used:

  * Assignment to a typed property of type ''bool'' in coercive typing mode
  * Argument for a parameter of type ''bool'' for both internal and userland functions in coercive typing mode
  * Returning such a value for userland functions declared with a return type of ''bool'' in coercive typing mode
  
The actual conversion to a boolean value remains unchanged - anything that was coerced to false before will still be coerced to false, and anything coerced to true will still be coerced to true.

The following shows typical ways to avoid a deprecation notice:

<PHP>
// Resolution 1: Check for an expected value or range
toBool($scalar > 0);
toBool($int === 5);
toBool($string === 'success');
toBool(strlen($string) > 0);
 
// Resolution 2: Check for truthiness
toBool($scalar == true);
 
// Resolution 3: Explicitly cast the argument
toBool((bool) $scalar);
</PHP>

With the many deprecation notices that appeared in PHP 8.0 and 8.1 there is some wariness if more deprecation notices will be worth the pain. These are the arguments why the RFC author thinks it will be worth it without too much pain:

  * Each individual case is easy to fix, the easiest (but also least useful) is to loosly compare a value to true ($value == true) instead of directly giving the value to a typed bool
  * bool arguments for internal functions are usually optional, less numerous and are much more likely to be set by a constant expression than a variable
  * deprecation notices do not demand immediate attention, and the "disadvantage" of the high number of deprecation notices with 8.0 and 8.1 should be that most tooling and codebases have gotten more used to dealing with them in their own time and not see them as an immediate call to action
  * Many of the coercions that will lead to a deprecation notice are most likely to be unintended and the information given in the notice should make it reasonably clear to a developer whether it is a bug and whether it is urgent or not

===== Proposed PHP Version =====

Next minor version: PHP 8.2.

===== Unaffected PHP Functionality =====

  * Manually casting to boolean will not raise a notice.
  * Strict Type behaviour is unaffected.
  * Implicit boolean (or truthiness) evaluations (if, ternary, logic operators) are not affected.

===== Patches and Tests =====

Patch: https://github.com/php/php-src/pull/8565

===== References =====

Initial mailing list discussion: <https://externals.io/message/117608> \\
RFC mailing list discussion: <https://externals.io/message/117732> \\