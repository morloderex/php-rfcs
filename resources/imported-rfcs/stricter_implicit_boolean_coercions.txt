====== PHP RFC: Stricter implicit boolean coercions ======
  * Version: 1.0
  * Date: 2022-05-16
  * Author: Andreas Leathley, <a.leathley@gmx.net>
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/stricter_implicit_boolean_coercions

===== Introduction =====

When not using strict_types in PHP, scalar type coercions have become less lossy/surprising in the last years - non-numbers cannot be passed to an int type (leads to a TypeError), floats (or float-strings) with a fractional part cannot be passed to an int type (leads to a deprecation notice in 8.1 and a TypeError in 9.0). The big exception so far are booleans: you can give a typed boolean any value and it will convert any non-zero (and non-empty-string) value to true.

Some examples where this might lead to unexpected outcomes:

<PHP>
function toBool(bool $a)
{
  var_dump($a);
}

toBool('0'); // bool(false)
toBool('0.0'); // bool(true)
toBool(0.0); // bool(false)
toBool(0.1); // bool(true)
toBool('inactive'); // bool(true)
toBool('false'); // bool(true)
</PHP>

===== Proposal =====

In coercive typing mode, limit the allowed scalar values for typed boolean arguments, boolean return types and boolean class properties to the following:

  * 0 integer (= false)
  * 0.0 float (= false)
  * "0" string (= false)
  * "" (empty) string (= false)
  * 1 integer (= true)
  * 1.0 float (= true)
  * "1" string (= true)

Any other integers, floats and strings are always coerced to true (no behavior change) but will emit an ''E_DEPRECATED'' notice:

  * For coercions from string the deprecation notice is: Implicit conversion from string "%s" to true, only "", "0" or "1" are allowed
  * For coercions from int the deprecation notice is: Implicit conversion from integer %d to true, only 0 or 1 are allowed
  * For coercions from float the deprecation notice is: Implicit conversion from float %f to true, only 0 or 1 are allowed

Raise these deprecation notices to ''TypeError'' in the next major version (PHP 9.0).

===== Rationale =====

When assigning values to objects, methods or functions the used data often comes from outside sources (HTTP request, database query, text file, etc.) and having reasonable type juggling behavior from PHP reduces the number of unexpected and unnoticed bugs. When boolean types accept any scalar value it is easy to introduce unintended errors.

When implementing this feature I even found such an unintended error in PHPs test suite (which is written in PHP) which boiled down to:

<PHP>
function mail_qa_team(string $data, bool $status = false): bool
{
  // send $status within an URL, so it is coerced to a string
}

if ($sum_results['FAILED']) {
    $status = "failed";
} else {
    $status = "success";
}

// $status is always coerced to true, and later converted to 1 when being converted back to a string
mail_qa_team($failed_tests_data, $status); 
</PHP>

This lead to a deprecation notice ''Implicit conversion from string "failed" to true, only "", "0" or "1" are allowed''. Reading that notice makes it immediately obvious that converting "failed" to true cannot be the intended behavior.

While using strict_types is an option to avoid unintended type coercions, the goal of this RFC is to make coercions less error-prone when not using strict_types. Silently coercing "hello" to true seems like an invitation to unexpected behavior. By introducing a deprecation notice users will have the chance of finding unexpected boolean coercions in their code. By the time PHP 9 is released it seems unlikely that many problematic coercions remain, as users will have had multiple years with deprecation notices.

===== Implementation notes =====

As this is my first RFC and my first contribution to php-src, I mimicked the code from the "Deprecate implicit non-integer-compatible float to int conversions" RFC (https://github.com/php/php-src/pull/6661). There are a few tests which are still failing with iterators, where I wanted to check with people more familiar with php-src first on how to adjust those, and there might still be changes needed for opcache/JIT, so the implementation is not 100% done. Any feedback is welcome!

===== Backward Incompatible Changes =====

The following operations will now emit an ''E_DEPRECATED'' if a non-boolean-compatible scalar value is used:

  * Assignment to a typed property of type ''bool'' in coercive typing mode
  * Argument for a parameter of type ''bool'' for both internal and userland functions in coercive typing mode
  * Returning such a value for userland functions declared with a return type of ''bool'' in coercive typing mode
  
The actual conversion to a boolean value remains unchanged - anything that was coerced to false before will still be coerced to false, and anything coerced to true will still be coerced to true.

The following shows typical ways to avoid a deprecation notice:

<PHP>
// Resolution 1: Check for an expected value or range
toBool($scalar > 0);
toBool($scalar === 5);
toBool($scalar === 'on');
 
// Resolution 2: Check for truthiness
toBool($scalar == true);
 
// Resolution 3: Explicitly cast the argument
toBool((bool) $scalar);
</PHP>

===== Backward Incompatible Changes =====

===== Proposed PHP Version =====

Next minor version: PHP 8.2.

===== RFC Impact =====

===== Unaffected PHP Functionality =====

  * Manually casting to boolean will not raise a notice.
  * Strict Type behaviour is unaffected.
  * Implicit boolean (or truthiness) evaluations (if, ternary, logic operators) are not affected.

===== Patches and Tests =====

Patch: https://github.com/php/php-src/pull/8565

===== References =====

Initial mailing list discussion: <https://externals.io/message/117608> \\
RFC mailing list discussion: <https://externals.io/message/117732> \\