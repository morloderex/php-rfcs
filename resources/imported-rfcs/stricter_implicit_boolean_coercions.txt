====== PHP RFC: Stricter implicit boolean coercions ======
  * Version: 1.2
  * Date: 2022-05-16
  * Author: Andreas Leathley, <a.leathley@gmx.net>
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/stricter_implicit_boolean_coercions

===== Introduction =====

When not using strict_types in PHP, scalar type coercions have become less lossy/surprising in the last years - non-numbers cannot be passed to an int type (leads to a TypeError), floats (or float-strings) with a fractional part cannot be passed to an int type (leads to a deprecation notice in 8.1 and a TypeError in 9.0). The big exception so far are booleans: you can give a typed boolean any value and it will convert any non-zero (and non-empty-string) value to true.

Some examples where this might lead to unexpected outcomes:

<PHP>
function toBool(bool $a)
{
  var_dump($a);
}

toBool('0'); // bool(false)
toBool('0.0'); // bool(true)
toBool(0.0); // bool(false)
toBool(0.1); // bool(true)
toBool('inactive'); // bool(true)
toBool('false'); // bool(true)
</PHP>

===== Proposal =====

In coercive typing mode, limit the allowed scalar values for typed boolean arguments, boolean return types and boolean class properties to the following:

  * 0 integer (= false)
  * 0.0 float (= false)
  * "0" string (= false)
  * "" (empty) string (= false)
  * 1 integer (= true)
  * 1.0 float (= true)
  * "1" string (= true)

Any other integers, floats and strings are always coerced to true (no behavior change) but will emit an ''E_DEPRECATED'' notice:

  * For coercions from string the deprecation notice is: Implicit conversion from string "%s" to true, only "", "0" or "1" are allowed
  * For coercions from int the deprecation notice is: Implicit conversion from int %d to true, only 0 or 1 are allowed
  * For coercions from float the deprecation notice is: Implicit conversion from float %f to true, only 0 or 1 are allowed

Raise these deprecation notices to ''TypeError'' in the next major version (PHP 9.0).

===== Rationale =====

When assigning values to objects, methods or functions the used data often comes from outside sources (HTTP request, database query, text file, etc.) and having reasonable type juggling behavior from PHP reduces the number of unexpected and unnoticed bugs. When boolean types accept any scalar value it is easy to introduce unintended errors.

When implementing this feature I even found such an unintended error in PHPs test suite (which is written in PHP) which boiled down to:

<PHP>
function mail_qa_team(string $data, bool $status = false): bool
{
  // send $status within an URL, so it is coerced to a string
}

if ($sum_results['FAILED']) {
    $status = "failed";
} else {
    $status = "success";
}

// $status as a non-empty string is always coerced to true, and later converted to 1 within mail_qa_team
mail_qa_team($failed_tests_data, $status); 
</PHP>

This lead to a deprecation notice ''Implicit conversion from string "failed" to true, only "", "0" or "1" are allowed''. Reading that notice makes it immediately obvious that converting "failed" to true cannot be the intended behavior.

While using strict_types is an option to avoid unintended type coercions, the goal of this RFC is to make coercions less error-prone when not using strict_types. Silently coercing "hello" to true seems like an invitation to unexpected behavior. By introducing a deprecation notice users will have the chance of finding unexpected boolean coercions in their code. By the time PHP 9 is released it seems unlikely that many problematic coercions remain, as users will have had multiple years with deprecation notices.

===== Implementation notes =====

As this is my first RFC and my first contribution to php-src, I mimicked the code from the "Deprecate implicit non-integer-compatible float to int conversions" RFC (https://github.com/php/php-src/pull/6661). I added some tests and made sure the existing tests still pass. There might still be changes needed for opcache/JIT, so the implementation might not 100% done. Any feedback is welcome!

===== Backward Incompatible Changes =====

The following operations will now emit an ''E_DEPRECATED'' if a non-boolean-compatible scalar value is used:

  * Assignment to a typed property of type ''bool'' in coercive typing mode
  * Argument for a parameter of type ''bool'' for both internal and userland functions in coercive typing mode
  * Returning such a value for userland functions declared with a return type of ''bool'' in coercive typing mode
  
The actual conversion to a boolean value remains unchanged - anything that was coerced to false before will still be coerced to false, and anything coerced to true will still be coerced to true.

The following shows typical ways to avoid a deprecation notice:

<PHP>
// Resolution 1: Check for an expected value or range
toBool($scalar > 0);
toBool($scalar === 5);
toBool($scalar === 'on');
 
// Resolution 2: Check for truthiness
toBool($scalar == true);
 
// Resolution 3: Explicitly cast the argument
toBool((bool) $scalar);
</PHP>

With the many deprecation notices that appeared in PHP 8.0 and 8.1 there is some wariness if more deprecation notices will be worth the pain. These are the arguments why the RFC author thinks it will not lead to too much unnecessary pain:

  * Each individual case is easy to fix, the easiest (but also least useful) is to loosly compare a value to true ($value == true) instead of directly giving the value to a typed bool
  * bool arguments for internal functions are usually optional, less numerous and are much more likely to be set by a constant expression than a variable
  * deprecation notices do not demand immediate attention, and the "disadvantage" of the high number of deprecation notices with 8.0 and 8.1 should be that most tooling and codebases have gotten more used to dealing with them in their own time and not see them as an immediate call to action

===== Proposed PHP Version =====

Next minor version: PHP 8.2.

===== Unaffected PHP Functionality =====

  * Manually casting to boolean will not raise a notice.
  * Strict Type behaviour is unaffected.
  * Implicit boolean (or truthiness) evaluations (if, ternary, logic operators) are not affected.

===== Patches and Tests =====

Patch: https://github.com/php/php-src/pull/8565

===== References =====

Initial mailing list discussion: <https://externals.io/message/117608> \\
RFC mailing list discussion: <https://externals.io/message/117732> \\