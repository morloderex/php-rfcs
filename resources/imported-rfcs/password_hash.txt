====== Request for Comments: Adding simple password hashing API ======
  * Version: 0.1
  * Date: 2012-06-26
  * Author: Anthony Ferrara <ircmaxell@php.net>
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/password_hash

===== Introduction =====

This RFC describes a new API for simplified password hashing.

==== Why Do We Need Password Hashing? ====

Password Hashing is a way to convert a user-supplied password into a one-way derived token for storage. By using the derived token, it makes it impossible to reverse the stored token and get the original password used by the user. This adds a layer of defense in case an attacker gets access to the database storing the password.

==== Why Do We Need Strong Password Hashing? ====

As it turns out, just hashing a password using //md5()// or even //sha512()// isn't good enough. Cryptographic hash functions (such as those supplied by //hash()//) are designed to be fast. This is good for cryptographic needs such as signing. But for password hashing, that's a problem since it allows an attacker to brute force a lot of passwords very quickly. Adding a salt makes it resistent to [[http://en.wikipedia.org/wiki/Rainbow_table|rainbow tables]], but not resistent to brute forcing where that salt is known.

By using either a [[http://en.wikipedia.org/wiki/Key_stretching|stretched algorithm]] (Such as //PBKDF2//) or an algorithm designed to be slow (Such as //bcrypt//), a much better defense against brute forcing will be had.

==== Why Do We Need A Simple API ====

As recent attacks have shown, strong password hashing is something that the vast majority of PHP developers don't understand, or don't think is worth the effort. The current core implementations of strong password hashing using //crypt()// are actually fairly difficult to work with. The error states are difficult to check for (returning //*0// or //*1// on error). The salt format is difficult to generate as it uses a custom base64 alphabet (//.// instead of //+// and no padded //=//). Additionally, salts are reasonably difficult to generate randomly (not too difficult, but requires a fair bit of code). Additionally, checking the return when validating a password can expose the application to [[remote timing attacks|http://en.wikipedia.org/wiki/Timing_attack]].

By providing a simple API that can be called, which takes care of all of those issues for you, hopefully more projects and developers will be able to use secure password hashing. 

===== Common Misconceptions =====

==== Salts Need To Be Cryptographically Secure ====

Salts exist for a single reason: To make it so that any time (CPU effort) spent cracking a single password hash cannot be amortized across multiple hashes. That means that attacking a single password hash will have no impact on the time it will take attacking another hash. Based on that reason, salts only need to be unique in a system. There is no requirement for them to be cryptographically secure.

==== Hash(password + salt) Is Fine ====

No, it's not. There's plenty of information out there to dispel this myth. See the references section for some details.

===== Proposal and Patch =====

The proposal is to add a new set of password hashing APIs to the standard PHP library. These hashing APIs will initially be thin wrappers around //crypt()// to allow for automatic salt generation and better error checking. The APIs are designed such that they can easily be extended in the future as additional strong hashing algorithms are introduced into PHP's core (Such as //scrypt//).

==== New Functions ====

  * //string password_hash(string $password, string $algo = PASSWORD_DEFAULT, array $options = array())// - The function which creates new password hashes. If called with one parameter, it will auto-generate a salt, and use the defined default algorithm (currently //bcrypt//). The //$options// array allows for passing in algorithm specific options. In the case of //bcrypt//, two options are supported: //salt// and //cost//. The //salt// parameter, if provided, will be used in place of an auto-generated salt. The //cost// parameter is passed to //crypt()// to control the amount of CPU time that should be expended creating the hash (higher is more resistent to brute forcing, lower is kinder on the servers. A balance should be achieved).
  * //bool password_verify($password, $hash)// - The function which verifies an existing hash. This hash can be created via //password_hash()//, or a normal //crypt()// hash. The only thing it provides on top of //crypt()// is resistance to timing attacks by using a constant-time comparison function.
  * //string password_make_salt(int $length, bool $raw_output = false)// - This function will create a new random salt of the specified length using psuedo-random algorithms. It will be used by //password_hash()// if a salt is not provided. But it can also be used to generate salts for other //crypt()// algorithms that //password_hash()// does not support. It can also be used to generate strong salts for other algorithms, such as //PBKDF2// (which exists as an RFC now), or 3pd libraries like //PHPASS//.

==== New Constants ====

Initially, two constants are defined:

  * //PASSWORD_BCRYPT = "2y"// - Create new password hashes using the //CRYPT_BLOWFISH// algorithm
  * //PASSWORD_DEFAULT = PASSWORD_BCRYPT// - The default algorithm to use for hashing if no algorithm is provided. This can change in future releases if a new, stronger hashing algorithm (such as //scrypt// is supported).

==== Supported Algorithms ====

 * //BCrypt// - The //CRYPT_BLOWFISH// algorithm. The strongest algorithm currently supported by PHP.

==== Examples ====

===Basic Usage:===
<file php basic_usage.php>
<?php
$password = "foo";
$hash = password_hash($password);
// Store Hash

if (password_verify($password, $hash)) {
    // Password Is Correct
} else {
    // Password Is Not Correct
}
?>
</file>

===Specifying Algorithm:===
<file php specify_algorithm.php>
<?php
$password = "foo";
$hash = password_hash($password, PASSWORD_BCRYPT);
// Store Hash

if (password_verify($password, $hash)) {
    // Password Is Correct
} else {
    // Password Is Not Correct
}
?>
</file>

===Specifying Cost:===
<file php specify_cost.php>
<?php
$password = "foo";
$hash = password_hash($password, PASSWORD_BCRYPT, array("cost" => 14);
// Store Hash

if (password_verify($password, $hash)) {
    // Password Is Correct
} else {
    // Password Is Not Correct
}
?>
</file>

===Specifying Salt Manually:===
<file php specify_salt.php>
<?php
$password = "foo";
$salt = mcrypt_create_iv(22, MCRYPT_DEV_URANDOM); 
$hash = password_hash($password, PASSWORD_BCRYPT, array("cost" => 14, "salt" => $salt);
// Store Hash

if (password_verify($password, $hash)) {
    // Password Is Correct
} else {
    // Password Is Not Correct
}
?>
</file>

===Generating Salts:===
<file php generate_salt.php>
<?php
// 15 characters in the alphabet a-zA-Z0-9./
$salt = password_make_salt(15);

// 15 characters of binary data (0-255)
$raw_salt = password_make_salt(15, true);
?>
</file>
==== Possible Implementation Details ====

  * INI setting for bcrypt cost - Presently, the default cost for //bcrypt// is determined by a C constant which can be updated in future releases. This could be changed to use an INI constant such as //password.bcrypt_cost = 11// so that hosts can change the default cost parameter at runtime. The problem with this is that hosts can also reduce the default cost so significantly that it makes the default hash very weak (relatively speaking). 
  * INI setting for default algo - Presently, the default algorithm is identified by a constant that can be updated only with a source-code change. It may be worth while implementing an INI setting to allow that to be chosen by the host. As the proposed implementation has only a single algorithm, this may be a choice to be made in the future.

==== Patch ====

Currently, the proposed patch is not yet complete. The basic functionality is there, but it needs some refactoring and testing prior to official proposal. The Work-In-Progress can be seen on the //hash_password// branch of [[https://github.com/ircmaxell/php-src/blob/hash_password/|ircmaxell's fork]]. 

The specific implementation is at [[https://github.com/ircmaxell/php-src/blob/hash_password/ext/standard/password.c|password.c]]

==== PHP Implementation ====

Additionally, a compatibility version in PHP is maintained at [[https://github.com/ircmaxell/password_compat|Github]]. This can be used in PHP versions 5.3 and 5.4 and for testing.

===== References ===== 

==== Recent Attacks ====

  * [[http://mashable.com/2012/06/06/6-5-million-linkedin-passwords/|LinkedIn]]
  * [[http://www.pcworld.com/article/257178/music_site_lastfm_joins_the_passwordleak_parade.html|LastFM]]
  * [[http://lifehacker.com/5374745/10000-hotmail-passwords-leaked-online|Hotmail]]
  * [[http://lifehacker.com/5712785/faq-compromised-commenting-accounts-on-gawker-media|Gawker Media]]

==== Hashing In General ====

Blog Posts:

  * [[http://blog.ircmaxell.com/2011/08/rainbow-table-is-dead.html|The Rainbow Table Is Dead]]
  * [[http://blog.ircmaxell.com/2012/06/reply-use-cuda-accelerated-pbkdf2.html|GPU Acclerated Hashing]]
  * [[http://www.codinghorror.com/blog/2012/04/speed-hashing.html|Speed Hashing]]
  * [[http://codahale.com/how-to-safely-store-a-password/|How to safely store a password]]
  * [[http://yorickpeterse.com/articles/use-bcrypt-fool|Use BCrypt Fool!]]

Stack Overflow Questions/Answers:

  * [[http://stackoverflow.com/questions/4948322/fundamental-difference-between-hashing-and-encryption-algorithms/4948393#4948393|Fundamental Difference Between Hashing And Encryption]]
  * [[http://stackoverflow.com/questions/3559437/many-hash-iterations-append-salt-every-time/3559497#3559497|Many Hash Iterations: Append Salt Every Time?]]
  * [[http://stackoverflow.com/a/11195855/338665|OpenSSL Digest vs Hash vs Hash_HMAC - Difference between salt - hmac]]
  * [[http://stackoverflow.com/questions/401656/secure-hash-and-salt-for-php-passwords|Secure Hash and Salt for PHP Passwords]]
  * [[http://stackoverflow.com/questions/3566504/why-do-salts-make-dictionary-attacks-impossible|Why do salts make dictionary attacks impossible]]
  * [[http://stackoverflow.com/q/1561174/338665|SHA512 vs Blowfish and BCrypt]]

==== Timing Attacks ====

  * [[http://rdist.root.org/2010/07/19/exploiting-remote-timing-attacks/|Exploiting Remote Timing Attacks]]
  * [[http://rdist.root.org/2010/01/07/timing-independent-array-comparison/|Timing Independent Array Comparison]]
  * [[http://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf|SSL Timing Attacks (PDF)]]
  * [[http://blog.astrumfutura.com/2010/10/nanosecond-scale-remote-timing-attacks-on-php-applications-time-to-take-them-seriously/|Nanosecond Scale Remote Timing Attacks on PHP Applications]]

==== Strong Algorithms ====

  * [[http://en.wikipedia.org/wiki/Bcrypt|BCrypt]]
  * [[http://www.openwall.com/crypt/|Crypt_BCrypt]]
  * [[http://en.wikipedia.org/wiki/PBKDF2|PBKDF2]]
  * [[http://www.tarsnap.com/scrypt.html|SCrypt]]

===== Changelog =====
  * 0.1 - Initial Draft