====== PHP RFC: any() and all() on iterables ======
  * Version: 0.3
  * Date: 2020-08-30
  * Author: Tyson Andre, tandre@php.net
  * Status: Under Discussion
  * First Published at: https://wiki.php.net/rfc/any_all_on_iterable
  * Implementation: https://github.com/php/php-src/pull/6053

===== Introduction =====

The primitives ''any()'' and ''all()'' are a common part of many programming languages and help in avoiding verbosity or unnecessary abstractions.

  - Haskell: https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#v:any
  - JavaScript: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
  - Python: https://docs.python.org/3/library/functions.html#all
  - Java 8(Stream): https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#allMatch-java.util.function.Predicate-

For example, the following code could be shortened significantly:

<code php>
// The old version
$satisifes_predicate = false;
foreach ($item_list as $item) {
    // Performs DB operations or external service requests, stops on first match by design.
    if (API::satisfiesCondition($item)) {
        $satisfies_predicate = true;
        break;
    }
}
if (!$satisfies_predicate) {
    throw new APIException("No matches found");
}
// more code....
</code>

<code php>
// The new version is much shorter, readable, and easier to review,
// without creating temporary variables or helper functions that are used in only one place.

// Performs DB operations or external service requests, stops on first match by design.
if (!any($item_list, fn($item) => API::satisfiesCondition($item))) {
    throw new APIException("No matches found");
}
</code>

===== Proposal =====

Add the functions ''any(iterable $input, ?callable $callback = null): bool'' and ''all(...)'' to php's standard function set.

<code php>
/** Determines whether any element of the iterable satisfies the predicate. */
function any(iterable $input, ?callable $callback = null) {
    foreach ($input as $v) {
        if ($callback !== null ? $callback($v) : $v) {
            return true;
        }
    }
    return false;
}
/** Determines whether all elements of the iterable satisfy the predicate */
function all(iterable $input, ?callable $callback = null) {
    foreach ($input as $v) {
        if (!($callback !== null ? $callback($v) : $v)) {
            return false;
        }
    }
    return true;
}
</code>

This proposal recommends adding ''any()'' and ''all()'' to the standard library instead of a PECL or composer library for the following reasons

  - New contributors to projects wouldn't know about ''any()'' and ''all()'' if it was reimplemented in various composer libraries or util.php files with different semantics/names and only occasionally used.
  - If this was provided only in userland, there'd be low adoption and code such as the above example (API::somePredicate()) would remain common.
  - If the standard library provided it, then polyfills for newer php functionality could adopt this as well, making cleaner code easier to write.

===== Backward Incompatible Changes =====

Any userland functions called ''any()'' and ''all()'' in the global namespace without a ''!function_exists()'' check would encounter duplicate function errors.

===== Proposed PHP Version(s) =====
8.1

===== Future Scope =====

==== Add int $flag = 0? ====
Similar to array_filter, ''int $flag = 0'' could be used to control which parameters get passed to the predicate such as ''ARRAY_FILTER_USE_BOTH'' and ''ARRAY_FILTER_USE_KEY''.

Because there was discussion of whether the ability to pass keys was widely useful and multiple approaches that could be used to pass the iterable key, this functionality was left out of this RFC. See https://externals.io/message/111711#111721

<blockquote>
I like this, but I do not like the flags. I don't think they're at all useful. A lot of the other discussion in the thread seems to be needlessly complicating it, too.

all() and any() only need return booleans. Their callbacks only need return booleans. That's the point. first() makes sense to add, and it would return the first value that matches.

For the callback itself, there is work to, hopefully, add partial function application to 8.1. (No idea if it will be successful, but the effort is in progress.) If so, the upshot is that turning an arbitrary function into a single-parameter function becomes silly easy, which means functions like this can just expect a single parameter callback and be done with it. No need for extra-args or flags or whatnot.

If you want to check the keys of an array, call ''array_keys()'' first and use that.

''if (any(array_keys($foo), fn($k) => $k %2)) { ... }''

all(), any(), and first() all sound like good things to include, but let's not over-complicate them. We can do better today than we could in 1999...

--Larry Garfield
</blockquote>

==== Add first($iterable, $callback = null, $default = null): mixed as well? ====

https://externals.io/message/111711#111732

<blockquote>
If it took the default value as well it could return that (to distinguish the absence of a result from null matching the predicate). While it's
useful in itself it also would enable you to pass a marker object and check
the identity of that to know if no matches have been found:

<code php>
$none = new stdClass;
$element = first($collection, fn($elt) => ..., $none);
if ($element === $none) {
    // nothing found
}
</code>
</blockquote>

Calling it ''[iterable_]search_callback()'' or ''first_match[ing]()'' or ''find()'' might help distinguish this from the ''reset()''/''end()''/''next()''/''prev()'' family of global functions - there's more than one possible name.

===== Discussion =====

==== Alternative names ====

''any_value()'' or ''all_values()'' have been suggested as alternative names: https://github.com/php/php-src/pull/6053#issuecomment-684164832

''iter_any()'' or ''iterable_any()'' have also been suggested as alternative names.

<blockquote>
The main thing I'm concerned about is that once we start extending this
area (I assume that any & all are not going to be the last additions in
this space) we will quickly run into function names that are either too
generic or outright collide. For example, what if we want to add an
iterator-based version of range()? Do we really want to be forced to pull
a Python and call it xrange()? That's about as good as real_range()...

As such, I think it's important to prefix these somehow, though I don't
care strongly how. Could be iter_all() or iterable_all(). We might even
make it iterator_all() if we also adjust other existing iterator_*
functions to accept iterables. I'd also be happy with iter\all() or
iterable\all(), but that gets us back into namespacing discussions :)
</blockquote>

Because ''any()'' and ''all()'' are potentially commonly used functions in the same way as ''count(Countable|array)'' and always return booleans, I preferred a short name over longer names.
This also allows potentially supporting ''int $flags = 0'' in the future, similar to what was done for ''array_filter()''.

Functions that act on iterables and return Traversables/iterables may still benefit from adding collections of functionality under a naming pattern such as `iter\function_name()` or `iterable_function_name()`, but that is out of the scope of this RFC. https://github.com/nikic/iter is an example of a composer package with some common iteration primitives that may be useful to consider adding, possibly returning arrays instead of Generators for performance/predictability reasons.

==== Add find_first() instead? ====

<blockquote>
I was actually working on this sort of thing recently. Technically,
you can support all, any, and first by using a single function:

<code php>
function find_first(iterable $of, callable($value, $key): bool $thatSatistifes): Iterator
</code>

It converts the ''$iterable'' into an ''Iterator'', then calls the callback
for each key/value pair until one returns true, and then always
returns the iterator at the current position.

This allows you to know both key and value when making a decision.
By returning an iterator the caller can get both key and value.
By returning an iterator it can handle both the empty case and not
found cases with ''$result->valid() === false''.
By returning an iterator it might be useful for processing the
remainder of the list somehow.
I'm not sure that in practice it would be that friendly, but it's
worth pointing out for discussion at least.
</blockquote>


===== Proposed Voting Choices =====

Add ''any(iterable $input, ?callable $callback = null)'' and ''all(...)'' (yes/no, requiring 2/3 majority)

===== References =====

  - https://externals.io/message/111711 "Proposal: Adding functions any(iterable $input, ?callable $cb = null, int $use_flags=0) and all(...)"
  - https://externals.io/message/103357 "[PATCH] Implementing array_every() and array_any()"
  - https://externals.io/message/111756 "[RFC] Global functions any() and all() on iterables"

===== Rejected Features =====

Adding flags like [[https://php.net/array_filter|''array_filter()'']] was left out of this RFC due to debate over how often it would be used in practice and moved to future scope.

===== Changelog ======

0.3: Add more quotes