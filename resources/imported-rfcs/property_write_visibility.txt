====== PHP RFC: Property write visibility ======
  * Version: 0.4
  * Date: 2020-06-25
  * Author: André Rømcke <andre.romcke+php@gmail.com>
  * Proposed PHP version: PHP 8.0
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/readonly_and_immutable_properties
  * Discussion: https://externals.io/message/ //coming//

===== Introduction =====

With the introduction of [[rfc:typed_properties_v2|typed properties]] in PHP 7.4, properties have become far more powerful. However there are still some common scenarios where you'll need to use magic methods for properties. Namely disconnected write vs read visibility for properties, like readonly, writeonly or immutable //like// semantic. This requires unnecessary boilerplate, makes usage less ergonomic and hurts performance.

This RFC resolves this issue by proposing to allow classes to optionally declare property write visibility, disconnected from read visibility.


Under this RFC, code like

<code php>
class User {
    private int $id;
    protected string $name;

    public function __construct(int $id, string $name) {
        $this->id = $id;
        $this->name = $name;
    }

    public function __get($property)
    {
        if (property_exists($this, $property)) {
            // We return value here as non public properties are "readonly" in this class
            return $this->$property;
        }
        throw new PropertyNotFoundException($property, static::class);
    }

    public function __set($property, $value)
    {
        if (property_exists($this, $property)) {
            // Here private/protected property is attempted accessed outside allowed scope, so we throw
            throw new PropertyReadOnlyException($property, static::class);
        }
        throw new PropertyNotFoundException($property, static::class);
    }

    public function __isset($property)
    {
        return property_exists($this, $property);
    }

    public function __unset($property)
    {
        $this->__set($property, null);
    }
}
</code>

might be written as

<code php>
class User {
    public:private int $id;
    public:protected string $name;

    public function __construct(int $id, string $name) {
        $this->id = $id;
        $this->name = $name;
    }
}
</code>



===== Main differences to previous proposals =====

This RFC is inspired by past RFCs and the discussions that happened around them. Especially credit to [[rfc:readonly_properties|Readonly properties]] by Andrea Faulds, and discussions that happened around the different flavors of [[rfc:propertygetsetsyntax-v1.2|Property Accessors Syntax]].

==== Readonly ====

This RFC allows for among others semantics proposed in [[rfc:readonly_properties|Readonly properties]] (2014, Withdrawn), by using ''public:protected''.


==== Immutability ====

This RFC allows for use cases **similar** to what was proposed in [[rfc:immutability|Immutability]] (2018, Stale), by using for instance ''public:private''.

This RFC does __not__ align with the semantics of the recent [[rfc:write_once_properties|Write once properties]] (2020, Declined), which is targeting a different problem.


==== Property Accessors Syntax ====

This RFC does not try to solve as wide use case as the different iterations of [[rfc:propertygetsetsyntax-v1.2|Property Accessors Syntax]] (2012, Declined) does.

However with what being proposed here and [[rfc:typed_properties_v2|typed properties]], most common use cases needed for properties are covered in an arguably simpler way.


===== Proposal =====

This proposal adds support for enforced write visibility checks for declared properties. The following example illustrates the basic syntax:

<code php>
class User {
    // Property is readonly in protected and public scope
    public:private int $id;

    // Property is readonly in public scope
    public:protected string $name;
    
    // Property is write-only in public and protected scope
    private:public string $newName;

    public function __construct(int $id, string $name) {
        $this->id = $id;
        $this->name = $name;
    }
}
</code>

The format is ''<read_visibility>:<write_visibility>'', and if you omit the last visibility value you will like before implicit set both read and write visibility at once.

==== References ====


Attempting to pass a property value outside of allowed writable scope as a reference, results in an error.


==== Reflection ====

When using reflection, methods such as ''ReflectionProperty::setAccessible()'' will work as before, it will implicit set visibility for both read and write.

In order to avoid backwards compatibility issue, the following methods will get updated behavior:

- ''ReflectionProperty::isPrivate()'' — Checks if property is private for read and write visibility, or one of them
- ''ReflectionProperty::isProtected()'' - Checks if property is protected for read and write visibility, or one of them with the remaining being public
- ''ReflectionProperty::isPublic()'' - Checks if property is public for read and write visibility

The following methods needs to be added to detect different read vs write visibility: 

- ''ReflectionProperty::isWritePrivate()'' — Checks if property is writable in private
- ''ReflectionProperty::isWriteProtected()'' — Checks if property is writable in protected
- ''ReflectionProperty::isWritePublic()'' — Checks if property is writable in public

- ''ReflectionProperty::isReadPrivate()'' — Checks if property is readable in private
- ''ReflectionProperty::isReadProtected()'' — Checks if property is readable in protected
- ''ReflectionProperty::isReadPublic()'' — Checks if property is readable in public



//TODO: ''Reflection::getModifiers()'' and ''Reflection::getModifierNames()'' will need adaption too//


===== Discussions =====

==== Language Syntax ====

The format being proposed here ''<read_visibility>:<write_visibility>'' is open for discussion if for instance this causes problems for parser, or is deemed otherwise in-practical.

If we where to just have two separate visibility keywords on properties, where second one will denote write visibility, that can cause issues for API's such as ''Reflection::getModifierNames()'', and arguably lowers readability.

One other alternative would be to align with, or take inspiration from [[https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html#ID18||Swift setter access level syntax]].


===== Backward Incompatible Changes =====

Code that acts on Reflection to check for visibility, //should// be adapted to take advantage of the more fine grained read or write visibility check methods.


===== Proposed PHP Version(s) =====

Next PHP version, 8.0 suggested.


===== Impact on extensions =====

More future extension code, and possible SPL code, can be written in PHP instead. This is in-line with other features already accepted for PHP 8.0.

Besides that existing PHP extensions working with visibility on properties will need to be adapted.


===== Performance =====

//Performance tests will need to be done once there is an implementation of this. Both for overhead on properties, as well as measuring benefit over using magic methods.//


===== Vote =====

As this is a language change, a 2/3 majority is required.


===== References =====

  * [[https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html#ID18||Swift setter access level]]
  * [[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/classes#readonly-fields|C# readonly fields]], semantically similar to what is referred to as "immutable" here.
  * [[https://docs.rs/readonly/0.1.6/readonly/|Rust readonly create]]


===== Errata =====

//If there are any edge-cases found during implementation, they will appear here.//


===== Changelog =====

Significant changes to the RFC are noted here.

  * 2020-06-28 Simplify Reflection API proposal, add syntax alternatives for discussion
  * 2020-06-25 Focus on write visibility proposal
  * 2020-06-20 Initial early draft to get feedback on direction between visibility, readonly/immutable keywords or attributes