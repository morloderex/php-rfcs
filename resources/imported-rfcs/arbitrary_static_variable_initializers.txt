====== PHP RFC: Arbitrary static variable initializers ======

  * Date: 2022-11-06
  * Author: Ilija Tovilo, tovilo.ilija@gmail.com
  * Status: Under discussion
  * Target Version: PHP 8.3
  * Implementation: https://github.com/php/php-src/pull/9301

===== Proposal =====

PHP allows declaring static variables in all functions. Static variables outlive the function call and are shared across
future execution of the function.

<code php>
function foo() {
    static $i = 1;
    echo $i++, "\n";
}

foo();
// 1
foo();
// 2
foo();
// 3
</code>

The right hand side of the assignment <php>static $i = 1;</php> must currently be a constant expressions. This means
that it can't call functions, use parameters, amongst many other things. This limitation is hard to understand from a
user perspective. This RFC suggests lifting this restriction by allowing the static variable initializer to contain
arbitrary expressions.

<code php>
function bar() {
    echo "bar() called\n";
    return 1;
}

function foo() {
    static $i = bar();
    echo $i++, "\n";
}

foo();
// bar() called
// 1
foo();
// 2
foo();
// 3
</code>

===== Backwards incompatible changes =====

==== Redeclaring static variables ====

Currently, redeclaring static variables is allowed, although the semantics are very questionable.

<code php>
function foo() {
    static $x = 1;
    var_dump($x);
    static $x = 2;
    var_dump($x);
}

foo();
// 2
// 2
</code>

The static variable is overridden at compile time resulting in both statements to refer to the same underlying static
variable initializer. This is not useful or intuitive. The new implementation is not compatible with this behavior but
would instead result in the first initializer to win. Instead of switching from one dubious behavior to another,
redeclaring static variables is disallowed in this RFC and results in a compile time error.

<code php>
function foo() {
    static $x = 1;
    static $x = 2;
}
// Fatal error: Duplicate declaration of static variable $x
</code>

==== ReflectionFunction::getStaticVariables() ====

<php>ReflectionFunction::getStaticVariables()</php> can be used to inspect a functions static variables and their
current values. Currently, PHP automatically evaluates the underlying constant expression and initializes the static
variable if the function has never been called, since the initializer cannot depend on any runtime values of the
function. This is no longer possible with arbitrary initializers. Instead, static variables in
<php>ReflectionFunction::getStaticVariables()</php> will be initialized to <php>null</php>. After executing the function
and assigning to the static variables the contents of the variables will be reflectable.

<code php>
function foo($initialValue) {
    static $x = $initialValue;
}

var_dump((new ReflectionFunction('foo'))->getStaticVariables()['x']);
// NULL
foo(1);
var_dump((new ReflectionFunction('foo'))->getStaticVariables()['x']);
// 1
foo(2);
var_dump((new ReflectionFunction('foo'))->getStaticVariables()['x']);
// 2
</code>

From the example above, it becomes more obvious why the initializer <php>$initialValue</php> cannot be evaluated before
calling the function.

//Side note:// It's been suggested that expressions that can be evaluated constantly continue to do so. This would mean that some expressions in <php>getStaticVariables</php> are evaluated and some are not. The upside is that this would avoid the backward incompatibility. I will check if this is technically feasible.

===== Other semantics =====

==== Exceptions during initialization ====

An initializer might throw an exception. In that case, the static variable remains uninitialized and the initializer
will be called again in the next execution.

<code php>
function bar($throw) {
    echo "bar() called\n";
    if ($throw) throw new Exception();
    return 42;
}

function foo($throw) {
    static $x = bar($throw);
}

try {
    foo(true);
} catch (Exception) {}
// bar() called
var_dump((new ReflectionFunction('foo'))->getStaticVariables()['x']);
// NULL

foo(false);
// bar() called
var_dump((new ReflectionFunction('foo'))->getStaticVariables()['x']);
// int(42)

foo(true);
// bar is not called anymore
</code>

==== Destructor ====

When the static variable declaration overwrites an existing local variable that contains an object with a destructor
that throws an exception, the assignment of the static variable is guaranteed to occur before the exception is thrown.
This is analogous to assignments to regular variables.

<code php>
class Foo {
    public function __destruct() {
        throw new Exception();
    }
}

function foo() {
    $x = new Foo();
    static $x = 42;
}

try {
    foo();
} catch (Exception) {}

var_dump((new ReflectionFunction('foo'))->getStaticVariables()['x']);
// 42
</code>

==== Recursion ====

The static variable declaration only runs the initializer if the static variable has not been initialized. When the
initializer calls the current function recursively this check will be reached before the function has been initialized.
This means that the initializer will be called multiple times. Note though that the assignment to the static variable
still only happens once. This is a somewhat technical limitation where the opcode needs to release two values that could
both execute user code and thus throw exceptions. Not reassigning the value avoids this issue. However, I cannot imagine
a useful scenario for recursive static variable initializers, so semantics here are unlikely to matter.

<code php>
function foo($i) {
    static $x = $i < 3 ? foo($i + 1) : 'Done';
    var_dump($a);
    return $cond;
}

foo(1);
// string(4) "Done" // $i = 3
// string(4) "Done" // $i = 2
// string(4) "Done" // $i = 1

foo(5);
// string(4) "Done" // $i = 5, initializer not called
</code>

===== Vote =====

Voting starts ??? and ends ???. 

As this is a language change, a 2/3 majority is required.

<doodle title="Allow arbitrary static variable initializers in PHP 8.3?" auth="ilutov" voteType="single" closed="true">
   * Yes
   * No
</doodle>
