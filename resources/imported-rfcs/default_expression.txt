====== PHP RFC: Default expression ======

  * Version: 1.0
  * Date: 2024-08-24
  * Author: Paul Morris <bilge@scriptfusion.com>
  * Status: Under Discussion
  * Target Version: PHP 8.5
  * Implementation: https://github.com/php/php-src/pull/15437
  * First Published at: https://wiki.php.net/rfc/default_expression

===== Introduction =====

The only way to pass the default value to a function or method parameter is to not pass anything. This can be particularly difficult in some circumstances, because the language does not offer an intuitive way to pass //nothing//. This RFC proposes to make the existing keyword, <php>default</php>, the canonical way to pass the default value. Moreover, ''default'' becomes a valid expression in the function argument context, meaning it can be creatively combined with any and all existing PHP expression grammars to augment the default value as it is passed, including assigning it to variables (see [[#appendixdefault_expressions|appendix]] for a comprehensive list).

In its simplest form, <php>default</php> can be used as a single token.

<code php>
f(default)
</code>

However, this is of limited usefulness. The main benefit comes from using <php>default</php> in expression contexts, the most common case being **conditional expressions**.

<code php>
function g($p = null) {
    f($p ?? default);
}
</code>

In this example, function ''f'' will receive whatever its default value is for its first argument only when <php>$p</php> is <php>null</php>, otherwise it receives the value of <php>$p</php>.

===== Default as an expression =====

The principal benefit of <php>default</php> is in its employ within **expressions**. Consider the following example: 

<code php>
class Config {
    public function __construct(Theme $theme = new CuteTheme()) {}
}
</code>

By default, the configuration is constructed with a new ''CuteTheme''. We want to allow users to specify a different theme, but if they do not specify anything, we should still use the default. For the purposes of this example, ''Config'' should be considered third-party code we cannot change. Given we want to conditionally apply the user's custom theme, traditionally we have a few options here, none of them good:

  - Copy the current default from ''Config''. This should be considered an invalid option, because we want to allow the upstream library to change the default without having to update our code.
  - Filter and splat the theme argument.
  - Reflection.

<code php>
// Filter and splat.
function applyTheme(?string $theme = null) {
    return new Config(...array_filter([isset($theme) ? new $theme : null]));
}
</code>

Filter and splat is a viable but unintuitive way to conditionally pass //nothing// as an argument and only works if we're willing to sacrifice ''null'' as a placeholder for //nothing//. Moreover, it only works with a single argument when not specifying keys; as soon as two or more nullable arguments are involved, collapsing them in this manner risks passing the arguments in the wrong order. However, we could specify parameter names as keys to mitigate this.

<code php>
// Reflect.
function applyTheme(?string $theme = null) {
    $param = new ReflectionParameter(['Config', '__construct'], 'theme');
    return new Config(isset($theme) ? new $theme : $param->getDefaultValue());
}
</code>

Reflection is a verbose option with performance overhead. It requires us to duplicate the class and method name we're calling and be explicit about the name or number of the argument, in order to obtain its default value.

<php>default</php> provides an elegant and intuitive solution to this problem.

<code php>
// Conditional default.
function applyTheme(?string $theme = null) {
    return new Config(isset($theme) ? new $theme : default);
}
</code>

This is somewhat similar to reflection, but PHP knows which class, method and argument we're calling just from context.

===== Default as a single token =====

Default as a single token was [[skipparams|proposed]] a decade ago as a mechanism for skipping some parameters, but was declined. Since then, [[named_params|named arguments]] has provided a way to implicitly pass //nothing//, by skipping over parameters we don't want to pass. Named arguments mostly preclude the usefulness of skipping parameters with <php>default</php>, but a curious consequence of named arguments is parameter names suddenly became part of our APIs. That is, changing parameter names now constitutes a compatibility break, whether libraries want to adopt this contract or not. Although it is neither the principal aim nor benefit of this RFC, it does provide an alternative syntax for passing defaults that does not rely on named arguments, and as such relinquishes the burden on libraries to affirm parameter names part of their API. That is, libraries could now elect to declare parameter names not part of their backwards-compatibility promise by offering passing <php>default</php> as an alternative.

<code php>
// Skipping JSON depth parameter with named parameters.
json_decode($json, true, flags: JSON_THROW_ON_ERROR);

// Skipping JSON depth parameter with default.
json_decode($json, true, default, JSON_THROW_ON_ERROR);
</code>

===== Proposal =====

<php>default</php> is now a valid expression, but only in argument-passing contexts. In all other contexts it is invalid, save for those in which it was valid previously, namely ''switch'' statements and ''match'' expressions. That is, <php>default</php> may be used when calling global or namespaced functions, static or instance class methods (including anonymous classes), any callable (including closures and arrow functions), whether they are defined internally or in userland. Outside these contexts, where expressions would otherwise be accepted, attempting to use <php>default</php> will raise a compile-time error.

Attempting to pass <php>default</php> to a function with no parameters, or as an argument beyond the callee's defined parameter limit, will result in a runtime exception. Similarly, attempting to pass <php>default</php> to a required parameter, with no default defined, results in a runtime exception.

Named arguments and default expressions can be used together, as in the following example.

<code php>
$f = fn ($v = 1, $default = 2) => $v + $default;
var_dump($f(default: default + 1)); // int(4)
</code>

Internally, <php>default</php> is treated as a new opcode that causes the VM to perform a parameter default value lookup using reflection. If this lookup fails for any reason, a runtime exception will be thrown. Currently the only known cause of failure is lookup of trampoline functions, which can be created by calling <php>__invoke</php> on a closure, as in <php>(fn ($P = 1) => $P)->__invoke(default);</php>. Considering this is not the intended, nor even a documented way of invoking a closure, it is supposed this limitation is very minor.

===== Backward Incompatible Changes =====

None known.

===== Future Scope =====

It may be possible to overcome the limitation regarding trampoline functions. It is unclear whether there is a practical need to do so, but if the need should arise, this should be possible to implement without any BC break.

===== Voting =====

As per the [[RFC/voting#required_majority|voting RFC]] a yes/no vote with a 2/3 majority is needed for this proposal to be accepted.

<doodle title="Implement default expressions as described?" auth="bilge" voteType="single" closed="false" closeon="2024-08-09T21:00:00Z">
   * Yes
   * No
</doodle>

===== Appendix: Default expressions =====

Throughout this RFC we have referred to default as an //expression//, but the only concrete examples of expressions have been the conditional expressions using the null coalesce (<php>??</php>) and ternary (<php>?:</php>) operators. This appendix lists all the ways <php>default</php> can be combined with other tokens and operators to form valid expressions, but before getting to that list, let's look at one more non-conditional example using the binary pipe operator (<php>|</php>) to augment flags.

<code php>
class Json {
    static function encode(mixed $value, int $flags = JSON_THROW_ON_ERROR): string
    {
        return json_encode($value, $flags);
    }
}
</code>

This static class wraps the internal function, <php>json_encode</php> to provide saner defaults for JSON encoding. In particular, it sets the <php>JSON_THROW_ON_ERROR</php> flag so our return type is guaranteed to be string, eliminating the possibility we have to deal with <php>false</php> as a return type. For the purposes of this contrived example, it is required to ignore the fact that the flag should be specified in the function body rather than the parameter default, to ensure the caller doesn't break this contract. Supposing we want to pretty-print our encoded JSON, we could call: <code php>Json::encode([], JSON_PRETTY_PRINT);</code> However, this will override the throw on error flag, which we want to keep. Calling the function as: <code php>Json::encode([], default | JSON_PRETTY_PRINT);</code> allows us to keep the default and append our pretty-print flag, which continues to work even if the ''Json'' class should elect to update its defaults later.

Following is the full expression list involving <php>default</php>. Not all of these examples will make much (or any) sense in practical terms, particularly those towards the end of the list, but many may have uses depending on your requirements and creativity.

<code php>
// Numeric binary operators
F(default + 1)
F(default - 1)
F(default * 2)
F(default / 2)
F(default % 2)
F(default & 1)
F(default | 1)
F(default ^ 2)
F(default << 1)
F(default >> 1)
F(default ** 2)
F(default <=> 2)

// Boolean binary operators
F(default === 2)
F(default !== 2)
F(default == '2')
F(default != '2')
F(default >= 1)
F(default <= 1)
F(default > 1)
F(default < 1)
F(default && 0)
F(default || 0)
F(default and 0)
F(default or 0)
F(default xor 0)

// Unary operators
F(+default)
F(-default)
F(!default)
F(~default)

// Conditional expressions
F(default ? 1 : 0)
F(1 ? default : 0)
F(1 ? 1 : default)
F(default ?: 0)
F(0 ?: default)
F(default ?? 0)
F(null ?? default)

// Variable assignments
F($V = default)
F($V += default)
F($V -= default)
F($V *= default)
F($V **= default)
F($V /= default)
F($V <<= default)
F($V >>= default)
F($V %= default)
F($V &= default)
F($V |= default)
F($V ^= default)
F($V .= default)
F($V ??= default)
F(list($V) = default)
F([, $V] = default)

// Casts
F((int)default)
F((double)default)
F((string)default)
F((array)default)
F((object)default)
F((bool)default)

// Match
F(match(default) { default => default })

// Parens
F((((default))))

// Internal functions
F(empty(default))
F(include default)
F(include_once default)
F(require default)
F(require_once default)

// Misc
F(default instanceof C)
F(clone default)
F(throw default)
F(print default)
</code>

===== References =====

  * Discussion threads
    * [[https://externals.io/message/125183|This RFC]] (Bilge, August 24, 2024).
    * [[https://externals.io/message/124629|Initial proposal]] (Bilge, July 26, 2024).
  * Similar RFCs
    * [[skipparams|Skipping optional parameters for functions]] (Stas Malyshev, January 1, 2015)

===== Special thanks =====

The implementation for this feature was heavily subsidised by invaluable input from Ilija and Bob Weinand. In particular, Ilija assessed the feasibility and guided the implementation path, and Bob submitted the entire Bison grammar patch! Without them, this feature would either have been impossible or highly scuffed. They, along with everyone else whom supported me from R11, have my utmost thanks! ‚ù§