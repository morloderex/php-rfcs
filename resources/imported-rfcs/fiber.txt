====== PHP RFC: Fiber ======
  * Version: 0.1
  * Date: 2017-09-13
  * Author: Haitao Lv, i@lvht.net
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/fiber


===== Introduction =====
Fibers are primitives for implementing light weight cooperative concurrency in PHP. Basically they are a means of creating Closure that can be paused and resumed. The scheduling of fiber must be done by the programmer and not the VM.

As opposed to Generator (a stackless light weight concurrency implementation), each fiber comes with a stack. This enables the fiber to be paused from deeply nested function calls within the fiber block.

When a fiber is created it will not run automatically. Rather it must be explicitly asked to run using the Fiber::resume method. The code running inside the fiber can give up control by calling Fiber::yield in which case it yields control back to caller (the caller of the Fiber::resume).

===== Proposal =====
==== Why not make it as a Extension? ====
Fibers is a major feature, that allows significant benefits for asynchronous frameworks. Providing it as an optional extension, just doesn't make sense.

==== Implementation ====

=== Proposed API ===
<code php>
final class Fiber {
  public const STATUS_SUSPENDED = 1;
  public const STATUS_RUNNING   = 2;
  public const STATUS_FINISHED  = 3;
  public const STATUS_DEAD      = 4;

  /**
   * @param callable $callable any php callable to be paused
   * @param int $stack_size fiber stack init size
   */
  public function __construct(callable $callable = null, int stack_size = null) {}

  /**
   * pause the current fiber and ~return~ the $arg1
   * as the Fiber::resume's return value.
   */
  public static function yield($arg1) {}
  
  /**
   * Start or resume a fiber.
   * 
   * If the fiber is not started, call resume will init
   * the $callable with all args.
   *
   * If the fiber is paused, call resume will send the first arg
   * as the last Fiber::yield's return value.
   */
  public function resume($arg1...) {}
  
  /**
   * Throw an exception into the fiber.
   * 
   * You code can use try/catch to process error in the
   * top level function call. Some framework make heavy
   * usage of this feature.
   */
  public function throw(Throwable $e) {}
}
</code>

=== Usage Demo ===
Here is the usage demo,
<code php>
function sub1()
{
	return Fiber::yield(1);
}
$fiber = new Fiber(function ($a, $b) {
	$c = Fiber::yield($a + $b);

	$d = sub1();
	return $d.$c;
});

echo $fiber->resume(1, 2);     // echo 3
echo $fiber->resume("world");  // echo 1
echo $fiber->resume("hello "); // echo "hello world"
</code>

=== Implementation Detail ===

===== Backward Incompatible Changes =====

"Fiber" are now globally defined classes, which might collide with user defined classes of the same name in the global namespace. However, the risk of the introduction of them is considered to be very low, since the global namespace should not be used by PHP users.

===== Proposed PHP Version(s) =====
7.3

===== RFC Impact =====
==== To SAPIs ====
None

==== To Existing Extensions ====
None

==== To Opcache ====
None

==== New Constants ====
None

==== php.ini Defaults ====
- fiber.stack_size default stack size for A fiber

===== Open Issues =====
<blockquote>What happens if there are internal calls on the call stack?Say something like array_map(function() { await; }, [1, 2, 3]); inside a fiber. Internal calls (using the C stack rather than the VM stack) are usually the problem with this kind of endeavor.
</blockquote>

Fiber does not support yielding during the internal call. Calling Fiber::yield in a internal call will trigger a fatal error.

<blockquote>How do you determine when a fiber has returned? Looking at the source, it appears Fiber::status() must be used, comparing against constants. Separate methods similar to Generator would be better.</blockquote>

Offering methods like <code>Fiber::alive()</code>, <code>Fiber::running()</code> makes any meaningful difference to check the <code>Fiber::status()</code> return value. This is just a coding style issue. And as a language feature, Fiber only offer the essential API and let other works to the userland code.

<blockquote>What about throwing exceptions into a fiber?</blockquote>

The Fiber::throw(Exception $exception) has been implemented.

<blockquote>Using Fiber::resume() to initialize the fiber and resume feels awkward. Separate methods again would be better here, perhaps Fiber::init(...$args) and Fiber::resume($send).</blockquote>

Both Ruby's Fiber and Lua's coroutine using the **resume()** API to **init** and **resume** their coroutine. There is no need to offer a **dedicate init** API.

<blockquote>What happens if the sub1() function in the RFC is invoked outside of a fiber?</blockquote>

You will get a Fatal Error like

Fatal error: Uncaught Error: Cannot call Fiber::yield out of Fiber

<blockquote>I think a keyword here would be beneficial, even if it has a minor BC impact. Fibers could then be written like generators. `await` or `emit` as a keyword perhaps? This would be a less verbose API, feel less magical (a static method call that actually pauses execution feels out of place), and would allow Fibers to be returned from methods, named functions, etc with less boilerplate.</blockquote>

Introducing new keywords like await/emit does not offer any essential benefit but only cause BC impact.

Both Ruby's Fiber and Lua's coroutine use method to pause and resume their coroutine. There is no need to introduce new keyword.

===== Unaffected PHP Functionality =====
None

===== Future Scope =====
This sections details areas where the feature might be improved in future, but that are not currently proposed in this RFC.

===== Proposed Voting Choices =====
2/3+1 voting majority

===== Patches and Tests =====
  * https://github.com/php/php-src/pull/3203
  * <del>[[https://github.com/php/php-src/pull/2723]]</del>
  * <del>[[https://github.com/php/php-src/pull/2733]]</del>
  * <del>[[https://github.com/php/php-src/pull/2886]]</del>
  * <del>[[https://github.com/php/php-src/pull/2902]]</del>

===== Implementation =====
After the project is implemented, this section should contain
  - the version(s) it was merged to
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature
  - a link to the language specification section (if any)

===== References =====
  * [[http://www.inf.puc-rio.br/~roberto/docs/MCC15-04.pdf|Revisiting Coroutines]]
  * [[https://ruby-doc.org/core-2.4.1/Fiber.html|Ruby Fiber]]
  * [[https://www.lua.org/pil/9.1.html|Lua Coroutine]]

===== Rejected Features =====