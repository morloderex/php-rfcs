====== PHP RFC: Partial Function Application ======
  * Version: 2
  * Date: 2020-04-22
  * Author: Paul Crovella, Levi Morrison, Joe Watkins, Larry Garfield
  * Status: In Discussion
  * First Published at: https://wiki.php.net/rfc/partial_function_application

===== Preface =====

In order to better understand the terminology in this document and the feature being proposed here we need to lay some groundwork. We intend to use the word "application" in a very specific context for PHP.

Developers intuitively think of a call as an atomic action - either a call has been performed or it hasn't. However, calling a function is actually a multi-step process.  The part of the process we are interested in is referred to as application.

The following is what we normally refer to as a call site, or call:

<code php>
foo(1, 2, 3)
</code>

  * When the engine encounters ''foo'', a call frame is initialized and pushed onto the stack. 
  * At the opening ''('' the engine begins //applying// arguments to the call frame. 
  * At the closing '')'', application is complete and the call is performed.

"Application" then, in simple terms, refers to what is happening between the opening and closing brace at a call site.

In partial application, one or more of the arguments at the call site are replaced by place holders; The engine does the normal work of application, but at the closing '')'' application is only partially complete, and so no call is performed.  For example:

<code php>
foo(1, ?, 3);
</code>

Instead the engine will return a Closure which stores the function that was invoked (in this case, ''foo'') at the call site as well as scope information (ie. ''$this''), and the arguments exactly as applied.  Execution then continues normally, freeing the partially complete frame initially pushed onto the stack.

The programmer is able to fill in the place holders by further (partial, or complete) application of the Closure: Upon further application, the Closure will merge all arguments as applied up to this point with the arguments from the current application.  If there are still placeholders to fill, it will return a new Closure.  If not, the original function will be invoked and its result returned.

The Closure also includes a function stub with a signature derived from the original function's signature, excluding the parameters that were already provided.  That means to the rest of the engine, and in particular the reflection API, the Closure has a signature compatible with further application.  In particular, that means parameter names, type declarations, and reference-or-not are carried through to the Closure.

===== Placeholder Semantics =====

This RFC introduces two place holder symbols:

  * ''?'' means that exactly one argument is expected at this position.  This is the "unary placeholder."
  * ''...'' means that zero or more arguments may be supplied at this position.  This is the "variadic placeholder."

===== Rules of Partial Application =====

The following rules apply to partial application:

  * ''...'' may only occur once
  * ''...'' may only be followed by named arguments
  * named arguments must come after all place holders
  * named placeholders are not supported

===== Introduction =====

Partial application has two main, complementary benefits:

  - It allows developers to "fill in" a function call over time as its arguments become available, in any order.
  - It allows developers to reference a function directly, by name, with or without providing some of its arguments in the process.

A simple example of where that is beneficial would be in array application functions, for example: 

<code php>
$result = array_map(do_stuff(?), $arr);
</code>

In practice, partial application behaves very similar to a short lambda that simply returns another function, passing along additional variables.  The implementation is subtly different, and more efficient, but is logically equivalent.  (See the examples section below.)

If a partial application Closure is called with more arguments than the underlying function is able to handle, a fatal error is thrown.  That is consistent with the way internal functions already behave, although not user-space functions which will simply ignore excess arguments.  Excessive arguments are, usually, a sign of a bug.  If arbitrary additional arguments are desired, the underlying function should use a variadic argument, which is fully supported.  (See below.)

Note that for the purposes of this RFC, "function" refers to any callable.  Named function, named method, named static method, anonymous function, short-anonymous function, etc.  Partial application applies to all of them.

===== Examples =====

<code php>
// Given:
function stuff(int $i, string $s, float $f, Point $p, int $m = 0) {}

// Each of these blocks contain logically equivalent statements.

// Ex 1
stuff(?, ?, ?, ?, ?);
fn(int $i, string $s, float $f, Point $p, int $m) 
  => stuff($i, $s, $f, $p, $m);

// Ex 2
// This differs from Ex 1 because the ... 
// retains the optionalness of $m.
stuff(?, ?, ...);
stuff(...);
fn(int $i, string $s, float $f, Point $p, int $m = 0)
  => stuff($i, $s, $f, $p, $m);

// Ex 3
stuff(1, 'hi', ?, ?, ?);
fn(float $f, Point $p, int $m) => stuff(1, 'hi', $f, $p, $m);

// Ex 4
stuff(1, 'hi', ...);
fn(float $f, Point $p, int $m = 0) => stuff(1, 'hi', $f, $p, $m);

// Ex 5
stuff(1, ?, 3.5, ?, ?);
fn(string $s, Point $p, int $m) => stuff(1, $s, 3.5, $p, $m);

// Ex 6
stuff(1, ?, 3.5, ...);
fn(string $s, Point $p, int $m = 0) => stuff(1, $s, 3.5, $p, $m);

// Ex 7
stuff(?, ?, ?, ?, 5);
fn(int $i, string $s, float $f, Point $p) 
  => stuff($i, $s, $f, $p, 5);

// Ex 8
// Not accounting for an optional argument
// means it will always get its default value.
stuff(?, ?, ?, ?); 
fn(int $i, string $s, float $f, Point $p) 
  => stuff($i, $s, $f, $p);

// Ex 9
stuff(?, ?, f: 3.5, p: $point);
stuff(?, ?, p: $point, f: 3.5);
fn(int $i, string $s) => stuff($i, $s, 3.5, $point);

// Ex 10
stuff(?, ?, f: 3.5, ..., p: $point);
fn(int $i, string $s, int $m = 0) => stuff($i, $s, 3.5, $point, $m);

// Ex 11
// Prefill all params, making a "delayed call"
stuff(1, 'hi', 3.4, $point, 5, ...);
fn(...$args) => stuff(1, 'foo', 3.4, $point, 5, ...$args);

// Ex 12
stuff(?, ?, ?, ..., p: $point);
fn(int $i, string $s, float $f, ...$args) 
  => stuff($i, $s, $f, $point, ...$args);


// For a function with a variadic argument, the 
// variadic-ness is not propagated to the partial directly.
// It may, however, be implicitly handled by ''...''

function things(int $i, float $f, Point ...$points) { ... }

// Ex 13
things(...);
fn(int $i, float $f, ...$args) => things(...[$i, $f, ...$args]);

// Ex 14
things(1, 3.14, ...);
fn(...$args) => things(...[1, 3.14, ...$args]);

// Ex 15
// In this version, the partial requires precisely four arguments,
// the last two of which will get received 
// by things() in the variadic parameter.
things(?, ?, ?, ?);
fn(int $i, float $f, Point $p1, Point $p2) => things($i, $f, $p1, $p2);


function four(int $a, int $b, int $c, int $d) {
    print "$a, $b, $c, $d\n";
}

// Ex 16
// These all print "1, 2, 3, 4"
(four(...))(1, 2, 3, 4);
(four(1, 2, ...))(3, 4);
(four(1, 2, 3, ?))(4);
(four(1, ?, ?, 4))(2,3);
(four(1, 2, 3, 4, ...))();
(four(..., d: 4, a: 1))(2, 3);

// Ex 17
function zero() { print "hello\n"; }
zero(...)(); // prints "hello\n"
</code>

===== Error examples =====

The following examples are all errors, for the reasons given.

<code php>
// Given
function stuff(int $i, string $s, float $f, Point $p, int $m = 0) {}

// Insufficient parameters.
stuff(?);

// Parameter $i used more than once.
stuff(?, ?, 3.5, $point, i: 5);

// Positional argument used after named argument.
stuff(i:1, ?, ?, ?, ?);

// Cannot use placeholder on named arguments.
stuff(1, ?, 3.5, p: ?);

// Cannot use positional placeholder after named argument.
stuff(?, ?, ?, p: $point, ?);
</code>

===== Variables/References =====

Variable arguments are ''use''d, and done so by reference if specified in the called function definition.

<PHP>
function f($value, &$ref) {}
 
$array = ['arg' => 0];

$f = f(?, $array['arg']);
</PHP>

is equivalent to

<PHP> 
$ref = &$array['arg'];
$f = function($value) use (&$ref) {
    return f($value, $ref);
};
</PHP>

===== func_get_args() and friends =====

''func_get_args()'', ''func_num_args()'', and similar functions are unaware of intermediate applications: The underlying function is only ever called once, using all the parameters that were built up over any number of applications. That means they will behave exactly as though all of the specified arguments were passed directly to the function all at once.

<code php>
function f($a = 0, $b = 0, $c = 3, $d = 4) {
    echo func_num_args() . PHP_EOL;
    
    var_dump(
        $a, 
        $b, 
        $c, 
        $d);
}

f(1, 2);

$f = f(?);

$f(1, 2);
</code>

Would output:

<code php>
2
int(1)
int(2)
int(3)
int(4)
2
int(1)
int(2)
int(3)
int(4)
</code>

===== Variadic Functions =====

Targeting a variadic parameter with ''?'' means the variadic becomes required, because ''?'' means exactly one parameter.

Targeting a variadic parameter with ''...'' allows it to accept a variable number of arguments, which will be passed through to the variadic parameter.  This behavior is consistent with the general model of "a partial is a function that passes all of its arguments through to the underlying function, after mixing them together."

For example:

<code>
function f(...$args) {
    print_r($args);
}

// This will require precisely 3 arguments, which
// f() will receive as a 4 element $args.
$f1 = f(1, ?, ?, ?);

// This will require 2 or more arguments, which
// f() will receive as a 2 or more element $args.
$f2 = f(?, ?, ...);

// This will require exactly 1 argument.
// f() will receive a 3 element $args.
$f3 = f(1, ?, 3);

// This will require exactly 3 arguments.
// f() will receive a 6 element $args.
$f4 = f(?, 2, ?, 4, ?, 6);

// This will require at least 2 arguments.
// f() will receive an $args array with the fixed values
// and additional arguments interleaved, followed by
// whatever additional arguments are provided.
$f5 = f(?, 2, ?, 4, ...);
</code>

===== Evaluation order =====

One subtle difference between the existing short lambda syntax and the partial application syntax is that argument expressions are evaluated in advance.  That is:

<code php>
function getArg() {
  print __FUNCTION__ . PHP_EOL;
  return 'hi';
}

function speak(string $who, string $msg) {
  printf("%s: %s\n", $who, $msg);
}

$arrow = fn($who) => speak($who, getArg());
print "Mark\n";
$arrow('Larry');

/* Prints:
Mark
getArg
Larry: hi
*/

$partial = speak(?, getArg());
print "Mark\n";
$partial('Larry');

/* Prints:
getArg
Mark
Larry: hi
*/
</code>

The reason is that in the partial application case, the arguments are all evaluated first, and then the engine detects that some have placeholders.  In the short lambda case, the closure object is created first around an expression body that just so happens to include a function call that will happen later.

===== Constructors =====

Constructors would normally be only partially compatible with partial application (pun intended), as constructor creation is two step: First create the object, then call the constructor to initialize it.  A naive implementation of partial application would result in the partial being created between those two steps.  Thus, partially applying a constructor and then invoking it multiple times would invoke the constructor on the same object multiple times, rather than creating multiple objects.

That would be unexpected and undesireable from the user point of view.  Special handling has therefore been included for constructors so that both object creation and the constructor invocation occur upon complete application.

That means the following will result in 4 objects created, as one would expect.

<code php>
class Point {
  public function __construct(private int $x, private int $y) {}
}

$data = [
  [1, 2],
  [4, 6],
  [3, 9],
  [7, 4],
];

// This works fine.
$points = array_map(new Point(?, ?), $data);
</code>

===== Common use cases =====

Although partial application has a wide range of use cases, in practice we anticipate there to be three general categories that will be the overwhelming majority cases:

==== Callable reference ====

First class support for creating a Closure from a callable with ''...''.  

That means it can be used to create a reference to a function, method, or other callable without resorting to strings or arrays as a pseudo-callable format. 

For example:

<code php>
class Foo {
  public function bar($a, $b, $c, $d): string { ... }
}

$f = new Foo();
$p = $f->bar(...);

// $p is now a partially applied function with the same 4 arguments
// as Foo::bar. Effectively there is no difference between now calling 
// $p(1, 2, 3, 4) and $foo->bar(1, 2, 3, 4).
</code>

That would make such functions still accessible to refactoring and static analysis tools, while avoiding any new syntax.  This is especially useful when trying to use a method as a callable, or when passing a reference to a named function or method as an argument.

<code php>
function do_logic(Point $p) { }

array_map(do_logic(...), $list_of_points);
</code>

==== Unary functions ====

A unary function is a function with a single parameter.  Many callbacks require a unary function,  which partial application makes trivial to produce.  For example:

<code php>
$result = array_map(in_array(?, $legal, strict: true), $input);
</code>

This use case is especially useful in combination with the [[rfc:pipe-operator-v2|Pipe Operator v2]] RFC, as discussed below.

==== Delayed execution ====

Partial application may return a closure with all required arguments applied, followed by ''...'':  That results in a closure that has all the arguments it needs for the underlying function but is not, yet, executed, and takes zero or more arguments.  It may therefore be called to execute the original function with its parameters at a later time.

<code php>
function expensive(int $a, int $b, Point $c) { /* ... */ }

$default = expensive(3, 4, $point, ...);
// $default here is a closure object.
// expensive() has not been called.

// Some time later, evaluate the function call only when necessary.
if ($some_condition) {
  $result = $default();
}
</code>

===== Optimizations =====

Although the result of partial application is a ''Closure'', since partial application is cumulative, there is no need to call intermediate objects upon complete application.

That is:

<code php>
function foo(int $a, int $b, int $c, int $d, int $e) { 
    throw new Exception("boo");
}

$foo = foo(1, ?, ?, ?, ?);

$bar = $foo(2, ...);

$baz = $bar(3, ...);

$boo = $baz(4, ...);

$boo(5);
</code>

Will produce something that matches:

<code>
Fatal error: Uncaught Exception: boo in %s:%d
Stack trace:
#0 %s(%d): foo(1, 2, 3, 4, 5)
#1 %s(%d): Closure->__invoke(5)
#2 {main}
  thrown in %s on line %d
</code>
===== Reflection =====

Because a partial application results in a ''Closure'', no changes to the reflection API are necessary.  It may be used by reflection in the same fashion as any other Closure or function, specifically using ''ReflectionFunction''.

===== Comparison to other languages =====

Partial function application is a common pattern in computer science generally.  In practice, though, few mainstream languages have a dedicated syntax for it, relying instead on user-space implementations similar to "just write your own arrow function."

The languages that do have native support for it are generally highly functional languages such as Haskell or OCaml, in which all functions are automatically curried to single argument functions anyway.  In those languages, calling a function with fewer arguments than it specifies will automatically partially apply it with just those arguments, returning a function that expects the remaining arguments.  One limitation of that approach, however, is that functions may be partially applied only from left to right.  There is no way to "pre fill" just the right-most argument.

The notable exception is Raku (formerly known as Perl 6), which has an ''assuming'' method that prefills arguments left to right as well.

The net result is that the functionality described here would give PHP the most robust and powerful partial application syntax of any significant language on the market today.  Which is pretty damned cool, frankly.

Source: https://rosettacode.org/wiki/Partial_function_application

There is a pending proposal for Javascript to add PFA syntax that is remarkably similar to that proposed here, although it is not as far along: https://github.com/tc39/proposal-partial-application

===== Syntax choices =====

The ''?'' character was chosen for the placeholder largely because it was unambiguous and easy to implement.  Prior, similar RFCs (such as the original [[rfc:pipe-operator|Pipe Operator]] proposal from several years ago) used the ''$$'' sigil instead.  The RFC authors are open to considering other characters if they can be trivially swapped out, but would only support ''$$'' if it gets called ''T_BLING''.

The ''...'' symbol was chosen for its similarity to variadic arguments.  They are conceptually similar, and thinking of ''...'' as the partial equivalent of ''...$args'' in a normal function is approximately accurate.

===== Related RFCs =====

Although this RFC is stand-alone, it naturally complements a few others under current discussion.

The [[rfc:pipe-operator-v2|Pipe Operator v2]] RFC proposes a new ''|>'' (pipe) operator that concatenates two callables, but was hampered by PHP's poor syntax for callables.  This RFC would largely resolve that issue and allow for the following syntax for pipes:

<code php>
$result = $var
|> step_one(?)
|> step_two(?, 'config')
|> $obj->stepThree('param', ?);
</code>

The original Pipes v1 proposal several years ago included similar functionality baked directly into the pipe operator.  By separating the two, it allows partial application to be used generally while still offering the same convenience for the pipe use case.

===== Backward Incompatible Changes =====

None.

===== Implementation =====

PR is available here: https://github.com/php/php-src/pull/6898

===== Proposed PHP Version(s) =====

Next major/minor

