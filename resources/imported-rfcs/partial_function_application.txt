====== PHP RFC: Partial Function Application ======
  * Version: 1.1
  * Date: 2020-04-22
  * Author: Paul Crovella, Levi Morrison, Joe Watkins, Larry Garfield
  * Status: In Discussion
  * First Published at: https://wiki.php.net/rfc/partial_function_application

===== Introduction =====
Partial function application is the process of fixing (or applying) only some of the arguments to a function call and leaving the remainder to be provided at a later point, either by further application or invocation.

This technique has two main, complementary benefits:

  - It allows developers to "fill in" a function call over time as its arguments become available, in any order.
  - It allows developers to reference a function directly, by name, with or without providing some of its arguments in the process.

A simple example of where that is beneficial would be in array application functions, for example: 

<code php>
$result = array_map(do_stuff(?), $arr);
</code>

===== Proposal =====

This RFC adds support for partial application via a new argument placeholder, ''?''.  At any given call site (where one would call a function, method, or any other ''callable''), the developer may replace one or more of the function arguments with an argument placeholder.  If so, then rather than applying arguments to the function in-place, the engine will instead construct and return a ''Closure'' object that captures the evaluated arguments by value.  That ''Closure'' object will have a signature that matches the original function being invoked, with the applied arguments removed.

The ''Closure'' may then be invoked at a later time with the remaining arguments.

<PHP>
function whole($one, $two) {
    /* ... */
}

$partial = whole(?, 2);
</PHP>

''$partial'' now has the prototype:

<PHP>
function($one) {
   /* ... */
}
</PHP>

this process is logically equivalent to:

<code php>
$partial = fn($one) => whole($one, 2);
</code>

At the call site (when the Closure is invoked), the engine will invoke the function originally being called at the application site, with the arguments positioned as resolved at the application site (this is important for named parameters). The arguments provided at the call site will be taken for any missing or extra arguments:

<PHP>
function whole($one, $two) { /* ... */ }

// equivalent to calling whole(1, 2, 3)
$result = whole(?, 2)(1, 3); 
</PHP>

Note that for the purposes of this RFC, "function" refers to any callable.  Named function, named method, named static method, anonymous function, short-anonymous function, etc.  Partial application applies to all of them.

==== Types ====

Type declarations are retained, as are parameter names (e.g. for reflection.)

<PHP>
function f(int $x, int $y): int {}

$partial = f(?, 42);
</PHP>

is equivalent to

<PHP>
$partial = function(int $x): int {
    return f($x, 42);
};
</PHP>


==== Variables/References ====

Variable arguments are ''use''d, and done so by reference if specified in the called function definition.

<PHP>
function f($value, &$ref) {}
 
$array = ['arg' => 0];

$f = f(?, $array['arg']);
</PHP>

is equivalent to

<PHP> 
$ref = &$array['arg'];
$f = function($value) use (&$ref) {
    return f($value, $ref);
};
</PHP>

==== Argument handling ====

In an argument list, positional arguments always must come first, followed by named arguments, if present.  (This is the case already in PHP 8.0.)  The positional argument list consists of the parameters of the underlying function, excluding any that appear in the named argument list.

The presence of at least one ''?'' in the positional argument list indicates that the expression is a partial application, not a function call, regardless of how many parameters the underlying function has.

The function signature of the underlying function is copied to the created ''Closure'', in order, including types and default values.

Any positional argument other than ''?'' will be bound to that argument in the underlying function, and not appear in the signature of the partially applied function.

A ''?'' is used to skip over parameters which you do not want to bind values for, and leaves the parameter information copied from the underlying function.

A ''?'' is not allowed in the named argument list.

No more than one trailing ''?'' is allowed at the end of the positional argument list, but one is always allowed even if there is no parameter in that position.

Invoking a partially applied function with more arguments than is necessary will result in the extra arguments being passed through to the underlying function unchanged.  They will be accessible via ''func_get_args()'' et al if desired, just like if they were passed directly to the function.

That results in the following examples:

<code php>
function four(int $a, int $b, int $c, int $d) {
    print "$a, $b, $c, $d\n";
}

// These all print "1, 2, 3, 4"
four(?)(1, 2, 3, 4);
four(1, 2, ?)(3, 4);
four(1, 2, 3, ?)(4);
four(1, ?, ?, 4)(2,3);
four(1, 2, 3, 4, ?)();
four(?, d: 4, b: 2, a: 1)(3);
four(?, d: 4, a: 1)(2, 3);

function zero() { print "hello\n"; }

zero(?)(); // prints "hello\n"

function two(int $a = 1, $b = 2) {
    print "$a, $b\n";
}

// These all print "1, 2"
two(?)(1, 2);
two(?)();
two(1, ?)();

// The following, however, are all errors:

four(?, ?, ?, ?); // Too many trailing ?
four(a: 1, ?); // Positional argument after named argument.
four(?)(1, 2); // Too few arguments provided to the partial call.
four(a: 1, b: ?, c: ?, d: 4); // Cannot use placeholders on named arguments.


// Heavy use of named arguments
function message(string $salutation, string $name, string $stmt): string {
    return "$salutation, $name. $stmt" . PHP_EOL;
}

$p = message(?, salutation: "Hello");
// Both of these have the same effect.
print $p('World', 'How are you.');
print $p(stmt: 'How are you.', name: 'World');
</code>


As an implication of this design, a callable of any arity can be partially applied without any binding with a single ''?''.  That is:

<code php>
class Foo {
  public function bar($a, $b, $c, $d, $e, $f, $g, $h): string { ... }
}

$f = new Foo();
$p = $f->bar(?);

// $p is now a partially applied function with the same 8 arguments
// as Foo::bar. Effectively there is no difference between now calling 
// $p(1, 2, 3, 4, 5, 6, 7, 8) and $foo->bar(1, 2, 3, 4, 5, 6, 7, 8).
</code>

That is especially useful when trying to use a method as a callable.

==== func_num_args et al. ====

When a partial invokes ''func_num_args'', it shall behave as if the function was invoked directly, such that:

<PHP>
function f($a = 0, $b = 0, $c = 3, $d = 4) {
    echo func_num_args() . PHP_EOL;
    
    var_dump(
        $a, 
        $b, 
        $c, 
        $d);
}

f(1, 2);

$f = f(?);

$f(1, 2);
</PHP>

Would output:

<PHP>
2
int(1)
int(2)
int(3)
int(4)
2
int(1)
int(2)
int(3)
int(4)
</PHP>

==== Variadic Functions ====

Variadic functions retain their signatures. Placeholders in a variadic position remain optional (there are no defaults, places not filled are simply not included in what's sent to the underlying function.) Fixed and placeholder arguments can be interleaved together.

<PHP>
function f(...$args) {
    print_r($args);
}

$f = f(?, 2, ?, 4, ?, 6);
$f(1, 3);
</PHP>

Would output:

<PHP>
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 6
)
</PHP>

Variadic named arguments are also supported, which results in the following being legal:

<code php>
function four(int $a, int $b, int $c, int $d) {
    print "$a, $b, $c, $d\n";
}

$args[
  'd' => some_computation_that_returns_4(),
  'b' => 2,
];
  
$p = four(?, ...$args);

$p(1, 3); // Prints 1, 2, 3, 4

</code>


==== Evaluation order ====

One subtle difference between the existing short lambda syntax and the partial application syntax is that argument expressions are evaluated in advance.  That is:

<code php>
function getArg() {
  print __FUNCTION__ . PHP_EOL;
  return 'hi';
}

function speak(string $who, string $msg) {
  printf("%s: %s\n", $who, $msg);
}

$arrow = fn($who) => speak($who, getArg());
print "Mark\n";
$arrow('Larry');

/* Prints:
Mark
getArg
Larry: hi
*/

$partial = speak(?, getArg());
print "Mark\n";
$partial('Larry');

/* Prints:
getArg
Mark
Larry: hi
*/
</code>

The reason is that in the partial application case, the arguments are all evaluated first, and then the engine detects that some have placeholders.  In the short lambda case, the closure object is created first around an expression body that just so happens to include a function call that will happen later.

==== Constructors ====

Constructors would normally be only partially compatible with partial application (pun intended), as constructor creation is two step: First create the object, then call the constructor to initialize it.  A naive implementation of partial application would result in the partial being created between those two steps.  Thus, partially applying a constructor and then invoking it multiple times would invoke the constructor on the same object multiple times, rather than creating multiple objects.

That would be unexpected and undesireable from the user point of view.  Special handling has therefore been included for constructors so that both object creation and the constructor invocation happen with the partial ''Closure''.  That means repeatedly calling a partially applied constructor will result in a new object each time, as expected.

That means the following will result in 4 objects created, as one would expect.

<code php>
class Point {
  public function __construct(private int $x, private int $y) {}
}

$data = [
  [1, 2],
  [4, 6],
  [3, 9],
  [7, 4],
];

// This works fine.
$points = array_map(new Point(?, ?), $data);
</code>

==== Use as an identifier ====

Although not the primary goal, this feature also provides a way to reference a function as a callable if needed in a given context.  Specifically, omitting all parameters during application would result in a callable with the same arity and signature as the original.  For example:

<PHP>
function by5(int $x) { return $x * 5; }

$arr = [1, 2, 3, 4, 5];

$result = array_map(by5(?), $arr);
</PHP>

That would make such functions still accessible to refactoring and static analysis tools, while avoiding any new syntax.

==== Optimizations ====

Although partials are implemented as a ''Closure'' instance, they do include an optimization in the case of repeated partial application to eliminate intermediate applications, and thus the resulting call stack when they are eventually called will include only one stack frame.

That is:

<code php>
function test(int $a, int $b, int $c, int $d, int $e) { ... }

$one = test(1, ?)(2, ?)(3, ?)(4, ?);

$two = test(1, 2, 3, 4, ?);

$three = fn(int $e) => test(1, 2, 3, 4, $e);


// These calls will all add only a single call frame,
// which will then call test(1, 2, 3, 4, 5);
// From a semantic and performance perspective they are identical.
$one(5);
$two(5);
$three(5);
</code>

===== Reflection =====

Because a partially applied function is implemented using the existing ''Closure'' object, no additional reflection logic is necessary.  Once created, a partially applied function is identical to a manually created equivalent closure, and may be reflected upon the same way.

===== Comparison to other languages =====

Partial function application is a common pattern in computer science generally.  In practice, though, few mainstream languages have a dedicated syntax for it, relying instead on user-space implementations similar to "just write your own arrow function."

The languages that do have native support for it are generally highly functional languages such as Haskell or OCaml, in which all functions are automatically curried to single argument functions anyway.  In those languages, calling a function with fewer arguments than it specifies will automatically partially apply it with just those arguments, returning a function that expects the remaining arguments.  One limitation of that approach, however, is that functions may be partially applied only from left to right.  There is no way to "pre fill" just the right-most argument.

The notable exception is Raku (formerly known as Perl 6), which has an ''assuming'' method that prefills arguments left to right as well.

The net result is that the functionality described here would give PHP the most robust and powerful partial application syntax of any significant language on the market today.  Which is pretty damned cool, frankly.

Source: https://rosettacode.org/wiki/Partial_function_application

There is a pending proposal for Javascript to add PFA syntax that is remarkably similar to that proposed here, although it is not as far along: https://github.com/tc39/proposal-partial-application

===== Syntax choices =====

The ''?'' character was chosen for the placeholder largely because it was unambiguous and easy to implement.  Prior, similar RFCs (such as the original [[rfc:pipe-operator|Pipe Operator]] proposal from several years ago) used the ''$$'' sigil instead.  The RFC authors are open to considering other characters if they can be trivially swapped out, but would only support ''$$'' if it gets called ''T_BLING''.

Baring any strong consensus to the contrary, the plan is to stick with ''?''.

===== Related RFCs =====

Although this RFC is stand-alone, it naturally complements a few others under current discussion.

The [[rfc:pipe-operator-v2|Pipe Operator v2]] RFC proposes a new ''|>'' (pipe) operator that concatenates two callables, but was hampered by PHP's poor syntax for callables.  This RFC would largely resolve that issue and allow for the following syntax for pipes:

<code php>
$result = $var
|> step_one(?)
|> step_two(?, 'config')
|> $obj->stepThree('param', ?);
</code>

The original Pipes v1 proposal several years ago included similar functionality baked directly into the pipe operator.  By separating the two, it allows partial application to be used generally while still offering the same convenience for the pipe use case.

===== Backward Incompatible Changes =====

None.

===== Implementation =====

PR is available here: https://github.com/php/php-src/pull/6898

===== Proposed PHP Version(s) =====

Next major/minor

