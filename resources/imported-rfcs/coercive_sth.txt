====== PHP RFC: Coercive Types for Function Arguments ======
  * Version: 0.11
  * Date: 2015-02-20
  * Author: Zeev Suraski <zeev@php.net>, others, to remain anonymous at this point :)
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/coercive_sth

===== Background & Summary =====
Scalar Type Hints have been a top requested feature for PHP for a very, very long time.  There have been numerous attempts at introducing them to the language, all of which failed to make it into the language thus far.
While there seems to be consensus regarding the viability and usefulness of adding Scalar Type Hints (STH), there’s been a long standing debate regarding what is the correct way to implement them.  The two key schools of thoughts around STH that emerged over the years are:

  - **Strict STH**.  In essence, this approach conducts a very simple zval.type check on the value being passed from the caller to the callee;  If there’s a match – the argument is accepted, otherwise rejected.  Coercion is (almost) never performed, so, for instance, a callee that expects an integer argument and is passed a “32” (string) – will reject it.
  - **Dynamic (weak) STH**.  Unlike strict STH, dynamic STH automatically converts values which are not already of the type that is expected by the callee into that type, according to the same ruleset presently used by internal functions.  That means that a callee expecting an integer that will be passed “32” (string), will successfully receive the argument, and it will be automatically converted to 32 (int).

It’s important to note that in terms of the code *inside* the callee, there’s absolutely no difference between the two schools of thought.  In both cases, the callee can rely with absolute confidence that if it typed hinted a certain argument as an int – this argument will always be an int.  The difference is localized to the behavior surrounding the invocation of the callee by the caller – with Strict STH will reject a lot more potential inputs as invalid, compared to Dynamic STH.

Proponents of Strict STH cite numerous advantages, primarily around code safety/security.  In their view, the conversion rules proposed by Dynamic STH can easily allow ‘garbage’ input to be silently converted into arguments that the callee will accept – but that may, in many cases, hide difficult-to-find bugs or otherwise result in unexpected behavior.

Proponents of Dynamic STH bring up consistency with the rest of the language, including some fundamental type-juggling aspects that have been key tenets of PHP since its inception.  Strict STH, in their view, is inconsistent with these tenets.

This RFC proposes a composite solution, which attempts to address the main goals of both camps, dubbed **Coercive STH**.  Coercive STH are less restrictive than simple zval.type checks, but a lot more restrictive than the conversion rules presently employed by internal functions.  They attempt to strike a balance between rejecting erroneous input, and allowing valid-but-wrongly-typed input.
Further, the RFC suggests a gradual solution for employing this new, more restrictive ruleset into internal functions.

Finally, the RFC outlines a potential future evolution of employing the new ruleset into additional parts of PHP, most notably implicit type conversions (outside the scope of this specific RFC).


===== Proposal =====

==== User-land Additions ====

This RFC proposes to introduce four new type hints into PHP – int, float, string and bool.
Arguments hinted with one of these STHs will accept values that are either already of that expected type (‘native’), or that can be coerced into the requested type without any data loss on one hand, and without creating ‘garbage’ data that wasn’t there on the other.

The exact behavior of each type hint is detailed in the following tables.
  * DL stands for 'Data Loss'.
  * Accept means either accept the value as-is (if it's already of the requested type), or convert it to the requested type.
  * Reject means triggering an E_RECOVERABLE_ERROR.

=== Integer STH (int) ===
^ Passed Value Type  ^ int    ^ float                                                  ^ string                                                                                                             ^ bool   ^ null   ^ array  ^ object  ^ resource ^
^ Behavior           ^ Accept ^ Accept only if no DL\\ ''7.0 accepted\\ 7.1 rejected'' ^ Accept numeric strings, only if no DL\\ ''"32", "42.0" accepted\\ "Apple", "100 dogs", "  123", "123  " rejected'' ^ Reject ^ Reject ^ Reject ^ Reject  ^ Reject   ^

=== Floating Point STH (float) ===
^ Passed Value Type  ^ int                   ^ float    ^ string                                                                                                                     ^ bool   ^ null   ^ array  ^ object  ^ resource ^
^ Behavior           ^ Accept only if no DL† ^ Accept   ^ Accept numeric strings, only if no DL\\ ''"32", "42.0", "1E07" accepted\\ "Apple", "100 dogs", "  123", "123  " rejected'' ^ Reject ^ Reject ^ Reject ^ Reject  ^ Reject   ^

† Integers that can be safely converted into a floating point number without losing accuracy, will be coerced successfully.  However, integers that are too big to fit into a floating point variable (double) - will be rejected.

=== String STH (string) ===
^ Passed Value Type  ^ int     ^ float    ^ string  ^ bool   ^ null   ^ array  ^ object                                               ^ resource ^
^ Behavior           ^ Accept  ^ Accept   ^ Accept  ^ Reject ^ Reject ^ Reject ^ Accept\\ ''Only if object has __toString() method''  ^ Reject   ^

=== Boolean STH (bool) ===
^ Passed Value Type  ^ int      ^ float     ^ string   ^ bool   ^ null   ^ array  ^ object  ^ resource ^
^ Behavior           ^ Accept‡  ^ Accept‡   ^ Accept‡  ^ Accept ^ Reject ^ Reject ^ Reject  ^ Reject   ^

‡ Booleans are one of the interesting open questions in this RFC.  This RFC takes the position that booleans cannot be safely converted to any other type, and thus, int, float and string STHs reject them.  However, whether other types should successfully coerce into boolean in the case of a boolean type hint - as integers, floats and strings do across the language is open for debate, and perhaps a secondary vote.


==== Changes to Internal Functions ====

This RFC proposes to bring the rule-set described in the last section to internal functions as well, through updates to the zend_parse_parameters() function.  (NEED TO ELABORATE ON THE CHANGES FROM EXISTING BEHAVIOR).
However, given that unlike the introduction of STH - which is a new, previously unused feature that will (for the most part) not affect existing code - changes to what internal functions would be willing to accept could have substantial compatibility implications.

There are 3 key approaches we could take to tackle that challenge.
  - **Just Do it™**.  Emit E_RECOVERABLE_ERROR on every input that is rejected due to the new stricter rules.  Key upside - consistency, and given that the proposed rules are lax enough to allow the majority of legitimate inputs to pass through, it may not be as bad as one might think.  It's likely that many if not most of the conversions that will be denied by the stricter rules would be exposing bugs or shortcomings in the code.  Key downside of this approach is that it somewhat deviates from our rule of deprecating functionality, and only afterwards removing/changing it.  Also, a developer that may have intentionally relied on "100g" or "17.7oz" to cleanly convert to int/float respectively, may view this as a change in behavior, rather than pointing out a bug in his code.
  - **Emit E_DEPRECATED in 7.0, move to E_RECOVERABLE_ERROR in v7.1 or v8.0**.  The upside - no compatibility breakage, beyond newly introduced E_DEPRECATED.  Key downside - no way for strict campers to go all the way in v7.0.  One possible remedy for the downside is that perhaps, under these very special circumstances, we introduce a temporary INI entry that will change the default E_DEPRECATED behavior into E_RECOVERABLE_ERROR.  While none of us is fond of INI entries that affect runtime behavior (probably an understatement), this is a temporary measure that will no longer be needed as soon as the migration to E_RECOVERABLE_ERROR is complete.  It's some sort of a 'fast forward' switch for strict campers.
  - **Just Do it™, but allow people to temporarily bail out.**  This is roughly the opposite of option #2.  Default to E_RECOVERABLE_ERROR, but allow people to change that behavior to E_DEPRECATED using INI.  Publish a clear roadmap as to when this compatibility switch will be removed from PHP.
 
The two-staged proposals (#2 and #3) would provide users ample time to update their code as needed to fit the new, more restrictive rule-set, at the cost of introducing a time-limited INI switch.
Most people who provided feedback to this first draft of the RFC were in favor of #1, but given the widespread implications, this is probably best left as a topic for discussion on internals@.


==== Future Changes to Implicit Casting Rules ====

While outside the scope of this RFC, the introduction of the new coercive-yet-more-restrictive rule-set may be considered for additional areas in PHP, most notably implicit casting.
For example, today, the result of "Apples" + "Oranges" is 0, because the + operator implicitly casts anything into a number.  It could be imagined that in the future, the + operator will accept only values that would fit into an int or float STH, and reject others.  Users would still be able to use explicit casting ($foo = (int) "Apples"; would still assign 0 into $foo), but the risk sometimes associated with implicit casting will be eliminated.


===== Comparison to the other RFC =====

Numerous community members have invested substantial effort into creating another comprehensive RFC, that proposes to introduce STH into PHP [[https://wiki.php.net/rfc/scalar_type_hints_v5|Scalar Type Hints RFC v0.5 ("Dual Mode RFC")]].  However, we believe the proposal in this RFC is better, for several different reasons:

  - **Single Mode.**  Even though the Dual Mode RFC presents a novel idea about how to allow developers to choose which mode they'd like to use, and use different modes in different parts of the app, it still introduces the burden of two different modes.  Two different rule-sets that need to be learned, may increase the language's complexity.  Further, the two sets can cause the same functions to behave differently depending on where they're being called, and potentially a new class of bugs stemming from developers not realizing which mode they're in in a particular file.  This RFC is unaffected by these issues, as it presents a single, composite rule set.
  - **Too strict may lead to too lax.** In the Dual Mode RFC, when in Strict mode, in many cases, functions would reject values that, semantically, are acceptable.  For example, a "32" (string) value coming back from an integer column in a database table, would not be accepted as valid input for a function expecting an integer.  Since semantically the developer is interested in this argument-passing succeeding, they would have the choice of either removing the integer STH altogether, or, more likely, explicitly casting the value into an integer.  This would have the opposite of the desired outcome of strict STHs - as explicit casts ($foo = (int) $foo;) always succeed, and would happily convert "100 dogs", "Apples" and even arrays and booleans into an integer.  Further, since already today, internal functions employ coercion rules that are more restrictive than PHP's explicit casting, pushing people towards explicit casting will actually make things **worse** in case developers opt for explicit casting as they pass values in an internal function call. 
  - **Smooth integration with Data Sources**.  PHP uses strings extensively across the language, and in most cases, data sources always feed data into PHP as strings.  PHP applications rely extensively on internal type juggling to convert that string-based data according to the needed context.  Strict zval.type based STH effectively eliminates this behavior, moving the burden of worrying about type conversion to the user.  The solution proposed in this RFC allows code that relies on type coercion to Just Work when the values are sensible, but fail (and appropriately warn the developer) otherwise.


In addition, there appear to be numerous misconception about benefits of strict type hinting, that to the best of our (deep) understanding of the associated technologies, aren't really there:

  - **Performance.**  There's complete consensus that there are no tangible performance differences between the strict and coercive typing.  The difference is that strict typing would block scenarios that coercive typing would allow;  But that's a difference in behavior, not performance.
  - **AOT/JIT implications.**  It is our position that there is no difference at all between strict and coercive typing in terms of potential future AOT/JIT development - none at all.  In both the case of strict and coercive STH, we can have full confidence that the value inside the callee is of the requested type;  And in both the case of strict and coercive STH, we can't make any assumptions about what is the type of value that the caller is passing as an argument.  Again, the difference is only that strict typing may reject values that coercive typing may accept;  But the very same checks need to be conducted in both cases;  The very same type inference can be used in both cases to potentially optimize these checks away;  Etc.
  - **Static Analysis**.  It is the position of several Strict STH proponents that Strict STH can help static analysis in certain cases.  For the same reasons mentioned above about JIT, we don't believe that is the case - although it's possible that Strict Typing may be able to help static analysis in certain edge cases.  However, it is out belief that even if that is true, Static Analyzers need to be designed for Languages, rather than Languages being designed for Static Analyzers.


===== Backward Incompatible Changes =====
Given the change to the acceptable values into a wide range of internal functions, this RFC is likely to result in a substantial number of newly introduced E_DEPRECATED warnings in internal function invocations, although those can be easily suppressed.  When E_DEPRECATED is replaced with E_RECOVERABLE_ERROR in a future PHP version, users will be forced to update their code and 'clean it up' before they can upgrade.
Also, the four newly introduced type hints (int, float, string and bool) will no longer permitted as class/interface/trait names (including with use and class_alias)

===== Proposed PHP Version(s) =====
7.0


===== Proposed Voting Choices =====
The voting choices would be yes/no.
The RFC proposes a very substantial change to PHP's coercion rules, which may evolve to affect implicit typing in the future.
It absolutely requires a 2/3 majority, with the hope of reaching as close as possible to consensus.