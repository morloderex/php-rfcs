====== PHP RFC: Semi-Automatic CSRF Protection ======
  * Version: 0.1
  * Date: 2016-05-10
  * Author: Yasuo Ohgaki <yohgaki@php.net>
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/automatic_csrf_protection


===== Introduction =====
CSRF ([[https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)|Cross Site Request Forgery]]) has been major vulnerability for PHP applications. CSRF protection is not difficult to implement especially with good web application frameworks. However, CSRF protection requires many lines of code if users have to implement by themselves. This proposal extends session module to provide optional automatic CSRF protection for any PHP web applications.

Session module has URL rewriter. It is used only for Trans SID (Transparent Session ID) for session management without cookie. URL rewriter can be extended to add CSRF protection token.


===== Proposal =====

====TL;DR;====

Session module is extended to manage CSRF status. When CSRF protection is enabled, CSRF attack is prevented by terminating execution by default. Developers may suppress error and detect CSRF protection(attack) status by themselves via new session function - session_csrf_status(). 

CSRF protection token is managed by session module and TTL value. Stolen CSRF protection token is valid upto defined TTL. Therefore, stolen CSRF protection token will not allow indefinite period of attacks. 

====Example - Protect sitewide CSRF via POST ====

php.ini
  session.csrf_rewrite = SESSION_CSRF_POST
  session.csrf_validation = SESSION_CSRF_POST

All post pages that use PHP session are protected. If application modify data only by POST, above INI settings and session_start() is enough for CSRF protection.

NOTE: Browsers cannot send POST request directly. i.e. It must display "form" before submit. Forms will have CSRF token by URL rewriter always. Therefore, POST requests have CSRF token always. 

====Example - Protect CSRF manually both POST and GET====

Entry page.

<code php>
<?php
// Add CSRF protection token to POST and GET 
session_start(['session.csrf_rewrite'=>SESSION_CSRF_POST|SESSION_CSRF_GET]);
?>
<html>
<head></head>
<body>
<a href="http://example.com/delete.php?id=1234">Remove ID:1234</a>

<form action="http://example.com/edit.php" method="POST">
<textarea name="comment"></textarea>
<input type="submit" />
</form>

</body>
</html>
</code>

Output to browser will be something like

<code html>
<html>
<head></head>
<body>
<a href="http://example.com/delete.php?id=1234&SESSCSRF=1462920523-5fd057a6ff9dc7a124fa5c814765a498e5aa024a">Remove ID:1234</a>

<form action="http://example.com/edit.php" method="POST">
<textarea name="comment"></textarea>
<input type="hidden" name="SESSCSRF" value="1462920523-5fd057a6ff9dc7a124fa5c814765a498e5aa024a" />
<input type="submit" />
</form>

</body>
</html>
</code>

delete.php
<code php>
<?php
// Validate GET's CSRF token
session_start(['session.csrf_validation' => SESSION_CSRF_GET]);
// Modify data
?>
</code>

edit.php
<code php>
<?php
// Validate POST's CSRF token
session_start(['session.csrf_validation', SESSION_CSRF_POST]);
// Modify data
?>
</code>


====Added/Extended settings/features====

  - Add hidden internal data structure to session data that stores CSRF token generation key. "<nowiki>__PHP_SESSION__</nowiki>" array is stored in session data, but user cannot see the key from their application.
  - Add **session.csrf_rewrite**(int) INI. Enable CSRF rewrite. (This INI value may be specified as session_start() parameter) Default: session.csrf_rewrite=0. 0: disable, 1: SESSION_CSRF_POST, 2: SESSION_CSRF_GET, 3: SESSION_CSRF_POST|SESSION_CSRF_GET
  - Add **session.csrf_validation**(int) INI. Enable CSRF validation when session.csrf_protection=1. (This INI value may be specified as session_start() parameter) Default: session.csrf_validation=0. 1: SESSION_CSRF_POST, 2: SESSION_CSRF_GET, 3: SESSION_CSRF_POST|SESSION_CSRF_GET
  - Add **session.csrf_ttl**(int - seconds) INI. Controls expiration of CSRF protection token when value is greater than 0. 0 for disabling TTL control. Default: 1800
  - Add **session.csrf_domains**(string) INI. Controls trusted domains default to "". When empty, HTTP_HOST is used. Default: empty
  - Add **session.csrf_error**(int - error level) INI. Controls which error is raised for CSRF token validation error. Default: E_RECOVERABLE_ERROR
  - Extend **session_start()** to support csrf_protection, csrf_ttl, csrf_domains, csrf_error options.
  - Add int **session_csrf_status(void)** function that returns CSRF token validation status. 
    - SESSION_CSRF_DISABLED : CSRF protection is not enabled
    - SESSION_CSRF_INVALID : Invalid request
    - SESSION_CSRF_VALID : Valid request 
  - Add int **session_csrf_validate(int $input_type)** function that validate CSRF token manually.
    - SESSION_CSRF_GET : Check $_GET
    - SESSION_CSRF_POST : Check $_POST. Option may be session_csrf_validate(SESSION_CSRF_GET|SESSION_CSRF_POST).
  - Define **SESSCSRF** constant when CSRF rewrite is enabled.

===Behaviors===

==Page Generation==
  - Generate random CSRF token key (csrf_token_key) if it does not exist in <nowiki>__PHP_SESSION__</nowiki> array.
  - Compute CSRF protection token. \\ SESSCSRF (CSRF protection token value) = time()+session.csrf_ttl ."-". sha1(time()+session.csrf_ttl . csrf_token_key). 
  - Set SESSCSRF as URL rewrite var. (This results URLs/forms have SESSCSRF=token_value in the page)


==Obtaining CSRF token manually==
JS apps may need to obtain CSRF token manually.

get_csrf_token.php
<code php>
<?php
session_start(['csrf_protection'=>SESSION_CSRF_GET]);
// CSRF token is secure because it is generated by using secret random key stored in session data.
echo json_encode(['SESSCSRF'=>SESSCSRF]);
?>
</code>


==Token Validation ==
  - Validation is performed according to session.csrf_validation setting.
  - Split SESSCSRF token value by "-"
    - Check CSRF validation mode (i.e. SESSION_CSRF_POST/GET). 
    - Check TTL value part > time(). If expired, raise error.
    - Check CSRF token part === sha1(ttl_value . csrf_token_key). If does not match, raise error.
  - If error is not raised, CSRF protection status can be verified by session_csrf_status() manually.


====Limitations====

  * Since users may enable/disable CSRF protection, pages that accept requests must enable CSRF protection. Otherwise, protection will not work. i.e. This feature is not fool proof.
  * Since CSRF protections adds CSRF protection token to all applicable URLs, pages that have both private URL and public URL cannot use automatic CSRF protection.
  * CSRF token in URLs has the same risk as Trans SID. (Not recommended)

===== Q & A =====

==Why PHP should have this?==
Simplicity and Security. If application requires POST protection only, 2 INI settings is good enough to protect whole application.

There are many existing applications that could be protected with 2 INI settings.

==How to use with JS applications?==
If there is no pages, you may use PHP script (get_csrf_token.php) mentioned above. Be Careful for TTL, but don't get new token always. It's waste of resources.

==get_csrf_token.php seems insecure==
It's secure. Random CSRF token generation key is stored in session data which is private to users. CSRF token is generated by using the secret key. Therefore, attacker cannot get CSRF token unless they have stolen session already.

==Should all applications use this CSRF protection?==
No. It works for large/complex applications, but one can use their own implementation.



===== Backward Incompatible Changes =====

  * SESSCSRF may be used by users already

===== Proposed PHP Version(s) =====

  * PHP 7.1

===== RFC Impact =====
==== New Constants ====

  * Session module may define constant for CSRF protection token for manual protection. i.e. For pages have both private/public URLs. (There is SID constant for session ID. Any good name for this?)

  * session_csrf_status() function return value constants.


==== php.ini Defaults ====

TBD

If there are any php.ini settings then list:
  * hardcoded default values
  * php.ini-development values
  * php.ini-production values

===== Open Issues =====

  - sha1 is used because it is available always. It is possible to store which hash function is used in CSRF protection token.
  - How it works is subject to be changed. Please comment.
  - URL rewriter must be fixed before this RFC. (It has a issue. Patch exists, not applied yet)

===== Unaffected PHP Functionality =====

  * This RFC does not affect how session ID is managed.
  * If there is CSRF protection module, this proposal works as long as SESSCSRF is not used in GET/POST.

===== Future Scope =====



===== Proposed Voting Choices =====
Include these so readers know where you are heading and can discuss the proposed voting options.

State whether this project requires a 2/3 or 50%+1 majority (see [[voting]])

===== Patches and Tests =====

TBD

===== Implementation =====
After the project is implemented, this section should contain 
  - the version(s) it was merged to
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature

===== References =====
Links to external references, discussions or RFCs

===== Rejected Features =====
Keep this updated with features that were discussed on the mail lists.