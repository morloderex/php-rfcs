====== PHP RFC: Semi-Automatic CSRF Protection ======
  * Version: 0.1
  * Date: 2016-05-10
  * Author: Yasuo Ohgaki <yohgaki@php.net>
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/automatic_csrf_protection


===== Introduction =====
CSRF ([[https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)|Cross Site Request Forgery]]) has been major vulnerability for PHP applications. CSRF protection is not difficult to implement especially with good web application frameworks. However, CSRF protection requires many lines of code if users have to implement by themselves. This proposal extends session module to provide optional automatic/manual CSRF protection for PHP web applications.

Session module has URL rewriter. It is used only for Trans SID (Transparent Session ID) for session management without cookie. URL rewriter can be extended to add CSRF protection token.

===== Proposal =====

====TL;DR;====

This RFC allows:

  * **Web applications can be protected from CSRF attacks easily**, if CSRF protection is required only for POST requests from web forms.
  * For more complex CSRF protections, developers may use CSRF token and validation manually.

Session module is extended to manage CSRF validation. When CSRF protection is enabled, CSRF attack is prevented by session_start(). Execution is terminated by default, but developers may suppress error and detect CSRF attack by themselves via session_csrf_status(). Validation can be done by developers also via  session_csrf_validate(). CSRF protection token is generated by random secret key stored in session data and specified TTL value. Stolen CSRF protection token only allows attacks for specific period upto TTL. 

Textbook web forms like

<code html>
<form action="http://example.com/edit.php" method="POST">
<textarea name="comment"></textarea>
<input type="submit" />
</code>

can be protected by one line

<code php>
<?php session_start(['csrf_rewrite'=>SESSION_CSRF_POST, 'csrf_validate'=SESSION_CSRF_POST]); ?>
</code>

How many CSRF vulnerabilities exist in PHP applications? Use of this CSRF protection is simple and easy. This RFC would help huge number of PHP applications.

====Example - Automatic site wide CSRF protection via POST ====

<code php>
<?php session_start('csrf_rewrite'=>SESSION_CSRF_POST, 'csrf_validate'=>SESSION_CSRF_POST); ?>
</code>

All post pages that use PHP session are protected. If application modify data only by POST, above session_start() is enough for POST CSRF protection. Developers can catch E_RECOVERABLE_ERROR by set_error_handler() callback and handle them.

NOTE: Browsers cannot send POST request directly. i.e. It must display "form" before submit. Forms will have CSRF token by URL rewriter always. Therefore, POST requests have CSRF token always. 

====Example - Manual CSRF protection ====

Manually embedding tokens and validation codes is mistakable, but it is supported.

To protect CSRF from manually, user can
  * Disable automatic rewrites. e.g. session_start(['csrf_rewrite'=>SESSION_CSRF_NONE]);
  * Disable automatic validation. e.g. session_start(['csrf_validate'=>SESSION_CSRF_NONE]); 
then, user can add token manually
<code php>
// GET
<a href="http://example.com/delete.php?id=1234&SESSCSRF=<?php echo SESSCSRF;?>">Delete ID:1234</a>
// POST - put this inside form tag
<input type="hidden" name="SESSCSRF" value="<?php echo SESSCSRF;?>" />
</code>
then, validate manually
<code php>
session_start(['csrf_validate'=>SESSION_CSRF_NONE]);
// This is POST. Use SESSION_CSRF_GET for GET
if (session_csrf_validate(SESSION_CSRF_POST) !== SESSION_CSRF_VALID) {
  die('Invalid request');
}
</code>

Followings are example for manual protection.

Entry page.
<code php>
<?php
// Disable automatic rewrite and validation explicitly - they are disabled by default
session_start(['csrf_rewrite'=>SESSION_CSRF_NONE, 'csrf_validate'=SESSION_CSRF_NONE]);
?>
<html>
<head></head>
<body>
<a href="http://example.com/delete.php?id=1234&SESSCSRF=<?php echo SESSCSRF;?>">Delete ID:1234</a>

<a href="http://example.com/show.php?id=1234">Show ID:1234</a>

<form action="http://example.com/edit.php" method="POST">
<textarea name="comment"></textarea>
<input type="hidden" name="SESSCSRF" value="<?php echo SESSCSRF;?>" />
<input type="submit" />
</form>

</body>
</html>
</code>

Output to browser will be something like

<code html>
<html>
<head></head>
<body>
<a href="http://example.com/delete.php?id=1234&SESSCSRF=1462920523-5fd057a6ff9dc7a124fa5c814765a498e5aa024a">Remove ID:1234</a>

<a href="http://example.com/show.php?id=1234">Show ID:1234</a>

<form action="http://example.com/edit.php" method="POST">
<textarea name="comment"></textarea>
<input type="hidden" name="SESSCSRF" value="1462920523-5fd057a6ff9dc7a124fa5c814765a498e5aa024a" />
<input type="submit" />
</form>

</body>
</html>
</code>

delete.php
<code php>
<?php
// Disable automatic rewrite and validation explicitly - they are disabled by default
session_start(['csrf_rewrite'=>SESSION_CSRF_NONE, 'csrf_validate'=SESSION_CSRF_NONE]);
if (session_csrf_validate(SESSION_CSRF_GET) !== SESSION_CSRF_VALID) {
  die('CSRF Attack or expired CSRF token');
}
// Delete data
?>
</code>

show.php
<code php>
<?php
// Disable automatic rewrite and validation explicitly - they are disabled by default
session_start(['csrf_rewrite'=>SESSION_CSRF_NONE, 'csrf_validate'=SESSION_CSRF_NONE]);
// No CSRF validation token for this
// Show data
?>
</code>

edit.php
<code php>
<?php
// Disable automatic rewrite and validation explicitly - they are disabled by default
session_start(['csrf_rewrite'=>SESSION_CSRF_NONE, 'csrf_validate'=SESSION_CSRF_NONE]);
if (session_csrf_validate(SESSION_CSRF_POST) !== SESSION_CSRF_VALID) {
  die('CSRF Attack or expired CSRF token');
}
// Modify data
?>
</code>

====Example - Automatic rewrite and validation ====

==GET rewrite==

<code php>
session_start(['csrf_rewrite'=>SESSION_CSRF_GET]);
</code>

This rewrites

<code html>
<a href="http://example.com/delete.php?id=1234">Remove ID:1234</a>
</code>

to 

<code html>
<a href="http://example.com/delete.php?id=1234&SESSCSRF=1462920523-5fd057a6ff9dc7a124fa5c814765a498e5aa024a">Remove ID:1234</a>
</code>

==POST rewrite==

<code php>
session_start(['csrf_rewrite'=>SESSION_CSRF_POST]);
</code>

This rewrites

<code html>
<form action="http://example.com/edit.php" method="POST">
<textarea name="comment"></textarea>
<input type="submit" />
</form>
</code>

to 

<code html>
<form action="http://example.com/edit.php" method="POST">
<textarea name="comment"></textarea>
<input type="hidden" name="SESSCSRF" value="1462920523-5fd057a6ff9dc7a124fa5c814765a498e5aa024a" />
<input type="submit" />
</form>
</code>

==CSRF Token Validation==

Validate GET request.
<code php>
session_start(['csrf_validate'=>SESSION_CSRF_GET]);
</code>

Validate POST request.
<code php>
session_start(['csrf_validate'=>SESSION_CSRF_POST]);
</code>

Validate GET and POST request.
<code php>
session_start(['csrf_validate'=>SESSION_CSRF_GET|SESSION_CSRF_POST]);
</code>


====Added/Extended settings/features====

  - Add hidden internal data structure to session data that stores CSRF token generation key. \\ "<nowiki>__PHP_SESSION__</nowiki>" array is stored in session data, but user cannot see the key from their application.
  - Add **session.csrf_rewrite**(int) INI. \\ Enable CSRF rewrite. (This INI value may be specified as session_start() parameter) Default: session.csrf_rewrite=0. 0: disable, 1: SESSION_CSRF_POST, 2: SESSION_CSRF_GET, 3: SESSION_CSRF_POST|SESSION_CSRF_GET
  - Add **session.csrf_validate**(int) INI. \\ Enable CSRF validation when session.csrf_protection=1. (This INI value may be specified as session_start() parameter) Default: session.csrf_validate=0. 1: SESSION_CSRF_POST, 2: SESSION_CSRF_GET, 3: SESSION_CSRF_POST|SESSION_CSRF_GET
  - Add **session.csrf_ttl**(int - seconds) INI. \\ Controls expiration of CSRF protection token when value is greater than 0. 0 for disabling TTL control. Default: 1800
  - Add **session.csrf_domains**(string) INI. \\ Controls trusted domains default to "". When empty, HTTP_HOST is used. Default: empty
  - Add **session.csrf_error**(int - error level) INI. \\ Controls which error is raised for CSRF token validation error. Default: E_RECOVERABLE_ERROR
  - Extend **session_start()** \\ Support csrf_rewrite, csrf_validate, csrf_ttl, csrf_domains, csrf_error options.
  - Add int **session_csrf_status(void)** function \\ It returns CSRF token validation status. 
    - SESSION_CSRF_DISABLED : CSRF protection is not enabled
    - SESSION_CSRF_INVALID : Invalid request
    - SESSION_CSRF_EXPIRED : CSRF token expired
    - SESSION_CSRF_VALID : Valid request 
  - Add int **session_csrf_validate(int $input_to_validate)** function \\ It validates CSRF token manually.
    - SESSION_CSRF_NONE : No validation
    - SESSION_CSRF_GET : Check $_GET
    - SESSION_CSRF_POST : Check $_POST. Option may be session_csrf_validate(SESSION_CSRF_GET|SESSION_CSRF_POST).
  - Define **SESSCSRF** constant when CSRF rewrite is enabled.


====Behaviors====

==Page Generation==
  - Generate random CSRF token key (csrf_token_key) if it does not exist in <nowiki>__PHP_SESSION__</nowiki> array.
  - Compute CSRF protection token. \\ SESSCSRF (CSRF protection token value) = time()+session.csrf_ttl ."-". sha1(time()+session.csrf_ttl . csrf_token_key). 
  - Set SESSCSRF as URL rewrite var. (This results URLs/forms have SESSCSRF=token_value in the page)


==Obtaining CSRF token manually==
JS apps may need to obtain CSRF token manually.

get_csrf_token.php
<code php>
<?php
header("Content-Type: application/json; charset=utf-8");
session_start(['csrf_protection'=>SESSION_CSRF_GET]);
// CSRF token is secure because it is generated by using secret random key stored in session data.
echo json_encode(['SESSCSRF'=>SESSCSRF]);
?>
</code>


==Token Validation ==
  - Validation is performed according to session.csrf_validate setting.
  - Split SESSCSRF token value by "-"
    - Check CSRF validation mode (i.e. SESSION_CSRF_POST/GET). 
    - Check TTL value part > time(). If expired, raise error.
    - Check CSRF token part === sha1(ttl_value . csrf_token_key). If does not match, raise error.
  - If error is not raised, CSRF protection status can be verified by session_csrf_status() manually.


====Limitations====

  * Since users may enable/disable CSRF protection, pages that accept requests must enable CSRF protection. Otherwise, protection will not work. i.e. This feature is not fool proof.
  * Since CSRF protections adds CSRF protection token to all applicable URLs, pages that have both private URL and public URL cannot use automatic CSRF protection.
  * CSRF token in URLs has the same risk as Trans SID. (CSRF token in URL is not recommended)

===== Q & A =====

==Why PHP should have this?==
Simplicity and Security. 

If application requires POST CSRF protection only, 2 INI settings is good enough to protect whole application. No code modification is required. There are many existing applications that could be protected by this.

This implementation is more secure than most CSRF protection implementations because it has TTL. CSRF token is only valid specified time and token value changes according to TTL. This implementation is much secure than session lifetime CSRF token.

Implementation (patch for this RFC) is simple and straightforward also.


==How to use with JS applications?==
If there is no pages, you may use PHP script (get_csrf_token.php) mentioned above. Be Careful for TTL, but don't get new token always. It's waste of resources.

==get_csrf_token.php seems insecure==
It's secure. Random CSRF token generation key is stored in session data which is private to users. CSRF token is generated by using the secret key. Therefore, attacker cannot get CSRF token unless they have stolen session already.

==Should all applications use this CSRF protection?==
No. It works for large/complex applications, but one can use their own implementation.

For instance, I have CSRF lib that detects both CSRF attack and multiple submits. Session module will never support multiple submit detection.



===== Backward Incompatible Changes =====

  * SESSCSRF may be used by users already

===== Proposed PHP Version(s) =====

  * PHP 7.1

===== RFC Impact =====
==== New Constants ====

  * Validation status
    * SESSION_CSRF_DISABLED
    * SESSION_CSRF_INVALID
    * SESSION_CSRF_EXPIRED
    * SESSION_CSRF_VALID


  * Protection Type 
    * SESSION_CSRF_NONE
    * SESSION_CSRF_GET
    * SESSION_CSRF_POST

  * CSRF Token Value
    * SESSCSRF

==== php.ini Defaults ====

  * hardcoded default values
  * php.ini-development values
  * php.ini-production values

All defaults are the same

  * session.csrf_rewrite = SESSION_CSRF_NONE (0)
  * session.csrf_validate = SESSION_CSRF_NONE (0)
  * session.csrf_ttl = 1800 (seconds)
  * session.csrf_domains = ""
  * session.csrf_error = E_RECOVERABLE_ERROR

===== Open Issues =====

  - SHA1 is used because it is available always. SHA256 or any hash could be used. It is possible to store which hash function is used in CSRF protection token. Please request if you feel it is required.
  - Any names (functions/constants/etc) are subject to be changed. Please comment.
  - How it works is subject to be changed. Please comment.
  - URL rewriter must be fixed before this RFC. (It has a issue. Patch exists, not applied yet)

===== Unaffected PHP Functionality =====

  * This RFC does not affect how session ID is managed.
  * If there is CSRF protection module, this proposal works as long as SESSCSRF is not used in GET/POST.

===== Future Scope =====



===== Proposed Voting Choices =====
Include these so readers know where you are heading and can discuss the proposed voting options.

State whether this project requires a 2/3 or 50%+1 majority (see [[voting]])

===== Patches and Tests =====

TBD

===== Implementation =====
After the project is implemented, this section should contain 
  - the version(s) it was merged to
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature

===== References =====
Links to external references, discussions or RFCs

===== Rejected Features =====
Keep this updated with features that were discussed on the mail lists.