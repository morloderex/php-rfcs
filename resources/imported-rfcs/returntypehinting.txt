
====== PHP RFC: Return Type-hinting ======
  * Version: 0.1
  * Date: 2014-03-20 
  * Author: Levi Morrison <levim@php.net>
  * Status: Draft
  * First Published at: https://wiki.php.net/rfc/returntypehinting

===== Introduction =====
Many developers would like to be able to declare the type of a return value. The basic idea has been proposed in at least three RFCs and has had a few other discussions (see [[#references]]).

Return type-hinting has several motivators and use-cases:
  * Preventing unintended return types
  * Providing return types on interface implementations((See [[#variance-and-signature-validation|Variance and Signature Validation]] and [[#examples]] for more details on how this works)).
  * Documenting return type information that is not easily invalidated (unlike comments).

//Providing a return type is optional.// This is important so that it does not introduce a backward compatibility break and so that it doesn't force users to use return types if they don't want to. 

===== Proposal =====
This proposal adds an optional return type-hint to all types of function declarations including closures, functions, interface method declarations and class declarations.

Example of ''function_declaration_stmt'':

  "function" ["&"] T_STRING "(" parameter_list ")" [":"  (T_STRING | array | callable)] "{"
      inner_statement_list
  "}"

==== Variance and Signature Validation ====
The enforcement of the type-hint during inheritance will be covariant. Covariant return types is considered to be type sound and is used in many other languages((C++, Java and others use covariant return types, just as is proposed here.)). The covariance allows an overrider to declare a return type that is a subclass of the original return type; this is illustrated in the [[#examples]] below.

If a mismatch is detected during compile time (eg a class improperly overriding a return type) then ''E_COMPILE_ERROR'' will be issued. If a type mismatch is detected when the function returns then ''E_RECOVERABLE_ERROR'' will be issued.

A class or interface may add a return type to an inherited method where one did not originally exist. This is show in the examples section in the Iterator example.

==== Position of Type-hint ====
The two major conventions in other programming languages for placing return type information are:

  * Before the function name: <php><return_type> name(){}</php>
  * After the parameter list: <php>name() <return_type> {}</php>

The former position has been proposed in the past and the RFCs were either declined or withdrawn. One cited issue is that many developers wanted to preserve the ability to search for <php>function foo</php> to be able to find the definition for ''foo''.

The latter position is used in some functional languages((Facebook's Hack language also declared their return types after the parameter list.)). Declaring the return type after the parameter list will have no known conflicts in the parser.

==== Examples ====
Here are some examples of valid and invalid uses.

=== Examples of Valid Use ===
<PHP>
// Covariant return-type:

interface Collection {
    function map(callable $fn): Collection;
}

interface Set extends Collection {
    function map(callable $fn): Set;
}
</PHP>
<PHP>
// Overriding a method that did not have a return type:

interface Iterator {
    function rewind();
    function valid();
    function key();
    function current();
    function next();
}

class CommentsIterator implements Iterator {
    function current() : Comment;
}
</PHP>

=== Examples of Invalid Use ===
<PHP>
// return type does not match type-hint
function get_config(): array {
    return null;
}
</PHP>
<PHP>
// invalid type-hint
function answer(): int {
    return 42;
}
</PHP>
<PHP>
// Missing return type on override:

interface UserGateway {
    function find($id) : User; 
}

class UserGateway_MySql implements UserGateway {
    function find($id); // must return User or subtype of User
}
</PHP>
<PHP>
// Defining a return type on a Generator
function filter(Traversable $in, callable $filter): array {
    foreach ($in as $key => $value) {
        yield $filter($key, $value);
    }
} 
</PHP>

==== Multiple Return Types ====
This proposal specifically does not allow multiple return type-hints; if such a feature is needed by a user then using PHP's existing dynamic nature is the best way to handle this need.

==== Differences from Past RFCs ====
This proposal differs from past RFCs in several key ways:

  * **We keep the current type-hint options.** Past proposals have suggested new types such as ''void'', ''int'', ''string'' or ''scalar''.
  * **We allow type-hints on all function types**((Except [[#generators]])). Will Fitch's proposal suggested adding it for methods only.
  * **We keep the current search patterns.** You can still search for <php>function foo</php> to find <php>foo</php>'s definition; all previous RFCs broke this.
  * **We do not modify or add keywords.** Past RFCs have proposed new keywords such as ''nullable'' and more. We still require the <php>function</php> keyword.


===== Open Issues =====

==== Allowing NULL for Objects ====
Consider the following function: 

<PHP>
function foo() : DateTime { 
    return null; 
}
</PHP>

It declares that it will return ''DateTime'' but returns <php>null</php>. In type-hints for parameters this would fail unless <php> = null</php> was appended to the end. It is a common pattern to return <php>null</php> to indicate that there is no result for something that normally returns an object.

We can introduce some syntax to allow <php>null</php> to be passed.

One proposal is to use <php>|</php>
<PHP>
function foo() : DateTime|null { 
    return null; 
}
</PHP>
I personally feel that this gives the impression that we allow multiple return types. This proposal explicitly [[#multiple-return-types|does not allow multiple return types]].

Another option is to use Hack's syntax:
<PHP>
function foo() : ?DateTime { 
    return null; 
}
</PHP>

Another option is to use a C# inspired syntax:
<PHP>
function foo() : DateTime? { 
    return null; 
}
</PHP>

We could choose to delay this decision to a later date; not allowing <php>null</php> would be future-compatible with such a decision.

==== Generators ====
According to Nikita Popov, generators have a concept of a return value that may be exposed at some future point. His recommendation is to not allow return types on generators as they may conflict with future work in this area. If type-hinting on generators were to work the same way it does on other functions then the only valid return type would be <php>Generator</php>; therefore not allowing return types on generators is not a loss at all.

===== Other Impact =====

==== On Backward Compatiblity ====
This RFC is backwards compatible with previous PHP releases.

==== On SAPIs ====
There is no impact on any SAPI.

==== On Existing Extensions =====
There is no known impact on extensions.

==== On Performance ====
Until a patch is completed (Joe Watkins has offered to provide one) the impact on performance is unknown.

===== Proposed PHP Version(s) =====
As there are no known BC breaks this RFC targets PHP 5.7. If a BC break is discovered it will be proposed for PHP 6.0.

===== Proposed Voting Choices =====
This RFC modifies the PHP language syntax and therefore requires a two-third majority of votes.

===== Patches and Tests =====
Currently there isn't a patch; Joe Watkins has offered to provide one.

===== References =====
  * [[rfc:typehint|Return value and parameter type hint]] by Felipe; 2008. [[http://marc.info/?l=php-internals&m=120753976214848&w=2|Mail Archive]].
  * [[rfc:returntypehint|Return Type-hint]] by Felipe; 2010. [[http://marc.info/?l=php-internals&m=128036818909738&w=2|Mail Archive]]
  * [[rfc:returntypehint2|Method Return Type-hints]] by Will Fitch; 2011. [[http://marc.info/?t=132443368800001&r=1&w=2|Mail Archive]].

===== Future Work =====
  * Reflection support
  * Consider allowing extensions to define type-hints for return values.