
====== PHP RFC: Return Type Declarations ======
  * Version: 0.1
  * Date: 2014-03-20 
  * Author: Levi Morrison <levim@php.net>
  * Status: Draft
  * First Published at: https://wiki.php.net/rfc/returntypehinting

===== Introduction =====
Many developers would like to be able to declare the return type of a function. The basic idea has been proposed in at least three RFCs and has had a few other discussions (see [[#references]]).

Declaring return types has several motivators and use-cases:
  * Preventing unintended return types
  * Providing return types on interface implementations((See [[#variance-and-signature-validation|Variance and Signature Validation]] and [[#examples]] for more details on how this works)).
  * Documenting return type information that is not easily invalidated (unlike comments).

//Providing a return type is optional.// This is important so that it does not break compatibility with older versions and so that it doesn't force users to use return types if they don't want to. 

===== Proposal =====
This proposal adds an optional return type declaration to most types of function declarations including closures, functions, interface method declarations and class declarations. This RFC does not change the existing type declarations nor does it add new ones (see [[#differences_from_past_rfcs|differences from past RFCs]]).

Example of ''function_declaration_stmt'':

  "function" ["&"] T_STRING "(" parameter_list ")" [":"  (T_STRING | array | callable)] "{"
      inner_statement_list
  "}"

This RFC does not allow declaring return types on Generators. Generators have a concept of return value internally that may be exposed at a later point. Not being able to declare a return type on a generator in this RFC is not really any loss because the only allowed type would be <php>Generator</php> (which is redundant).

==== Variance and Signature Validation ====
The enforcement of the declared return type during inheritance will be covariant. Covariant return types are considered to be type sound and is used in many other languages((C++, Java and others use covariant return types, just as is proposed here.)). The covariance allows an overrider to declare a return type that is a subclass of the original return type; this is illustrated in the [[#examples]] below.

If a mismatch is detected during compile time (eg a class improperly overriding a return type) then ''E_COMPILE_ERROR'' will be issued. If a type mismatch is detected when the function returns then ''E_RECOVERABLE_ERROR'' will be issued.

A class or interface may add a return type to an inherited method where one did not originally exist. This is shown in the examples section in the Iterator example.

==== Position of Type Declaration ====
The two major conventions in other programming languages for placing return type information are:

  * Before the function name: <php>return_type function_name(){}</php>
  * After the parameter list: <php>function_name() return_type {}</php>

The former position has been proposed in the past and the RFCs were either declined or withdrawn. One cited issue is that many developers wanted to preserve the ability to search for <php>function foo</php> to be able to find the definition for ''foo''.

The latter position is used in several languages(([[http://hacklang.org/|Hack]],  [[http://www.haskell.org|Haskell]], and [[http://www.erlang.org/|Erlang]] all put the return type after the parameter list)); it is also used in C++11's lambda declarations when the type cannot be deduced. 

Declaring the return type after the parameter list will have no known conflicts in the parser.

==== Disallowing NULL on Return Types ====
Consider the following function: 

<PHP>
function foo(): DateTime { 
    return null; // invalid
}
</PHP>

It declares that it will return ''DateTime'' but returns <php>null</php>; this type of situation is common in many languages including PHP. By design this RFC does not allow <php>null</php> to be returned in this situation for two reasons:

  - This aligns with current type behavior which does not allow <php>null</php> to be passed, except when a <php>null</php> default is also declared.
  - Allowing <php>null</php> by default works against the purpose of type declarations. By putting constraints on variable types it becomes easier to reason about the surrounding code. By allowing <php>null</php> by default means that the programmer would always have to worry about the <php>null</php> case on return values.

The [[rfc:nullable_typehints|Nullable Type-Hints RFC]] addresses this shortcoming and more.

==== Examples ====
Here are some examples of valid and invalid uses.

=== Examples of Valid Use ===
<PHP>
// Covariant return-type:

interface Collection {
    function map(callable $fn): Collection;
}

interface Set extends Collection {
    function map(callable $fn): Set;
}
</PHP>
<PHP>
// Overriding a method that did not have a return type:

interface Iterator {
    function rewind();
    function valid();
    function key();
    function current();
    function next();
}

class CommentsIterator implements Iterator {
    function current() : Comment;
}
</PHP>

=== Examples of Invalid Use ===

The error messages are taken from the current patch.

----
<PHP>
// Returned type does not match the type declaration

function get_config(): array {
    return 42;
}
</PHP>
''Fatal error: the function get_config was expected to return an array and returned an integer in %s on line %d''

----

<PHP>
// Int is not a valid type declaration

function answer(): int {
    return 42;
}
</PHP>
''Fatal error: the function answer was expected to return an object of class int and returned an integer in %s on line %d''

----

<PHP>
// Cannot return null with a return type declaration

function foo(): bar {
    return null;
}
</PHP>
''Fatal error: the function foo was expected to return an object of class bar and returned null in %s on line %d''

----

<PHP>
// Missing return type on override

class User {}

interface UserGateway {
    function find($id) : User; 
}

class UserGateway_MySql implements UserGateway {
    // must return User or subtype of User
    function find($id) {
        return new User();
    }
}
</PHP>
''Fatal error: Delcaration of UserGateway_MySql::find should be compatible with UserGateway::find($id) : User, return type missing in %s on line %d''

----

<PHP>
// Cannot define a return type on a Generator

function filter(Traversable $in, callable $filter): array {
    foreach ($in as $key => $value) {
        if ($filter($key, $value)) {
            yield $key => $value;
        }
    }
} 
</PHP>
''Fatal error: The "yield" expression can not be used inside a function with a return type hint in %s on line %d''

==== Multiple Return Types ====
This proposal specifically does not allow declaring multiple return types; this is out of the scope of this RFC and would require a separate RFC if desired.

If you want to use multiple return types, simply omit a return type declaration and rely on PHP's excellent dynamic nature.

==== Reflection ====

This proposal includes Reflection support; ''ReflectionFunctionAbstract'' added the following methods:

  - ''hasReturnType'' - returns bool
  - ''getReturnType'' - returns ReflectionClass or string (''array'', ''callable'')

<PHP>
$functions = [
    function() : stdClass {return new stdClass;},
    function() : array { return []; },
    function() : callable { return $this; },
    function() {}
];

foreach ($functions as $function) {
    $reflector = new ReflectionFunction($function);
    var_dump(
        $reflector->hasReturnType(),
        $reflector->getReturnType()
    );
}
</PHP>

<code>
bool(true)
object(ReflectionClass)#6 (1) {
  ["name"]=>
  string(8) "stdClass"
}
bool(true)
string(5) "array"
bool(true)
string(8) "callable"
bool(false)
NULL
</code>

==== Differences from Past RFCs ====
This proposal differs from past RFCs in several key ways:

  * //We keep the current type options.// Past proposals have suggested new types such as ''void'', ''int'', ''string'' or ''scalar''.
  * //We allow return type declarations on all function types//((Except [[#generators]])). Will Fitch's proposal suggested adding it for methods only.
  *//We keep the current search patterns.// You can still search for <php>function foo</php> to find <php>foo</php>'s definition; all previous RFCs broke this.
  * //We do not modify or add keywords.// Past RFCs have proposed new keywords such as ''nullable'' and more. We still require the <php>function</php> keyword.

===== Other Impact =====

==== On Backward Compatiblity ====
This RFC is backwards compatible with previous PHP releases.

==== On SAPIs ====
There is no impact on any SAPI.

==== On Existing Extensions =====
There is no known impact on extensions.

==== On Performance ====
A preliminary patch has been completed by Joe Watkins; the impact on performance is still unknown. Testing will be done before voting phase.

===== Proposed PHP Version(s) =====
As there are no known BC breaks this RFC targets PHP 5.7. If a BC break is discovered it will be proposed for PHP 6.0.

===== Proposed Voting Choices =====
This RFC modifies the PHP language syntax and therefore requires a two-third majority of votes.

===== Patches and Tests =====
Joe Watkins has provided [[https://github.com/krakjoe/php-src/compare/returntypehinting|an implementation]] which includes tests, reflection and opcache support. Any feedback is welcome and appreciated.

===== References =====
  * [[rfc:returntypehint2|Method Return Type-hints]] by Will Fitch; 2011. [[http://marc.info/?t=132443368800001&r=1&w=2|Mail Archive]].
  * [[rfc:returntypehint|Return Type-hint]] by Felipe; 2010. [[http://marc.info/?l=php-internals&m=128036818909738&w=2|Mail Archive]]
  * [[rfc:typehint|Return value and parameter type hint]] by Felipe; 2008. [[http://marc.info/?l=php-internals&m=120753976214848&w=2|Mail Archive]].
  * [[http://derickrethans.nl/files/meeting-notes.html#type-hinted-properties-and-return-values|Type-hinted properties and return values]] from meeting notes in Paris; Nov 2005.

In November 2005 it was decided that PHP should have return type declarations and some suggestions were made for syntax. Suggestion 5 is nearly compatible with this RFC; however, it requires the addition of a token (keyword). To avoid this headache we opted to go for a syntax that does not require additional tokens in the parser.

The following (tiny) patch makes this RFC compatible with suggestion 5 while retaining compatibility with the syntax used for this RFC, but must add the parser token we wanted to avoid "returns":

https://gist.github.com/krakjoe/f54f6ba37e3eeab5f705

===== Related Work =====

Allowing null to be returned in a type hint (such as <php>?DateTime</php>) is discussed in a related RFC: [[rfc:nullable_typehints|Declaring Nullable Types]]
