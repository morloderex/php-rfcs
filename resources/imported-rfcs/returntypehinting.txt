
====== PHP RFC: Return Type Declarations ======
  * Version: 1.3
  * Date: 2014-03-20 
  * Author: Levi Morrison <levim@php.net>
  * Status: Under Discussion
  * First Published at: https://wiki.php.net/rfc/returntypehinting

===== Introduction =====
Many developers would like to be able to declare the return type of a function. The basic idea of declaring a return type has been included in at least three RFCs and has been discussed in a few other places (see [[#references]]). This RFC proposes a different approach from previous RFC's to accomplish this goal in a simple way.

Declaring return types has several motivators and use-cases:
  * Providing return types on interface implementations((See [[#variance-and-signature-validation|Variance and Signature Validation]] and [[#examples]] for more details on how this works)).
  * Preventing sub-classes to break your return type
  * Preventing unintended return types
  * Documenting return type information that is not easily invalidated (unlike comments).

===== Proposal =====
This proposal adds an optional return type declaration to function declarations including closures, functions, generators, interface method declarations and class declarations. This RFC does not change the existing type declarations nor does it add new ones (see [[#differences_from_past_rfcs|differences from past RFCs]]).

Example of ''function_declaration_stmt'':

  "function" ["&"] T_STRING "(" parameter_list ")" [":"  (T_STRING | array | callable)] "{"
      inner_statement_list
  "}"

Here is a brief example of the syntax in action:
<PHP>
function foo(): array {
    return [];
}
</PHP>
More examples can be found in the [[#examples|Examples]] section.

//Code which does not declare a return type 
 continue to work// exactly as it currently does. This RFC requires a return type to be declared only when a method inherits from a parent method that declares a return type; in all other cases it may be omitted.

==== Variance and Signature Validation ====
The enforcement of the declared return type during inheritance is covariant; this allows an over-riding method to declare a return type that is a sub-type of the original (illustrated in [[#examples]]). This notably allows a class or interface to add a return type to an inherited method where one did not exist in the parent (also shown in examples).

If a mismatch is detected during compile time (e.g. a class improperly overriding a return type) then ''E_COMPILE_ERROR'' will be issued. If a type mismatch is detected when the function returns then ''E_RECOVERABLE_ERROR'' will be issued.

Covariant return types are considered to be type sound and are used in many other languages((C++, Java and others use covariant return types, just as is proposed here.)).

==== Position of Type Declaration ====
The two major conventions in other programming languages for placing return type information are:

  * Before the function name
  * After the parameter list's closing parenthesis

The former position has been proposed in the past and the RFCs were either declined or withdrawn. One cited issue is that many developers wanted to preserve the ability to search for <php>function foo</php> to be able to find the definition for ''foo''. A recent discussion about [[http://marc.info/?t=141235344900003&r=1&w=2|removing the function keyword]] has several comments that re-emphasized the value in preserving this.

The latter position is used in several languages(([[http://hacklang.org/|Hack]],  [[http://www.haskell.org|Haskell]], [[https://golang.org/|Go]], [[http://www.erlang.org/|Erlang]], [[http://www.adobe.com/devnet/actionscript.html|ActionScript]], [[http://www.typescriptlang.org/|TypeScript]] and more all put the return type after the parameter list)); notably C++11 also places the return type after the parameter lists for certain constructs such as lambdas and auto-deducing return types.

Declaring the return type after the parameter list had no shift/reduce conflicts in the parser.

==== Returning by Reference ====

This RFC does not change the location of ''&'' when returning by reference. The following examples are valid:
<PHP>
function &array_sort(array &$data) {
    return $data;
}

function &array_sort(array &$data): array {
    return $data;
}
</PHP>

==== Disallowing NULL on Return Types ====
Consider the following function: 

<PHP>
function foo(): DateTime { 
    return null; // invalid
}
</PHP>

It declares that it will return ''DateTime'' but returns ''null''; this type of situation is common in many languages including PHP. By design this RFC does not allow ''null'' to be returned in this situation for two reasons:

  - This aligns with current parameter type behavior. When parameters have a type declared, a value of ''null'' is not allowed ((Except when the parameter has a ''null'' default)).
  - Allowing ''null'' by default works against the purpose of type declarations. Type declarations make it easier to reason about the surrounding code. If ''null'' was allowed the programmer would always have to worry about the ''null'' case.

The [[rfc:nullable_typehints|Nullable Types RFC]] addresses this shortcoming and more.

==== Methods which cannot declare return types ====

Class constructors, destructors and clone methods may not declare return types. Their respective error messages are:

  * ''<nowiki>Fatal error: Constructor %s::%s() cannot declare a return type in %s on line %s</nowiki>''
  * ''<nowiki>Fatal error: Destructor %s::__destruct() cannot declare a return type in %s on line %s</nowiki>''
  * ''<nowiki>Fatal error: %s::__clone() cannot declare a return type in %s on line %s</nowiki>''

==== Examples ====
Here are some snippets of both valid and invalid usage.

=== Examples of Valid Use ===
<PHP>
// Covariant return-type:

interface Collection {
    function map(callable $fn): Collection;
}

interface Set extends Collection {
    function map(callable $fn): Set;
}
</PHP>
<PHP>
// Overriding a method that did not have a return type:
interface Comment {}
interface CommentsIterator extends Iterator {
    function current(): Comment;
}
</PHP>
<PHP>
// Using a generator:

interface Collection extends IteratorAggregate {
    function getIterator(): Iterator;
}

class SomeCollection implements Collection {
    function getIterator(): Iterator {
        foreach ($this->data as $key => $value) {
            yield $key => $value;
        }
    }
}
</PHP>

=== Examples of Invalid Use ===

The error messages are taken from the current patch.

----
<PHP>
// Returned type does not match the type declaration

function get_config(): array {
    return 42;
}
get_config();
</PHP>
''Catchable fatal error: The function get_config was expected to return an array and returned an integer in %s on line %d''

----

<PHP>
// Int is not a valid type declaration

function answer(): int {
    return 42;
}
answer();
</PHP>
''Catchable fatal error: The function answer was expected to return an object of class int and returned an integer in %s on line %d''

----

<PHP>
// Cannot return null with a return type declaration

function foo(): DateTime {
    return null;
}
foo();
</PHP>
''Catchable fatal error: The function foo was expected to return an object of class DateTime and returned null in %s on line %d''

----

<PHP>
// Missing return type on override

class User {}

interface UserGateway {
    function find($id): User; 
}

class UserGateway_MySql implements UserGateway {
    // must return User or subtype of User
    function find($id) {
        return new User();
    }
}
</PHP>
''Fatal error: Declaration of UserGateway_MySql::find should be compatible with UserGateway::find($id): User, return type missing in %s on line %d''

----

<PHP>
// Generator return types can only be declared as Generator, Iterator or Traversable (compile time check)

function foo(): array {
    yield [];
}
</PHP>
''Fatal error: Generators may only declare a return type of Generator, Iterator or Traversable, %s is not permitted in %s on line %d''


==== Multiple Return Types ====
This proposal specifically does not allow declaring multiple return types; this is out of the scope of this RFC and would require a separate RFC if desired.

If you want to use multiple return types, simply omit a return type declaration and rely on PHP's excellent dynamic nature.

==== Reflection ====

A new ''ReflectionType'' class has been added (described below).

The following two methods have been added to ''ReflectionFunctionAbstract'':

  - ''hasReturnType()'' - returns ''bool''
  - ''getReturnType()'' - returns ''ReflectionType''

Note that ''getReturnType'' will always return a ''ReflectionType'' object, even if there is no return type declared. In this case, ''ReflectionType::getKind()'' will return ''ReflectionType::IS_UNDECLARED''.

=== ReflectionType ===
<PHP>
class ReflectionType implements Reflector {
    const IS_UNDECLARED = 0;
    const IS_ARRAY;    /* You may not rely on the value of IS_ARRAY */
    const IS_CALLABLE; /* You may not rely on the value of IS_CALLABLE */
    const IS_OBJECT;   /* You may not rely on the value of IS_OBJECT */

    public function getKind(); /* returns one of the ReflectionType::IS_* constants */
    public function getName(); /* returns the string version of the type */
    public function __toString(); /* returns the string version of the type */
}
</PHP>


This API was designed so you could use ''ReflectionType::getKind()'' in a switch statement to cover all cases, rather than be forced to use a nested if/else structure that calls ''isArray()'', ''isCallable'', etc like the ''ReflectionParameter'' API does. Compare these two examples:

<PHP>
// If ReflectionType mirrored ReflectionParameter's API
$ReflectionType = /* ... */;

if ($ReflectionType !== false) {
    if ($ReflectionType->isArray()) {
        // ...
    } elseif ($ReflectionType->isCallable()) {
        // ...
    } elseif ($ReflectionType->getClass() !== null) {
        // ...
    } else {
        // handle unknown type (future compatibility)
    }
} else {
    // ...
}
</PHP>
<PHP>
// The proposed API:
$ReflectionType = /* ... */;

switch ($ReflectionType->getKind()) {
    case ReflectionType::IS_ARRAY:
        // ...
        break;
    case ReflectionType::IS_CALLABLE:
        // ...
        break;
    case ReflectionType::IS_OBJECT:
        // ...
        break;
    case ReflectionType::IS_UNDECLARED:
        // ...
        break;
    default:
        // handle unknown type (future compatibility)
        break;
}
</PHP>

Additionally, if you have a ''ReflectionType'' API that matches ''ReflectionParameter'', to see if there is no type provided you must do:

<PHP>
$ReflectionType = /* ... */;

if (!$ReflectionType->isArray() && !$ReflectionType->isCallable() && $ReflectionType->getClass() === null) {
    // no type provided
}
</PHP>

Compared to the proposed API:
<PHP>
$ReflectionType = /* ... */;

if ($ReflectionType->getKind() == ReflectionType::IS_UNDECLARED) {
    // no type provided
}
</PHP>

Note that this RFC does not alter ''ReflectionParameter'' in any way; for now ''ReflectionType'' is only used by return type information but was designed so that it could be reused for other type information in the future.

==== Differences from Past RFCs ====
This proposal differs from past RFCs in several key ways:

  * **The return type is positioned after the parameter list.** See [[#position_of_type_declaration|Position of Type Declaration]] for more information about this decision.
  * **We keep the current type options.** Past proposals have suggested new types such as ''void'', ''int'', ''string'' or ''scalar''; this RFC does not include any new types. Note that it does allow ''self'' and ''parent'' to be used as return types.
  * **We keep the current search patterns.** You can still search for <php>function foo</php> to find <php>foo</php>'s definition; all previous RFCs broke this common workflow.
  * **We allow return type declarations on all function types**. Will Fitch's proposal suggested that we allow it for methods only.
  * **We do not modify or add keywords.** Past RFCs have proposed new keywords such as ''nullable'' and more. We still require the <php>function</php> keyword.

===== Other Impact =====

==== On Backward Compatiblity ====
This RFC is backwards compatible with previous PHP releases.

==== On SAPIs ====
There is no impact on any SAPI.

==== On Existing Extensions =====
The structs ''zend_function'' and ''zend_op_array'' have been changed; extensions that work directly with these structs may be impacted.

==== On Performance ====
An informal test indicates that performance has not seriously degraded. More formal performance testing can be done before voting phase.

===== Proposed PHP Version(s) =====
This RFC targets PHP 7.

===== Proposed Voting Choices =====
This RFC modifies the PHP language syntax and therefore requires a two-third majority of votes.

===== Patches and Tests =====
Joe Watkins provided [[https://github.com/krakjoe/php-src/compare/returntypehinting|an implementation based on the PHP 5.x series]] which includes tests, reflection and opcache support; it's pull request is here: https://github.com/php/php-src/pull/653

Levi Morrison has provided a [[https://github.com/php/php-src/pull/820|pull request]] that needs some work before being merged, but is a fully-working implementation with tests.

===== Future Work =====
Ideas for future work which are out of the scope of this RFC include:

  * Allowing functions to declare that they do not return anything at all (''void'')
  * Allowing nullable types(such as <php>?DateTime</php>). This is discussed in a related RFC: [[rfc:nullable_typehints|Declaring Nullable Types]]
  * Unifying the reflection type API by having ''ReflectionParameter'' use ''ReflectionType''.
  * Improving parameter variance. Currently parameter types are invariant while they could be contravariant.
  * Improving runtime performance by doing type analysis.
  * Updating documentation to use the new return type syntax.

===== References =====
  * [[rfc:returntypehint2|Method Return Type-hints]] by Will Fitch; 2011. [[http://marc.info/?t=132443368800001&r=1&w=2|Mail Archive]].
  * [[rfc:returntypehint|Return Type-hint]] by Felipe; 2010. [[http://marc.info/?l=php-internals&m=128036818909738&w=2|Mail Archive]]
  * [[rfc:typehint|Return value and parameter type hint]] by Felipe; 2008. [[http://marc.info/?l=php-internals&m=120753976214848&w=2|Mail Archive]].
  * [[http://derickrethans.nl/files/meeting-notes.html#type-hinted-properties-and-return-values|Type-hinted properties and return values]] from meeting notes in Paris; Nov 2005.

In the meeting in Paris on November 2005 it was decided that PHP should have return type declarations and some suggestions were made for syntax. Suggestion 5 is nearly compatible with this RFC; however, it requires the addition of a new token ''T_RETURNS''. This RFC opted for a syntax that does not require additional tokens so ''returns'' was replaced by a colon.

The following (tiny) patch would allow the syntax in suggestion 5 to be used alongside the current syntax. This RFC does not propose that both versions of syntax should be used; the patch just shows how similar this RFC is to that suggestion from 2005.

https://gist.github.com/krakjoe/f54f6ba37e3eeab5f705

===== Changelog =====

  * v1.1: RFC now targets PHP 7.
  * v1.2: disallow return types for constructors, destructors and clone methods.
  * v1.3: reworked Reflection support to use new ReflectionType class