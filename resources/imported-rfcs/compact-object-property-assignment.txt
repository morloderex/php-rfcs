====== PHP RFC: Compact Object Property Assignment ======

**COPA: A //pragmatic// approach to object literals**

  * Version: 1.2
  * Date: 2020-03-17
  * Author: Jakob Givoni <jakob@givoni.dk>
  * Status: Under Discussion
  * Discussion: https:%%//%%externals.io/message/109055

===== Introduction =====

==== Summary ====

This RFC proposes a new, compact syntax to assign values to multiple properties on an object in a single expression.

This //**pseudo object literal**// notation, (though not limited to such use) is intended to enable the developer to //**create an object and populating it inline**//, f.ex. directly as an argument in a function call.

As an alternative to writing a data structure as an associative array, COPA gives the data a **//documented signature//** so that you know what parameters are expected and their values.

You may find that COPA is best suited when you don’t mind public properties you don’t require a constructor, since as [[https://wiki.php.net/rfc/write_once_properties#read-only_semantics|the saying goes]]: //Object construction is a fuzzy concept in PHP and lazy initialisation is a feature!//

==== Example ====

Let’s start with an example that demonstrates the essence of COPA.

=== Instead of doing this... ===

<code php>
$myObj = new Foo(); // 1. Create

$myObj->a = 1; // 2. Populate
$myObj->b = 2;
$myObj->c = 3;

doTheFoo($myObj); // 3. Send
</code>
=== You will be able to do this: ===

<code php>
doTheFoo((new Foo)->[
    a = 1,
    b = 2,
    c = 3,
]);
</code>
//See more use cases below - and keep an open mind about the syntax; the options are limited these days :-)//

==== Motivation ====

The purpose of this feature is to lighten the effort of creating, populating and sending data structures, from small to large ones.

The goal was to find a solution that meets the following criteria:

  * **Brief** - only mention the object once (less repetition)
  * **Inline** - object can be created and populated in a single expression (pseudo object literals, nested objects)
  * **Typo-proof** - property names can be autocompleted easily by IDE (faster typing, fewer errors)
  * **Type-checking** - IDE can verify correct type for typed properties and annotated virtual properties
  * **Order-agnostic** - properties can be specified in any order (though note that the order //may// change the result!)
  * **Sparcity** - any property can be “skipped” (“skipped” properties may acquire a default value)
  * **Simple** - does what you would expect without introducing any new concepts into the language

//My focus is to find a **pragmatic** solution that can be implemented soon, but won’t trip up the continuing, inspiring development of the awesome language that is PHP.//

//If you have ever wanted to create, populate and send an object inside a function call, COPA is your chance!//

===== Proposal =====

==== Syntax ====

The proposed syntax consists of the object arrow operator followed by a set of square brackets containing a comma-separated list of assignments in the form of property name equals expression:

<code>
<object-expression> -> [
    `<property-name> = <expression>`,
    [repeat as needed],
]
</code>
A trailing comma is permitted for the same reasons it's permitted in array literals and [[https://wiki.php.net/rfc/trailing-comma-function-calls|function calls (as of PHP 7.3)]].

The whole block is considered an expression that returns the object before the arrow.

This syntax was chosen for its availability in the language. If we land on another syntax, I’m not married to this one. The only criteria are that it doesn’t conflict with anything else, that it is brief and feels good.

==== Interpretation ====

Each comma-separated assignment inside the brackets is executed as an assignment of the named property on the object preceding the block. If the property is defined and publicly accessible, it will simply be set, or possible throw a ''%%TypeError%%''. If there's no property with that name, or if it's protected or private, the magic method ''%%__set%%'' will be called just like you would expect. When used in an expression, **COPA** simply returns the object itself.

If you replace COPA with single line assignments, you will always get the same result, f.ex.:

<code php>
$foo->[
    a = 1,
    b = myfunc(),
    c = $foo->bar(),
];

// The COPA above is identical to
$foo->a = 1;
$foo->b = myfunc();
$foo->c = $foo->bar();
</code>
==== Use cases ====

=== Alternative to passive associative arrays ===

<code php>
// Instead of this:

doSomething([
    'a' => 1, // Array syntax doesn't provide any help on parameter names
    'b' => 2, // or types
]);

// Use COPA:

class Options {
    public $a;
    public $b;
}

doSomething((new Options)->[
    a = 1, // Parameter name and type checking
    b = 2,
]);
</code>
//If you often create, populate and send the same families of data structure, declaring those structures and using COPA makes it a breeze.//

=== DTOs - data transfer objects ===

Typical characteristics of DTOs:

  * many properties
  * properties may be optional, with default values
  * public visibility on properties, i.e. no desire for boilerplate code to create setters and getters for each one
  * desirability to create, populate and send in one go

== With current syntax ==

<code php>
class FooDto {
    public ?string $mane = null;
    public int $padme = 1; // Optional, with default
    public ?FooDto $hum = null;
}

$foo = new FooDto(); // Instantiating the object first
$foo->mane = 'get'; // Setting the properties
// Skipping the $padme property which has a default value
$foo->hum = new FooDto(); // Creating a nested DTO
$foo->hum->mane = 'life'; // Populating the nested DTO

doTheFoo($foo); // Passing it to a function
</code>
== With new COPA syntax ==

<code php>
doTheFoo((new FooDto)->[ // Constructing and populating inline
    mane = 'get',
    hum = (new FooDto)->[ // Even nested structures
        mane = 'life',
    ],
]);
</code>
//Though the example is not a typical DTO, it represents the characteristics.//

=== Argument bags ===

Argument bags are typically used when:

  * many arguments needs to be passed to a function
  * some arguments are optional
  * order of arguments is not important

With the proposed new syntax we can **avoid using simple arrays** and instead get **autocomplete** and **type-checking** in the IDE with a syntax that smells of **named parameters**:

== With current syntax ==

<code php>
class Foo {
    protected string $mane;
    protected int $padme;
    protected string $hum;

    public function __construct(array $options) {
        $this->mane = $options['mane'];
        $this->padme = $options['padme'] ?? 1;
        $this->hum = $options['hum'];
    }
}

$myFoo = new Foo([
    'mane' => 'get', // Array syntax doesn't provide any help on parameter names
    'hum' => 'life', // or types
]);
</code>
== With new COPA syntax ==

<code php>
class FooOptions { // Separate concerns into an options class that handles optional and default values...
    public ?string $mane = null;
    public int $padme = 1; // Optional, with default
    public ?string $hum = null;
}

class Foo { // And the main class that receives the options and handles some feature
    protected FooOptions $options;

    public function __construct(FooOptions $options) {
        // Do some validate here if you must, f.ex. checking for mandatory parameters
        $this->options = $options;
    }
}

$myFoo = new Foo((new FooOptions)->[ // Objects as argument bags (pseudo named parameters?)
    mane = 'get', // Parameter name and type checking
    hum = 'life',
]);
</code>
//The other alternative to an argument bag is usually a constructor with many arguments, which is something that has been attempted to solve with RFCs arguing for automatic promotion of arguments to properties (f.ex. [[https://wiki.php.net/rfc/automatic_property_initialization|RFC: Automatic Property Initialization]], but which is probably also better left to the COPA argument bag example above.//

==== Special cases ====

Clarification of edge-case behavior.

=== Execution order ===

The fact that the assignments are executed in the order they are listed (just as if they had been specified on separate lines), has the following consequence:

<code php>
$myObj->[
    foo = 10,
    bar = $myObj->foo + 20,
];

var_dump($myObj->bar); // int(30)
</code>
//As the assignments are carried out in order on the object, you can use the new value of a previous assigment in a following one.//

//There may be arguments equally for and against this behavior, but ultimately the simplicity of the design and implementation wins, in my opinion.//

=== Exceptions ===

If an expression inside a COPA block throws an exception, the result is the same as if the assignments had been done the old way, f.ex. if we have:

<code php>
class Foo {
    public $a;
    public $b;
    public $c;
}

$foo = new Foo();

function iThrow() {
    throw new \Exception();
}
</code>
Then the following examples behave identically:

<code php>
// With COPA
try {
    $foo->[
        a = 'a',
        b = iThrow(),
        c = 'c',
    ];
} catch (\Throwable $e) {
    var_dump($foo);
}

</code>
<code php>
// Without COPA
try {
    $foo->setA('a')
        ->setB(iThrow())
        ->setC('c');
} catch (\Throwable $e) {
    var_dump($foo);
}

// OR

try {
    $foo->a = 'a';
    $foo->b = iThrow();
    $foo->c = 'c';
} catch (\Throwable $e) {
    var_dump($foo);
}
</code>
The result in all cases is that ''%%a%%'' will be set, while ''%%b%%'' and ''%%c%%'' will not:

<code php>
object(Foo)#1 (3) {
  ["a"]=>
  string(1) "a"
  ["b"]=>
  NULL
  ["c"]=>
  NULL
}
</code>
//I.e. COPA is not an atomic operation in the same way method chaining isn’t.//

==== Out of scope / future scope ====

This section contains a tentative list of features that may not be implemented.

=== Can you do that? ===

The following examples show some things that is now possible using regular property accessor, but which will not also be supported with COPA:

<code php>
$p = 'foo';
$myObj->$p = 'bar'; // Variable property name
$a->{"fo" . "o"} = 'baz'; // Property name generated from expression
$a->b->c = 'hum'; // Creating default object from empty value
$a->d['e'] = 'dear'; // Setting array element inside property
$a->f++; // Increment/decrement of property value

$myObj->[
    $p = 'bar', // Syntax error
    {"foo"} = 'bar', // Syntax error
    b->c = 'hum', // Syntax error - but see Nested COPA below...
    d['e'] = 'dear', // Syntax
    f++, // Syntax error
];
</code>
//If anyone can show that any these features would be significantly desirable and simultaneously rather trivial to implement, let’s discuss.//

=== Nested COPA ===

It might be nice to be able to populate an existing nested object in the same block:

<code php>
// This example, using current syntax...
$foo->a = 1;
$foo->b->c = 2;

// Could be written with COPA like this:
$foo->[
    a = 1,
    b->[
        c = 2,
    ],
];

// But for now you'll have to do this:
$foo->[
    a = 1,
    b = $foo->b->[
        c = 2,
    ],
];

</code>
===== Backward Incompatible Changes =====

None. Array followed by square bracket causes syntax error in PHP 7.4. This new syntax is optional. If you don't use it, your code will continue to run.

===== Proposed PHP Version(s) =====

PHP 8.0

===== Open Issues =====

==== Alternative syntaxes ====

Some alternative syntaxes for COPA has been suggested, but I’m not convinced they can be implemented without hassle:

<code php>
$foo = new Foo()[
   property1 = "hello",
   property2 = 5,
 ];
</code>
For some reason it’s not possible to do this:

<code php>
new Foo()->doSomething(); // syntax error, unexpected '->'
</code>
It’s necessary to wrap the instantiation in brackets:

<code php>
(new Foo)->doSomething(); // Ok
</code>
Which is why I think it will be necessary in my proposal as well.

Furthermore, a variable or object directly followed by square brackets usually imply array access on it. That syntax would conflict with COPA.


----

//Unless someone can convince me that it’s trivial to implement another syntax that looks even better, my stance is that the people who are going to vote no on this because they don’t find the feature useful are not gonna change their mind if the syntax changes, and the people who find this feature useful will prefer rapid adaptation over solving implementation issues.//

==== Mandatory properties ====

Rowan Tommins:

> It seems pretty rare that an object would have no mandatory properties, so saying “if you have a mandatory property, COPA is not for you” is ruling out a lot of uses.

Is it possible to amend the proposal to help with mandatory properties? Or at least give an example of how you would add the check yourself?

===== Proposed Voting Choices =====

The primary vote of whether or not to accept this RFC requires a 2/3 majority.

A secondary “vote” directed at no-voters, will ask you the primary reason for voting “No”.

The options will be:

  - I voted yes!
  - I don’t find the feature useful
  - I don’t like the syntax
  - A more comprehensive solution to this problem will be better
  - A thinner solution to this problem will be better
  - This breaks backwards compatibility too much
  - This will negatively limit future changes
  - It will be a nightmare to implement and maintain
  - I prefer not to say

This will help understand what the obstacles are, when studying this RFC in the future, should anyone be tempted to have another shot at object literals et. al.

===== Patches and Tests =====

There are yet no patches nor tests. The question of who will be developing this will be addressed if the RFC passes.

===== Implementation =====

After the project is implemented, this section should contain

  - the version(s) it was merged into
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature
  - a link to the language specification section (if any)

===== References =====

Related RFCs:

  * https://wiki.php.net/rfc/object-initializer
  * https://wiki.php.net/rfc/objectarrayliterals
  * https://wiki.php.net/rfc/simplified_named_params
  * https://wiki.php.net/rfc/named_params
  * https://wiki.php.net/rfc/code_free_constructor
  * https://wiki.php.net/rfc/constructor-promotion
  * https://wiki.php.net/rfc/automatic_property_initialization
  * https://wiki.php.net/rfc/skipparams
