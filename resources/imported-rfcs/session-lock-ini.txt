
====== PHP RFC: Introduce session.lock, session.lazy_write and session.lazy_destory ======
  * Version: 1.2
  * Date: 2014-01-20 
  * Author: Yasuo Ohgaki, yohgaki@ohgaki.net
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/session-lock-ini

===== Introduction =====

**1st proposal:**

Session module locks session data while executing script by default. This make sure session data integrity by serializing script execution. i.e. Only a script may have control of session data at a time.

Current behavior ensure session data integrity, but it serializes script execution and slows down application performance.

Memcached session save handler has lock ini option for better performance by sacrificing integrity a little. Second proposal mitigates broken integrity by unlocked session data access.

**2nd proposal:**

Session data does not have to write back to session data storage if session data has not changed. By omitting write, overall system performance may improve. It also helps keep session integrity for unlocked session access.


**3rd proposal:**

When session ID is renewed, race condition may occur. 

  * Script A renewed session ID
  * Script B accessed to server with old session ID

Current session module simply deletes session data with $delete_old_session=true. When $delete_old_session=false(default), it simply creates new session ID and leave old session ID.

Even when old session ID is destroyed, script B can access server with old session ID. Without session.strict_mode=On, session module may reinitialize session data with old ID which may be known to attackers.

Lazy session data deletion solves this issue.


**Summary:**
For concurrent session access, current session module saves "the last one write to session data". New session modules with new INI parameters enabled, module saves "the one changed session data".

Currently, programmer has no control which session data is saved. New behavior allows programmer to control save changed session data when there are concurrent access. 

===== Proposal 1 - session.lock =====

Introduce session.lock that enable/disable session data lock.

  session.lock - On by default.

When session.lock=On, save handler works exactly as it is now.

When session.lock=Off, save handler lock session data only when locking is strictly needed. For files save handler, it locks only when reading/writing data.

Current behavior:

  Open session data   -----------------
   ↓                         ↑
  Read session data           ｜
   ↓
  （Script execution）      Locked
   ↓
  Write session data          ｜
   ↓　                       ↓
  Close session data  ------------------

New behavior with session.lock=Off:
        
  Open session data 
   ↓               
  Read session data   ←   Locked
   ↓
  （Script execution）      
   ↓
  Write session data  ←   Locked
   ↓　               
  Close session data


**Pros.**
  * Application that are secure with this option can have much better concurrency and performance without additional/modified scripts.

**Cons.**
  * Users may enable this option even if application does not support this. This could result in strange application behavior.


===== Proposal 2 - session.lazy_wirte =====

Introduce session.lazy_write that enable/disable lazy session data writing.

  session.lazy_write - Off by default

When session.lazy_write=Off, session module works exactly as it is now.

WHen session.lazy_write=On, session module save session data only when session data has been changed.

When reading session data, session module takes MD5 hash for read data. When writing session data, session module compares old MD5 and new MD5 of session data and save session data only when MD5 differs.

Since write is omitted, save handler may not change "last updated time". This may result deleting session data by timeout. To prevent unwanted expiration of session, introduce new save handler API that update "last updated time" of session data.

  PS_UPDATE()

Session module calls PS_UPDATE() instead of PS_WRITE() when session.lazy_write=On.

**Pros.**
  * session.lazy_write=On could improved 2 times or better performance by removing write() calls.
  * session.lazy_write=On provides better data consistency since only modified session data is written when session.lock=Off, 

**Cons.**
  * Session behavior is changed. When session.lazy_write=Off, "last session written" wins. When session.lazy_write=On, "last session modified" wins. 
  * Programmers are responsible for ensuring data consistency when session.lock=Off.

**NOTE: save handler implementation**

For files save handler, PS_UPDATE() is not needed as it can update mtime at PS_OPEN(). Files save handler's PS_UPDATE() will be empty function that simply return true. 

For memcache/memcached/redis save handlers, PS_UPDATE() is not needed since read access(PS_READ()) updates last access time stamp. PS_UPDATE() may return true simply.

Other save handlers should support PS_UPDATE() API to update last access time. Otherwise, garbage correction may remove active sessions. Alternatively, save handler may update last access time when PS_OPEN()/PS_READ() is called, then PS_UPDATE() may return true simply.


===== Proposal 3 - session.lazy_destroy =====

Introduce session.lazy_destroy that enable/disable lazy session data deletion.

  session.lazy_destroy - 0 by default. Seconds that app may access session marked to be deleted.


In order to session module to know if the session data is already deleted and accessible, there must be flag/time stamp for deletion/access control.

**First option:**

<nowiki>
Save time stamp in $_SESSION['__PHP_SESSION_DESTROYED__']. 
</nowiki>

  * Pros - simple and fast.
  * Cons - exposed internal data.

**Alternative option:**

Introduce new save handler API that saves flag/time stamp else where.

  * Pros - clean. no exposed data.
  * Cons - complex and slow.

Since alternative option could impact performance a lot. This RFC choose first option.


**Pros and Cons for this proposal**

**Pros**
  * session_regenerate_id() becomea more reliable for reasons described below.
  * Mitigate race condition that creates unneeded sessions. NOTE: Unneeded session created by race condition could be known session to attacker. Unneeded session increase system load.
  * Ensure proper application behavior even when network connection is unreliable. This is important for mobile applications especially.

**Cons**
  * Deleted session is accessible by specified time. NOTE: Access to deleted session is required for reliable session_regenerate_id() operation.
  * Deleted session contains time stamp variable in $_SESSION. NOTE: Time stamp is mandatory and storing it in $_SESSION is the fastest and simplest way. 

===== Backward Incompatible Changes =====

None.

As long as user uses default settings.

===== Proposed PHP Version(s) =====

PHP 5.6 and later.


===== Impact to Existing Extensions =====

None. 

Old save handler works without new INI or API support.

Save handler module needs to be recompiled, but recompile is required for new release anyway.


===== php.ini Defaults =====

  * session.lock=On
  * session.lazy_write=0
  * session.lazy_destroy=Off

for hardcoded/development/production.

===== Open Issues =====

None.

===== Related Features ====

  * session_commit()/session_write_close() - Implemented (PHP 4.0 and up). End session and write session data.
  * session_abort() - Implemented (5.6 and up). End session without saving session data.
  * session_unlock() - Will be implemented (5.6 and up). Unlock session data. Session data is saved at close. i.e. session_commit() or module shutdown.


===== Proposed Voting Choices =====

  * Proposal1,2,3: Yes / No for each feature. 

1) session.lock that minimize locked time. 

2) session.lazy_write that write only session data has changed. 

3) session.lazy_destroy that allows delayed session data deletion for concurrent accesses and reliable session_regenerate_id() operation.

Please note that session.lazy_destroy is **mandatory for reliable session_regenerate_id()**. Please refer to referenced discussion for details.

===== Vote =====

Please vote feature by feature.

The voting period is 2014/01/20 until 2014/01/30.

1) Introduce session.lock INI option.
<doodle title="RFC/session_lock" auth="user" voteType="single" closed="true">
   * Yes
   * No
</doodle>

2) Introduce session.lazy_write INI option.
<doodle title="RFC/session_lazy_write" auth="user" voteType="single" closed="true">
   * Yes
   * No
</doodle>

3) Introduce session.lazy_destroy INI option.
<doodle title="RFC/session_lazy_destroy" auth="user" voteType="single" closed="true">
   * Yes
   * No
</doodle>

Thank you for voting!


===== Patches and Tests =====

Patch will be reviewed before commit.

Note: Partial patch that omits write in files save handler is already committed. It may change session module behavior and will be replaced with new patch.

===== Implementation =====

After the project is implemented, this section should contain 
  - the version(s) it was merged to
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature

===== References =====

  * session_regenerated_id() discussion - http://marc.info/?l=php-internals&m=138242492914526&w=2
  * session.lock discussion - http://marc.info/?l=php-internals&m=138445826032002&w=2

===== Rejected Features =====
