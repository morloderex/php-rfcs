====== PHP RFC: #[\Deprecated] Attribute ======

  * Version: 1.4
  * Date: 2024-05-04
  * Author: Benjamin Eberlei, Tim Düsterhus 
  * Status: Voting
  * First Published at: http://wiki.php.net/rfc/deprecated_attribute

===== Introduction =====

PHP’s internal functions and (class-)constants can be marked as deprecated, making this information available to Reflection and emitting deprecation errors (<php>E_DEPRECATED</php>), but there is no //equivalent// functionality for functions defined in userland.

While the functionality can be //emulated// using <php>trigger_error()</php> to emit a <php>E_USER_DEPRECATED</php> error when calling a deprecated function, combined with either parsing a doc comment for the <php>/** @deprecated */</php> annotation or attaching a custom-defined attribute and reading it with Reflection, it requires special handling depending on whether the function in question is an internal or a userland function. <php>ReflectionFunctionAbstract::isDeprecated()</php> always returns <php>false</php> for userland functions - and doc comments / custom attributes are unavailable for internal functions. For class constants the deprecation behavior cannot be emulated at all.

===== Proposal =====

A new attribute <php>#[\Deprecated]</php> shall be added:


<PHP>
#[Attribute(Attribute::TARGET_METHOD|Attribute::TARGET_FUNCTION|Attribute::TARGET_CLASS_CONSTANT)]
final class Deprecated
{
    public readonly ?string $message;

    public readonly ?string $since;

    public function __construct(?string $message = null, ?string $since = null) { /* … */ }
}
</PHP>

Applying this attribute to a userland function, method, or class constant will add the internal ''ZEND_ACC_DEPRECATED'' flag to the element, resulting in a behavior that is consistent with the existing deprecation functionality for internal functions and class constants. This means:

  * For functions and methods <php>ReflectionFunctionAbstract::isDeprecated()</php> will return <php>true</php>.
  * For class constants <php>ReflectionClassConstant::isDeprecated()</php> will return <php>true</php> (this method is newly added in PHP 8.4).
  * Calling a function will emit a <php>E_USER_DEPRECATED</php> error (internal functions emit <php>E_DEPRECATED</php>, but this error code is reserved for internal functions).
  * Accessing a class constant will emit a <php>E_USER_DEPRECATED</php> error (likewise internal class constants use <php>E_DEPRECATED</php>).

The <php>$message</php> given within the attribute definition will be included in the error message when calling the function or accessing the class constant. It goes without saying that it will also be available to static analysis tools, just like the parameters of any other attribute.

Likewise the <php>$since</php> value is also included within the error message, intended to indicate since when the element having the attribute is deprecated. It is included for easier programmatic access, due to its pre-existing use within the PHP documentation and also userland libraries and frameworks. The contents of <php>$since</php> may be a free-form string that is not validated. The semantics of the property is left to the library applying the <php>#[\Deprecated]</php> attribute. It may contain a version number, a date, or anything else the library in question considers appropriate.

While internal, non-class constants can also be marked as deprecated, there is no support for attributes on them yet, and <php>ReflectionConstant</php> has just been added in PHP 8.4. Adding attribute support for non-class constants is out of scope of this RFC/PR for now.

Enum cases are internally implemented as class constants. Adding the <php>#[\Deprecated]</php> attribute to an enum case will behave as expected.

==== Examples ====

<PHP>
<?php

#[\Deprecated]
function test() {
}

#[\Deprecated("use test() instead")]
function test2() {
}

#[\Deprecated("use test() instead", since: "2.4")]
function test3() {
}

#[\Deprecated(since: "2024-05-07")]
function test4() {
}

class Clazz {
    #[\Deprecated]
    public const OLD_WAY = 'foo';
    
    #[\Deprecated]
    function test() {
    }

    #[\Deprecated("use test() instead")]
    function test2() {
    }
}

enum MyEnum {
    #[\Deprecated]
    case OldCase;
}

test(); // Deprecated: Function test() is deprecated in test.php on line 37
test2(); // Deprecated: Function test2() is deprecated, use test() instead in test.php on line 38
test3(); // Deprecated: Function test2() is deprecated since 2.4, use test() instead in test.php on line 39
test4(); // Deprecated: Function test4() is deprecated since 2024-05-07 in test.php on line 40
call_user_func("test"); // Deprecated: Function test() is deprecated in test.php on line 41

$cls = new Clazz();
$cls->test(); // Deprecated: Method Clazz::test() is deprecated in test.php on line 44
$cls->test2(); // Deprecated: Method Clazz::test2() is deprecated, use test() instead in test.php on line 45
Clazz::OLD_WAY; // Deprecated: Constant Clazz::OLD_WAY is deprecated in test.php on line 46

MyEnum::OldCase; // Deprecated: Enum case MyEnum::OldCase is deprecated in test.php on line 48

call_user_func([$cls, "test"]); // Deprecated: Method Clazz::test() is deprecated in test.php on line 50

?>
</PHP>

<PHP>
<?php

#[\Deprecated]
function test() {
}

$r = new ReflectionFunction('test');

var_dump($r->isDeprecated()); // bool(true)

?>
</PHP>

<PHP>
<?php

class Clazz {
    #[\Deprecated]
    public const OLD_WAY = 'foo';
}

$r = new ReflectionClassConstant(Clazz::class, 'OLD_WAY');

var_dump($r->isDeprecated()); // bool(true)

?>
</PHP>

<PHP>
<?php

#[\Deprecated]
function test1() {
}

#[\Deprecated()]
function test2() {
}

#[\Deprecated("use test() instead")]
function test3() {
}

#[\Deprecated("use test() instead", since: "2.4")]
function test4() {
}

#[\Deprecated(since: "2024-05-07")]
function test5() {
}

$reflection = new ReflectionFunction('test1');
var_dump($reflection->getAttributes()[0]->newInstance());
/*
object(Deprecated)#3 (2) {
  ["message"]=>
  NULL
  ["since"]=>
  NULL
}
*/

$reflection = new ReflectionFunction('test2');
var_dump($reflection->getAttributes()[0]->newInstance());
/*
object(Deprecated)#2 (2) {
  ["message"]=>
  NULL
  ["since"]=>
  NULL
}
*/

$reflection = new ReflectionFunction('test3');
var_dump($reflection->getAttributes()[0]->newInstance());
/*
object(Deprecated)#1 (2) {
  ["message"]=>
  string(18) "use test() instead"
  ["since"]=>
  NULL
}
*/

$reflection = new ReflectionFunction('test4');
var_dump($reflection->getAttributes()[0]->newInstance());
/*
object(Deprecated)#3 (2) {
  ["message"]=>
  string(18) "use test() instead"
  ["since"]=>
  string(3) "2.4"
}
*/

$reflection = new ReflectionFunction('test5');
var_dump($reflection->getAttributes()[0]->newInstance());
/*
object(Deprecated)#2 (2) {
  ["message"]=>
  NULL
  ["since"]=>
  string(10) "2024-05-07"
}
*/

?>
</PHP>

Further examples are given by [[https://github.com/php/php-src/pull/11293/files?file-filters%5B%5D=.phpt&show-viewed-files=true|the newly added tests within the PR for this RFC]].

===== Backward Incompatible Changes =====

<php>Deprecated</php> can no longer be used as a class name in the global namespace. A GitHub search for ''"class Deprecated " language:php symbol:deprecated'' revealed a total of 173 matches in source code. The vast majority of them appear to be defined within a namespace.

===== Proposed PHP Version(s) =====

Next minor (PHP 8.4).

===== RFC Impact =====

==== To SAPIs ====

None.

==== To Existing Extensions ====

The <php>#[\Deprecated]</php> attribute will also be available to internal functions and internal class constants. Within a stub file it will have the same effect as adding a <php>/** @deprecated */</php> doc comment. The attribute will //not// be automatically applied to existing functions having the doc comment, but extension authors are encouraged to apply the attribute for consistency reasons.

For extensions that are part of php-src the attribute will replace the existing doc comment as part of this RFC.

==== To Opcache ====

None.

==== New Constants ====

None.

==== php.ini Defaults ====

None.

===== Open Issues =====

A few things tracked in https://github.com/php/php-src/pull/11293

===== Future Scope =====

  * Supporting <php>#[\Deprecated]</php> on other targets of attributes that to not yet support deprecations for internally defined symbols, for example classes.
  * Adding further metadata to the <php>#[\Deprecated]</php> attribute beyond a custom message (e.g. hints for replacements that IDEs could use).

===== Proposed Voting Choices =====

==== Primary Vote ====

2/3 majority for the primary vote:

<doodle title="Implement the #[\Deprecated] attribute?" auth="timwolla" voteType="single" closed="false" closeon="2024-06-05T08:00:00Z">
   * Yes
   * No
</doodle>

==== Secondary Votes ====

50% majority for each secondary vote. Ties are broken at the RFC authors’ discretion.

<doodle title="Include the Deprecated::$since property?" auth="timwolla" voteType="single" closed="false" closeon="2024-06-05T08:00:00Z">
   * Yes
   * No
</doodle>

===== Patches and Tests =====

https://github.com/php/php-src/pull/11293

===== Implementation =====

n/a

===== References =====

  * Implementation: https://github.com/php/php-src/pull/11293
  * Early Mailing List Discussion: https://externals.io/message/112554#112554

===== Rejected Features =====

  * Changes to the runtime behavior of deprecated functions and class constants are out of scope of this RFC (i.e. not emitting the <php>E_DEPRECATED</php> error for internal functions).
  * Making the <php>Deprecated</php> attribute class non-final: Child classes of attributes are not understood by the engine for technical reasons and the semantics of a child class would be less clear for static analysis tools.