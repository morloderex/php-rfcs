====== PHP RFC: Property Accessors ======
  * Date: 2021-01-27
  * Author: Nikita Popov <nikic@php.net>
  * Proposed Version: PHP 8.1
  * Implementation: https://github.com/php/php-src/pull/6873 (WIP)
  * Status: Draft

> **This is an early draft.**

===== Introduction =====

Property accessors allow implementing custom behavior for reading or writing a property. PHP already provides this general functionality through ''%%__get()%%'' and ''%%__set()%%''. However, these methods are non-specific and may be used to intercept all property accesses. This RFC proposes to add per-proprety accessors.

The primary use case for accessors is actually to **not** use them, but retain the ability to do so in the future, should it become necessary. Consider the following class declaration, which might have been considered idiomatic prior to PHP 7.4:

<PHP>
class User {
    private $name;

    public function __construct(string $name) {
        $this->name = $name;
    }

    public function getName(): string {
        return $this->name;
    }

    public function setName(string $name): void {
        $this->name = $name;
    }
}
</PHP>

With the introduction of typed properties in PHP 7.4, the use of getters and setters in this example no longer serves a useful purpose, and only increases the necessary boilerplate both in the class declaration, and for any consumers of the class. We could instead use a typed public property:

<PHP>
class User {
    public string $name;

    public function __construct(string $name) {
        $this->name = $name;
    }
}
</PHP>

Or even make use of constructor property promotion:

<PHP>
class User {
    public function __construct(public string $name) {}
}
</PHP>

This has one significant disadvantage: What happens if we later, for whatever reason, do want to introduce additional behavior for this property, for example by validating that it is non-empty? We could restore the original getters and setters, but that would constitute an API break. Or we could add the additional behavior through ''%%__get()%%'' and ''%%__set()%%'':

<PHP>
class User {
    private string $_name;

    public function __construct(string $name) {
        $this->name = $name;
    }

    public function __get(string $propName): mixed {
        return match ($propName) {
            'name' => $this->_name,
            default => throw new Error("Attempt to read undefined property $propName"),
        };
    }

    public function __set(string $propName, $value): void {
        switch ($propName) {
            case 'name':
                if (!is_string($value)) {
                    throw new TypeError("Name must be a string");
                }
                if (strlen($value) === 0) {
                    throw new ValueError("Name must be non-empty");
                }
                $this->_name = $value;
                break;
            default:
                throw new Error("Attempt to write undefined property $propName");
        }
    }

    public function __isset(string $propName): bool {
        return $propName === 'name';
    }
}
</PHP>

While doing this is possible, it has many disadvantages. Apart from requiring a lot of additional code, it also breaks reflection and static analysis, as the ''name'' property does not really exist anymore. It is also necessary to reimplement your own type checks, which will not match PHP's behavior (with regard to coercive typing mode).

Property accessors allow you to introduce the additional behavior in a way that is specific to a single property, is reflectible and analyzable, and generally integrates well with the rest of PHP:

<PHP>
class User {
    private string $_name;

    public string $name {
        get {
            return $this->_name;
        }
        set {
            if (strlen($value) === 0) {
                throw new ValueError("Name must be non-empty");
            }
            $this->_name = $value;
        }
    }

    public function __construct(string $name) {
        $this->name = $name;
    }
}
</PHP>

===== Usage patterns =====

The following section illustrates various usage patterns for accessors. An accessor implementation for PHP should support most or all of these in some fashion, though possibly not using the precise syntax employed here.

=== Asymmetric visibility ===

The likely most important use-case for accessors (or a closely related feature) is to restrict visibility of a property asymmetrically, without otherwise changing the behavior:

<PHP>
class User {
    public string $name { get; private set; }

    public function __construct(string $name) {
        $this->name = $name;
    }
}
</PHP>

In this case, the ''name'' property can be accessed from outside the class, but only set inside the class. It is equivalent to defining a getter method, but no setter method. This provides a weak form of read-only properties (publicly read-only).

=== Init-only property ===

Closely related to asymmetric visibility are properties that can only be assigned once:

<PHP>
class User {
    public string $name { get; private init; }

    public function __construct(string $name) {
        $this->name = $name;
    }
}
</PHP>

This is the closest that PHP can have to a "read-only" property. The initialization in the constructor will be permitted, but any further writes are prohibited, even from within the same class.

For most read-only properties, the use of this "init only" approach is appropriate. However, for classes that use "wither" methods implemented using a "clone and set" paradigm, the use of "private set" is necessary.

=== Setter guard ===

This is the use-case mentioned in the introduction: Adding additional validation checks when setting a property:

<PHP>
class User {
    public string $name {
        get; set;
        guard {
            if (strlen($value) === 0) {
                throw new ValueError("Name must be non-empty");
            }
        }
    }
}
</PHP>

The guard handler is invoked directly before the property value is set.

=== Lazy initialization ===

For values that are expensive to compute, it may be useful to lazily initialize a property the first time it is accessed:

<PHP>
class Test {
    public string $somethingExpensive {
        get;
        lazy {
            return computeSomethingExpensive();
        }
    }
}
</PHP>

On first access, the lazy initializer is invoked and the result is stored. On subsequent accesses, the stored value is used, and the initializer is not invoked again.

=== Synthesized properties ===

Finally, there are "real" accessor properties, which access a synthesized value. This could be in a read-only fashion, or a read-write fashion:

<PHP>
class Test {
    public int $value;
    public int $plusOne {
        get { return $this->value + 1; }
    }
}

class Test {
    public int $value;
    public int $plusOne {
        get {
            return $this->value + 1;
        }
        set {
            $this->value = $value - 1;
        }
    }
}
</PHP>

=== Properties in interfaces ===

As accessors make properties a first-class citizen in class APIs, it also needs to be possible to declare properties in interfaces (or as abstract):

<PHP>
interface UserInterface {
    // Interface requires that property is public readable.
    public string $name { get; }
}

class User implements UserInterface {
    // Implemented without accessors, but (more than) satisfies the interface.
    public string $name;
}
</PHP>

The interface declares a property that has to be at least readable, while the implementing class implements it in a way that is also writable, by using an ordinary property without accessors.

===== Proposal =====

==== Basic accessors ====

To declare an accessor property, the trailing semicolon of a property declaration is replaced by accessor list, which must contain at least one accessor:

<PHP>
class Test {
    // Illegal, must define at least one accessor.
    public $prop { }

    // Read-only property.
    public $prop { get; }

    // Write-only property. (Of dubious usefulness.)
    public $prop { set; }

    // Read-write property.
    public $prop { get; set; }
}
</PHP>

The basic accessors are ''get'' and ''set'', which are invoked when the property is read or written respectively. If an accessor is omitted, then performing the corresponding operation on the property will result in an ''Error'' exception.

The above example uses automatically generated accessors, which are discussed in the "Backing property" section. If an explicit implementation is provided, ''get'' should return the value of the property, which must satisfy the type of the property under the usual rules:

<PHP>
class Test {
    public int $prop {
        get { return 42; }

        // Effectively:
        public function get(): int { return 42; }
    }
}

$test = new Test;
var_dump($test->prop); // int(42)

// Modification of read-only property throws:
$test->prop = 1; // Error: Property Test::$prop is read-only
$test->prop += 1; // Error: Property Test::$prop is read-only
</PHP>

The ''set'' handle receives the new value of the property as the ''$value'' variable, which is compatible with the property type:

<PHP>
class Test {
    public string $prop {
        set { echo "Set to $value\n"; }

        // Effectively:
        public function set(string $value): void { echo "Set to $value\n"; }
    }
}

$test = new Test;
$test->prop = "foobar"; // "Set to foobar\n"

// Reading of write-only property throws:
var_dump($test->prop); // Error: Property Test::$prop is write-only
var_dump(isset($test->prop)); // Error: Property Test::$prop is write-only
</PHP>

The default name of ''$value'' can be changed by explicitly specifying the parameter name:

<PHP>
class Test {
    public string $prop {
        set($someOtherName) { echo "Set to $someOtherName\n"; }
    }
}
</PHP>

Write-only properties like the above example have dubious usefulness. The more typical case is where a property defines both ''get'' and ''set'':

<PHP>
class Test {
    public int $value = 0;
    public int $valuePlusOne {
        get { return $value + 1; }
        set { $this->value = $value - 1; }
    }
}

$test = new Test;
$this->value = 9;
var_dump($this->valuePlusOne); // int(10)
$this->valuePlusOne = 42;
var_dump($this->value); // int(41)

$this->valuePlusOne += 5;
// Behaves like:
$this->valuePlusOne = $this->valuePlusOne + 5;
</PHP>


It is not permitted to specify any explicit types on accessors, as they are inferred from the type of the property. Code like the following is illegal:

<PHP>
class Test {
    public string $prop {
        get(): string { return ""; } // Can't have return type (it's implicit)
        set(string $value): void { } // Can't have argument or return type (it's implicit)
    }
}
</PHP>

The following signatures are also illegal:

<PHP>
get() {}       // Must not have parameter list
set() {}       // Must have exactly one parameter
set($a, $b) {} // ... if a parameter list is specified
set(...$a) {}  // Cannot be variadic
set(&$a) {}    // Cannot be by-reference
set($a = 1) {} // Cannot have default
</PHP>

==== Visibility ====

The visibility of the accessors defaults to the visibility of the property, but may be explicitly overridden for individual accessors, resulting in asymmetric visibility:

<PHP>
class Test {
    public string $prop { get; private set; }

    public function __construct(string $prop) {
        $this->prop = $prop;
    } 
}

$test = new Test("foo");
var_dump($test->prop); // Works.
$test->prop = "bar"; // Error: Call to private accessor Test::$prop::set() from global scope
</PHP>

Visibility on individual accessors must either be omitted, or strictly smaller than the property visibility:

<PHP>
class Test {
    // Illegal: "public get" has higher visibility than "private $prop".
    private string $prop { public get; set; }
    
    // Illegal: "public get" has same visibility as "public $prop".
    // This visibility modifier is redundant and must be omitted.
    public string $prop { public get; private set; }
}
</PHP>

==== Inheritance ====

Acessors can be inherited with similar semantics to normal methods, and support ''abstract'' and ''final'' modifiers.

=== Simple inheritance ===

Accessors from the child class take precedence, but accessors that have not been explicitly overridden will be taken from the parent class:

<PHP>
class A {
    public $prop {
        get { echo __METHOD, "\n"; }
        set { echo __METHOD, "\n"; }
    }
}
class B extends A {
    public $prop {
        set { echo __METHOD, "\n"; }
    }
}

$b = new B;
$b->prop;     // A::$prop::get (inherited)
$b->prop = 1; // B::$prop::set (overridden)
</PHP>

TODO: Compatibility.

=== Final properties and accessors ===

Accessors can be marked as final, in which case they cannot be overridden in child classes:

<PHP>
class A {
    public $prop {
        get { echo __METHOD, "\n"; }
        final set { echo __METHOD, "\n"; }
    }
}
// Legal: A::$prop::get() can be overridden.
class B extends A {
    public $prop {
        get { echo __METHOD, "\n"; }
    }
}
// Illegal: A::$prop::set() is final.
class C extends A {
    public $prop {
        set { echo __METHOD, "\n"; }
    }
}
</PHP>

A whole property can also be marked final. This will prohibit any redeclaration in child classes, even if accessors are only added:

<PHP>
class A {
    // This is legal also for non-accessor properties.
    final public $prop { get; }
}

class B extends A {
    // Illegal, property is final.
    public $prop { set; }
}
</PHP>

Marking a property/accessor both private and final is illegal. Redundant final modifiers are illegal.

<PHP>
class Test {
    // Illegal, private and final.
    private final $prop;
    
    // Illegal, redundant final.
    final public $prop { final get; final set; }
}
</PHP>

=== Abstract properties and accessors ===

Accessors can be marked abstract, in which case the class must also be abstract, and the accessor needs to be implemented by any (non-abstract) child class.

<PHP>
abstract class A {
    public $prop {
        get { echo __METHOD__, "\n"; }
        abstract set;
    }
}
// Illegal, missing implementation for A::$prop::set().
class B extends A {
}
// Legal, all abstract accessors implemented.
class C extends A {
    public $prop {
        set { echo __METHOD__, "\n"; }
    }
}
</PHP>

A whole property can be marked abstract, which is the same as marking all accessors abstract:

<PHP>
abstract class A {
    abstract public $prop { get; set; }
}
// Legal implementation.
class B extends A {
    public $prop;
}
</PHP>

It is **not** legal to mark a non-accessor property as abstract. It is always required to specify which accessors an abstract property needs to satisfy.

<PHP>
abstract class A {
    // Illegal, only accessor properties can be abstract.
    abstract public $prop;
}
</PHP>

Properties / accessors cannot be both abstract and private. Redundant abstract modifiers (on both the property and the accessor) cannot be specified. Abstract accessors cannot have bodies.

==== Implicit implementation and backing property ====

If a property accessor is defined that has neither an explicit ''get'' or ''set'' implementation, then an automatic backing property is generated, and ''get'' and ''set'' are implemented to read and write that backing property.

That is, the following two pieces of code are conceptually equivalent:

<PHP>
class Test {
    public string $prop { get; set; }
}

class Test {
    private string $_prop;
    public string $prop {
        get { return $this->_prop; }
        set { $this->_prop = $value; }
    }
}
</PHP>

The actual backing property however has the same name as the accessor property, and will appear as such in ''var_dump()'' output and similar.

If either ''get'' or ''set'' has an explicit implementation, then no backing property is generated, in the sense that PHP will not reserve space for optimized access of the property. However, following the recursion behavior of ''%%__get()%%'' and ''%%__set()%%'', the accessors implementations could still operate on a property of the same name:

<PHP>
class Test {
    public string $prop {
        get { return $this->prop; }
        set { $this->prop = $value; }
    }
}
</PHP>

Just like with ''%%__get()%%'' and ''%%__set()%%'', this would not recursively invoke the accessors and instead operate on an actual property of the same name. As no backing property is generated in this case, the property would be a dynamic one. It is recommended to declare an explicit backing property if you want to implement accessors with non-trivial behavior.

If there is no explicit ''get'' or ''set'' implementation, then a default value for property may be specified:

<PHP>
class Test {
    public string $prop = "" { get; set; }
}
</PHP>

This default value is the default value of the backing property. If there is an explicit ''get'' or ''set'' implementation, then specifying a default value is illegal.

TODO: bwoebi suggests that instead the specification of a default should always result in the generationg of an implicit backing property, regardless of whether get/set are implicit or not.

==== Lazy initialization ====

A lazily initialized property can be implemented using the ''get'' accessors as follows:

<PHP>
class Test {
    private ?T $cache = null;
    public T $lazy {
        get {
            if ($this->cache === null) {
                $this->cache = computeValue();
            }
            return $this->cache;
        }
        // Optional, depending on whether it should be read-only or not.
        set { $this->cache = $value; }
    }
}
</PHP>

However, this has a significant disadvantage: Even after the property has been initialized, accessing it still requires invocation of the getter, which is very inefficient. To handle this case more efficiently, a separate ''lazy'' accessor is provided:

<PHP>
class Test {
    public T $lazy {
        lazy {
            return computeValue();
        }
        // Optional, depending on whether it should be read-only or not.
        set;
    }
}
</PHP>

The ''lazy'' accessor is invoked on first access to the property, and is used to initialize the proprety. All subsequent accesses will read the value directly.

It is not possible to declare both ''lazy'' and ''get''. TODO: Should that be possible? Possibly ''lazy'' should really be ''init'' and be independent of ''get'' entirely?

TODO: Girgias suggests that we should allow ''init'' + manually implemented ''set''. In this case ''set'' will be called with the value returned by ''init'' on first access. My own view here is that it is only used to initialize the backing property.

==== Setter guard ====

It is possible to implement a setter guard, which imposes additional pre-conditions for setting a property, by implementing both ''get'' and ''set'' with a separate underlying property:

<PHP>
class Test {
    private string $_name;
    public string $name {
        get { return $this->_name; }
        set {
            if ($value === '') {
                throw new ValueError("Name cannot be empty");
            }
            $this->_name = $value;
        }
    }
}
</PHP>

This has the disadvantage that the underlying property has to be explicitly managed, and it is necessary to invoke the getter every time it is read. Once again, a more concise and efficient method to add setter guards is provided:

<PHP>
class Test {
    public string $name {
        guard {
            if ($value === '') {
                throw new ValueError("Name cannot be empty");
            }
        }
    }
}
</PHP>

The ''guard'' accessor is invoked before the property is actually modified, and it's only purpose is to throw an exception to reject invalid values.

TODO: Once again, how does this interact with ''get'' and ''set''? Probably those should be specified explicitly.

==== Constructor promotion =====

If only implicitly implemented accessors are used, then accessor properties can be used in conjunction with constructor promotion:

<PHP>
class Test {
    public function __construct(
        public string $prop { get; private set; },
        public int $prop2 = 0 { get; private set; },
    ) {}
}
</PHP>

Constructor promotion cannot be used with explicitly implemented accessors, the following code is illegal:

<PHP>
class Test {
    public function __construct(
        public string $prop {
            get { return ""; }
            set { echo "Set!\n"; }
        }
    ) {}
}
</PHP>

This limitation exists to prevent embedding of very large property declarations in the constructor signature.

==== Isset and unset ====

It is not possible to define ''isset'' or ''unset'' accessors. ''isset($obj->accessorProp)'' is equivalent to ''$obj->accessorProp !== null'' and ''unset($obj->accessorProp)'' always throws an ''Error'' exception.

==== Parent accessors ====

TODO: How should parent accessors be invoked? There's no really clear syntax choice for that. ''parent::get()'' conflicts with a method of the same name. ''parent::$this->prop'' looks like a static property access. ''$this->parent::prop'' would be a possibility.

==== Compatibility between ordinary properties and accessor properties ====

A somewhat tricky question is how ordinary properties and accessor properties interact during inheritance, in terms of which properties are considered "compatible".

<PHP>
class A {
    public $prop1;
    public $prop2 { get; set; }
}
class B extends A {
    public $prop1 { get; set; }
    public $prop2;
}
</PHP>

While it would clearly be legal to replace ''public $prop2 { get; set; }'' with ''public $prop2'', the reverse case is less obvious.

The first complication is the case where the property is indirectly modified, for example because it is used as an array:

<PHP>
class A {
    public $prop;
}
class B extends A {
    public $prop { get; set; }
}

$b = new B;
$b->prop = [];
$b->prop[] = 42;
</PHP>

This will fail, because ''get'' does not return by reference. As such, these properties are technically not compatible. To make this code work, ''get'' would need to return by reference:

<PHP>
class A {
    public $prop;
}
class B extends A {
    public $prop { &get; set; }
}

$b = new B;
$b->prop = [];
$b->prop[] = 42;
</PHP>

However, in that case there is one subtle incompatibility. While this allows acquiring a reference **to** the property, it does not allow storing a reference into the property:

<PHP>
class A {
    public $prop;
}
class B extends A {
    public $prop { &get; set; }
}

$b = new B;
$b->prop =& $prop; // Treated as $b->prop = $prop.
$prop = 42; // Does not modify $b->prop!
</PHP>

This is rather fundamental limitation of property accessors, which prevents them from being fully compatible with ordinary properties.

What does this mean in practice? There's two perspectives to consider here: The first is the perspective of a library author, who replaces a property with an accessor in a minor/patch version. I believe this is acceptable and should not be considered a semver major change (it would defeat the entire proposal if it were), unless the property is explicitly intended to be used in such a fashion.

The other is how this situation is treated by the language itself, during inheritance. It's unclear whether or not we should allow overriding an ordinary property with an accessor property, and whether ''get''-by-reference should be a requirement to do so.

===== Backward Incompatible Changes =====

==== Reserved Keywords ====

The accessor names ''get'', ''set'', ''lazy'' and ''guard'' are **not** added as reserved keywords, and are contextually disambiguated instead.

===== Vote =====
