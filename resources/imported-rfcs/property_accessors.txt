====== PHP RFC: Property Accessors ======
  * Date: 2021-01-27
  * Author: Nikita Popov <nikic@php.net>
  * Proposed Version: PHP 8.1
  * Implementation: https://github.com/php/php-src/pull/6873 (WIP)
  * Status: Draft

> **This is an early draft.**

===== Introduction =====

Property accessors allow implementing custom behavior for reading or writing a property. PHP already provides this general functionality through ''%%__get()%%'' and ''%%__set()%%''. However, these methods are non-specific and may be used to intercept all property accesses. This RFC proposes to add per-proprety accessors.

The primary use case for accessors is actually to **not** use them, but retain the ability to do so in the future, should it become necessary. Consider the following class declaration, which might have been considered idiomatic prior to PHP 7.4:

<PHP>
class User {
    private $name;

    public function __construct(string $name) {
        $this->name = $name;
    }

    public function getName(): string {
        return $this->name;
    }

    public function setName(string $name): void {
        $this->name = $name;
    }
}
</PHP>

With the introduction of typed properties in PHP 7.4, the use of getters and setters in this example no longer serves a useful purpose, and only increases the necessary boilerplate both in the class declaration, and for any consumers of the class. We could instead use a typed public property:

<PHP>
class User {
    public string $name;

    public function __construct(string $name) {
        $this->name = $name;
    }
}
</PHP>

Or even make use of constructor property promotion:

<PHP>
class User {
    public function __construct(public string $name) {}
}
</PHP>

This has one significant disadvantage: What happens if we later, for whatever reason, do want to introduce additional behavior for this property, for example by validating that it is non-empty? We could restore the original getters and setters, but that would constitute an API break. Or we could add the additional behavior through ''%%__get()%%'' and ''%%__set()%%'':

<PHP>
class User {
    private string $_name;

    public function __construct(string $name) {
        $this->name = $name;
    }

    public function __get(string $propName): mixed {
        return match ($propName) {
            'name' => $this->_name,
            default => throw new Error("Attempt to read undefined property $propName"),
        };
    }

    public function __set(string $propName, $value): void {
        switch ($propName) {
            case 'name':
                if (!is_string($value)) {
                    throw new TypeError("Name must be a string");
                }
                if (strlen($value) === 0) {
                    throw new ValueError("Name must be non-empty");
                }
                $this->_name = $value;
                break;
            default:
                throw new Error("Attempt to write undefined property $propName");
        }
    }

    public function __isset(string $propName): bool {
        return $propName === 'name';
    }
}
</PHP>

While doing this is possible, it has many disadvantages. Apart from requiring a lot of additional code, it also breaks reflection and static analysis, as the ''name'' property does not really exist anymore. It is also necessary to reimplement your own type checks, which will not match PHP's behavior (with regard to coercive typing mode).

Property accessors allow you to introduce the additional behavior in a way that is specific to a single property, is reflectible and analyzable, and generally integrates well with the rest of PHP:

<PHP>
class User {
    private string $_name;

    public string $name {
        get {
            return $this->_name;
        }
        set {
            if (strlen($value) === 0) {
                throw new ValueError("Name must be non-empty");
            }
            $this->_name = $value;
        }
    }

    public function __construct(string $name) {
        $this->name = $name;
    }
}
</PHP>

===== Usage patterns =====

The following section illustrates various usage patterns for accessors. An accessor implementation for PHP should support most or all of these in //some// fashion, though possibly not using the exact syntax used here, and possibly not in the initial proposal. Examples in this section should be considered non-normative.

=== Asymmetric visibility ===

The likely most important use-case for accessors (or a closely related feature) is to restrict visibility of a property asymmetrically, without otherwise changing the behavior:

<PHP>
class User {
    public string $name { get; private set; }

    public function __construct(string $name) {
        $this->name = $name;
    }
}
</PHP>

In this case, the ''name'' property can be accessed from outside the class, but only set inside the class. It is equivalent to defining a getter method, but no setter method. This provides a weak form of read-only properties (publicly read-only).

=== Init-only property ===

Closely related to asymmetric visibility are properties that can only be assigned once:

<PHP>
class User {
    public string $name { get; private init; }

    public function __construct(string $name) {
        $this->name = $name;
    }
}
</PHP>

This is the closest that PHP can have to a "read-only" property. The initialization in the constructor will be permitted, but any further writes are prohibited, even from within the same class.

For most read-only properties, the use of this "init only" approach is appropriate. However, for classes that use "wither" methods implemented using a "clone and set" paradigm, the use of "private set" is necessary.

=== Setter guard ===

This is the use-case mentioned in the introduction: Adding additional validation checks when setting a property:

<PHP>
class User {
    public string $name {
        get; set;
        guard {
            if (strlen($value) === 0) {
                throw new ValueError("Name must be non-empty");
            }
        }
    }
}
</PHP>

The guard handler is invoked directly before the property value is set.

=== Lazy initialization ===

For values that are expensive to compute, it may be useful to lazily initialize a property the first time it is accessed:

<PHP>
class Test {
    public string $somethingExpensive {
        get;
        lazy {
            return computeSomethingExpensive();
        }
    }
}
</PHP>

On first access, the lazy initializer is invoked and the result is stored. On subsequent accesses, the stored value is used, and the initializer is not invoked again.

=== Synthesized properties ===

Finally, there are "real" accessor properties, which access a synthesized value. This could be in a read-only fashion, or a read-write fashion:

<PHP>
class Test {
    public int $value;
    public int $plusOne {
        get { return $this->value + 1; }
    }
}

class Test {
    public int $value;
    public int $plusOne {
        get {
            return $this->value + 1;
        }
        set {
            $this->value = $value - 1;
        }
    }
}
</PHP>

=== Properties in interfaces ===

As accessors make properties a first-class citizen in class APIs, it also needs to be possible to declare properties in interfaces (or as abstract):

<PHP>
interface UserInterface {
    // Interface requires that property is public readable.
    public string $name { get; }
}

class User implements UserInterface {
    // Implemented without accessors, but (more than) satisfies the interface.
    public string $name;
}
</PHP>

The interface declares a property that has to be at least readable, while the implementing class implements it in a way that is also writable, by using an ordinary property without accessors.

===== Proposal =====

==== Basic accessors ====

To declare an accessor property, the trailing semicolon of a property declaration is replaced by accessor list, which must contain at least one accessor:

<PHP>
class Test {
    // Illegal, must define at least one accessor.
    public $prop { }

    // Read-only property.
    public $prop { get; }

    // Write-only property. (Of dubious usefulness.)
    public $prop { set; }

    // Read-write property.
    public $prop { get; set; }
}
</PHP>

The basic accessors are ''get'' and ''set'', which are invoked when the property is read or written respectively. If an accessor is omitted, then performing the corresponding operation on the property will result in an ''Error'' exception.

The above example uses automatically generated accessors, which are discussed in the "Backing property" section. If an explicit implementation is provided, ''get'' should return the value of the property, which must satisfy the type of the property under the usual rules:

<PHP>
class Test {
    public int $prop {
        get { return 42; }

        // Effectively:
        public function get(): int { return 42; }
    }
}

$test = new Test;
var_dump($test->prop); // int(42)

// Modification of read-only property throws:
$test->prop = 1; // Error: Property Test::$prop is read-only
$test->prop += 1; // Error: Property Test::$prop is read-only
</PHP>

The ''set'' handle receives the new value of the property as the ''$value'' variable, which is compatible with the property type:

<PHP>
class Test {
    public string $prop {
        set { echo "Set to $value\n"; }

        // Effectively:
        public function set(string $value): void { echo "Set to $value\n"; }
    }
}

$test = new Test;
$test->prop = "foobar"; // "Set to foobar\n"

// Reading of write-only property throws:
var_dump($test->prop); // Error: Property Test::$prop is write-only
var_dump(isset($test->prop)); // Error: Property Test::$prop is write-only
</PHP>

The default name of ''$value'' can be changed by explicitly specifying the parameter name:

<PHP>
class Test {
    public string $prop {
        set($someOtherName) { echo "Set to $someOtherName\n"; }
    }
}
</PHP>

Write-only properties like the above example have dubious usefulness. The more typical case is where a property defines both ''get'' and ''set'':

<PHP>
class Test {
    public int $value = 0;
    public int $valuePlusOne {
        get { return $value + 1; }
        set { $this->value = $value - 1; }
    }
}

$test = new Test;
$this->value = 9;
var_dump($this->valuePlusOne); // int(10)
$this->valuePlusOne = 42;
var_dump($this->value); // int(41)

$this->valuePlusOne += 5;
// Behaves like:
$this->valuePlusOne = $this->valuePlusOne + 5;
</PHP>


It is not permitted to specify any explicit types on accessors, as they are inferred from the type of the property. Code like the following is illegal:

<PHP>
class Test {
    public string $prop {
        get(): string { return ""; } // Can't have return type (it's implicit)
        set(string $value): void { } // Can't have argument or return type (it's implicit)
    }
}
</PHP>

The following signatures are also illegal:

<PHP>
get() {}       // Must not have parameter list
set() {}       // Must have exactly one parameter
set($a, $b) {} // ... if a parameter list is specified
set(...$a) {}  // Cannot be variadic
set(&$a) {}    // Cannot be by-reference
set($a = 1) {} // Cannot have default
</PHP>

==== Visibility ====

The visibility of the accessors defaults to the visibility of the property, but may be explicitly overridden for individual accessors, resulting in asymmetric visibility:

<PHP>
class Test {
    public string $prop { get; private set; }

    public function __construct(string $prop) {
        $this->prop = $prop;
    } 
}

$test = new Test("foo");
var_dump($test->prop); // Works.
$test->prop = "bar"; // Error: Call to private accessor Test::$prop::set() from global scope
</PHP>

Visibility on individual accessors must either be omitted, or strictly smaller than the property visibility:

<PHP>
class Test {
    // Illegal: "public get" has higher visibility than "private $prop".
    private string $prop { public get; set; }
    
    // Illegal: "public get" has same visibility as "public $prop".
    // This visibility modifier is redundant and must be omitted.
    public string $prop { public get; private set; }
}
</PHP>

==== Inheritance ====

Acessors can be inherited with similar semantics to normal methods, and support ''abstract'' and ''final'' modifiers.

=== Simple inheritance ===

Accessors from the child class take precedence, but accessors that have not been explicitly overridden will be taken from the parent class:

<PHP>
class A {
    public $prop {
        get { echo __METHOD, "\n"; }
        set { echo __METHOD, "\n"; }
    }
}
class B extends A {
    public $prop {
        set { echo __METHOD, "\n"; }
    }
}

$b = new B;
$b->prop;     // A::$prop::get (inherited)
$b->prop = 1; // B::$prop::set (overridden)
</PHP>

=== Property compatibility ===

For the most part, accessor properties follow the same compatibility rules as normal properties (e.g. visibility may not be reduced). However, there are some additional considerations.

Normal properties are invariant in the type system. Read-only accessor properties are covariant, while write-only accessor properties are contravariant.

<PHP>
class A {
    public int|string $invariant { get; set; }
    public int|string $covariant { set; }
    // This property is useless, but will serve for the sake of illustration.
    public int|string $contravariant { set; }
}

class B extends A {
    // Illegal: int is not subtype of int|string.
    public int $invariant;
    // Illegal: int|float|string is not subtype of int|string.
    public int|float|string $invariant;

    // Legal: int is subtype of int|string.
    public int $covariant;
    // Illegal: int|float|string is not subtype of int|string.
    public int|float|string $covariant;

    // Illegal: int|string is not a subtype of int.
    public int $contravariant;
    // Legal: int|string is a subtype of int|float|string.
    public int|float|string $contravariant;
}
</PHP>

In practical terms, this means that the type of a read-only property may be narrowed. Widening the type of a write-only property is a largely theoretical property.

Similarly to normal methods, if the parent ''get'' returns by reference, then the child ''get'' is also required to return by reference:

<PHP>
class A {
    public $prop { &get; set; }
}
class B extends A {
    // Illegal: get must return by ref.
    public $prop { get; set; }
    
    // Legal
    public $prop { &get { /* My new get */ } }
}
</PHP>

It is possible to override an accessor property with a normal property:

<PHP>
class A {
    public $prop {
        get { echo __METHOD__, "\n"; }
        set { echo __METHOD__, "\n"; }
    }
}
class B extends A {
    // Legal.
    public $prop;
}
</PHP>

This is allowed, as a normal property can be used anywhere an accessor property can be used. However, the converse does not hold, and the following is illegal:

<PHP>
class A {
    public $prop;
}
class B extends A {
    public $prop { &get; set; }
}
</PHP>

This restriction exists, because accessors, even in their most general form, do not and can not support certain behavior. In particular, while it is possible to take a reference to an accessor property (as long as it uses ''&get''), it's not possible to assign to such a property by reference:

<PHP>
$b = new B;
$b->prop =& $prop; // Error: Cannot assign by reference to overloaded object
</PHP>

As proposed, there are also other limitations, e.g. the inability to ''unset()'' accessor properties (this is a design decision though, and not fundamental).

=== Final properties and accessors ===

Accessors can be marked as final, in which case they cannot be overridden in child classes:

<PHP>
class A {
    public $prop {
        get { echo __METHOD, "\n"; }
        final set { echo __METHOD, "\n"; }
    }
}
// Legal: A::$prop::get() can be overridden.
class B extends A {
    public $prop {
        get { echo __METHOD, "\n"; }
    }
}
// Illegal: A::$prop::set() is final.
class C extends A {
    public $prop {
        set { echo __METHOD, "\n"; }
    }
}
</PHP>

A whole property can also be marked final. This will prohibit any redeclaration in child classes, even if accessors are only added:

<PHP>
class A {
    // This is legal also for non-accessor properties.
    final public $prop { get; }
}

class B extends A {
    // Illegal, property is final.
    public $prop { set; }
}
</PHP>

Marking a property/accessor both private and final is illegal. Redundant final modifiers are illegal.

<PHP>
class Test {
    // Illegal, private and final.
    private final $prop;
    
    // Illegal, redundant final.
    final public $prop { final get; final set; }
}
</PHP>

=== Abstract properties and accessors ===

Accessors can be marked abstract, in which case the class must also be abstract, and the accessor needs to be implemented by any (non-abstract) child class.

<PHP>
abstract class A {
    public $prop {
        get { echo __METHOD__, "\n"; }
        abstract set;
    }
}
// Illegal, missing implementation for A::$prop::set().
class B extends A {
}
// Legal, all abstract accessors implemented.
class C extends A {
    public $prop {
        set { echo __METHOD__, "\n"; }
    }
}
</PHP>

A whole property can be marked abstract, which is the same as marking all accessors abstract:

<PHP>
abstract class A {
    abstract public $prop { get; set; }
}
// Legal implementation.
class B extends A {
    public $prop;
}
</PHP>

It is **not** legal to mark a non-accessor property as abstract. It is always required to specify which accessors an abstract property needs to satisfy.

<PHP>
abstract class A {
    // Illegal, only accessor properties can be abstract.
    abstract public $prop;
}
</PHP>

Properties / accessors cannot be both abstract and private. Redundant abstract modifiers (on both the property and the accessor) cannot be specified. Abstract accessors cannot have bodies.

Accessor properties can also be part of interfaces, in which case they follow the rules of abstract accessors:

<PHP>
interface I {
    public $readonly { get; }
    public $readwrite { get; set; }
}
class C implements I {
    public $readonly { get { return "Foo"; } }
    public $readwrite;
}
</PHP>

Accessor properties in interfaces can only be public, and cannot be explicitly abstract (they are implicitly abstract).

==== Implicit implementation ====

If ''get'' and ''set'' accessors are specified without an implementation, then an implementation is generated automatically. The automatic implementation will forward to an implicit backing property:

<PHP>
class Test {
    public string $prop { get; set; }
}
// Is conceptually similar to:
class Test {
    private string $_prop;
    public string $prop {
        get { return $this->_prop; }
        set { $this->_prop = $value; }
    }
}
</PHP>

The actual backing property however has the same name as the accessor property, and will appear as such in ''var_dump()'' output and similar.

While the implementation will handle such accessors much more efficiently (and will not be performing any actual method calls), they are still subject to normal accessor restrictions. For example, ''get'' and ''&get'' will have distinct behavior (the latter will allow indirect modification, and the former won't).

The primary purpose of auto-implemented accessors is to specify an asymmetric visibility, without changing any behavior:

<PHP>
class Test {
    public string $prop { get; private set; }
}
</PHP>

When auto-implemented accessors are used, a default value may be specified:

<PHP>
class Test {
    public string $prop = "" { get; set; }
}
</PHP>

A default value is not legal if there is an explicit ''get'' or ''set'' implementation.

==== Backing property ====

PHP reserves a slot for each declared property on an object. These properties take up much less memory, and can be accessed more efficiently than dynamic (not declared) properties.

For accessor properties that are fully synthesized (i.e. use a separate property for storage or don't need any storage at all), allocating such a slot would be a waste of memory, as it will never be used.

A backing property is only allocated if at least one accessor uses an implicit implementation.

<PHP>
class Test {
    // Has backing property (uses implicit accessors)
    public string $implicitProp { get; set; }

    // Normal property...
    private string $_prop;
    // Does not have backing property.
    public string $prop {
        get { return $this->_prop; }
        set { $this->_prop = $value; }
    }
}
</PHP>

An open question is what happens if the property is accessed recursively from the accessor:

<PHP>
class Test {
    public $prop {
        get { return $this->prop; }
        set { $this->prop = $prop; }
    }
}
</PHP>

It would be in line with ''%%__get%%''/''%%__set%%'' behavior to make recursive access bypass the accessor. Without a backing property, this would mean that ''$this->prop'' would be created as a dynamic property, which would be very inefficient. I believe it would be better to throw an Error instead.

Another situation to consider is the case where implicit and explicit accessors are mixed:

<PHP>
class Test {
    public int $prop {
        get { return $this->prop * 2; }
        set;
    }
}
</PHP>

Here we use default write behavior, but return the value multiplied by two on read. TODO: Should this be allowed?

==== Lazy initialization ====

A lazily initialized property can be implemented using the ''get'' accessors as follows:

<PHP>
class Test {
    private ?T $cache = null;
    public T $lazy {
        get {
            if ($this->cache === null) {
                $this->cache = computeValue();
            }
            return $this->cache;
        }
        // Optional, depending on whether it should be read-only or not.
        set { $this->cache = $value; }
    }
}
</PHP>

However, this has a significant disadvantage: Even after the property has been initialized, accessing it still requires invocation of the getter, which is very inefficient. To handle this case more efficiently, a separate ''lazy'' accessor is provided:

<PHP>
class Test {
    public T $lazy {
        lazy {
            return computeValue();
        }
        // Optional, depending on whether it should be read-only or not.
        set;
    }
}
</PHP>

The ''lazy'' accessor is invoked on first access to the property, and is used to initialize the proprety. All subsequent accesses will read the value directly.

It is not possible to declare both ''lazy'' and ''get''. TODO: Should that be possible? Possibly ''lazy'' should really be ''init'' and be independent of ''get'' entirely?

TODO: Girgias suggests that we should allow ''init'' + manually implemented ''set''. In this case ''set'' will be called with the value returned by ''init'' on first access. My own view here is that it is only used to initialize the backing property.

==== Setter guard ====

It is possible to implement a setter guard, which imposes additional pre-conditions for setting a property, by implementing both ''get'' and ''set'' with a separate underlying property:

<PHP>
class Test {
    private string $_name;
    public string $name {
        get { return $this->_name; }
        set {
            if ($value === '') {
                throw new ValueError("Name cannot be empty");
            }
            $this->_name = $value;
        }
    }
}
</PHP>

This has the disadvantage that the underlying property has to be explicitly managed, and it is necessary to invoke the getter every time it is read. Once again, a more concise and efficient method to add setter guards is provided:

<PHP>
class Test {
    public string $name {
        guard {
            if ($value === '') {
                throw new ValueError("Name cannot be empty");
            }
        }
    }
}
</PHP>

The ''guard'' accessor is invoked before the property is actually modified, and it's only purpose is to throw an exception to reject invalid values.

TODO: Once again, how does this interact with ''get'' and ''set''? Probably those should be specified explicitly.

==== Constructor promotion =====

If only implicitly implemented accessors are used, then accessor properties can be used in conjunction with constructor promotion:

<PHP>
class Test {
    public function __construct(
        public string $prop { get; private set; },
        public int $prop2 = 0 { get; private set; },
    ) {}
}
</PHP>

Constructor promotion cannot be used with explicitly implemented accessors, the following code is illegal:

<PHP>
class Test {
    public function __construct(
        public string $prop {
            get { return ""; }
            set { echo "Set!\n"; }
        }
    ) {}
}
</PHP>

This limitation exists to prevent embedding of very large property declarations in the constructor signature.

==== Isset and unset ====

It is not possible to define ''isset'' or ''unset'' accessors. ''isset($obj->accessorProp)'' is equivalent to ''$obj->accessorProp !== null'' and ''unset($obj->accessorProp)'' always throws an ''Error'' exception.

==== Parent accessors ====

TODO: How should parent accessors be invoked? There's no really clear syntax choice for that. ''parent::get()'' conflicts with a method of the same name. ''parent::$this->prop'' looks like a static property access. ''$this->parent::prop'' would be a possibility.

===== Backward Incompatible Changes =====

==== Reserved Keywords ====

The accessor names ''get'', ''set'', ''lazy'' and ''guard'' are **not** added as reserved keywords, and are contextually disambiguated instead.

===== Vote =====
