====== PHP RFC: Typed Properties ======
  * Version: 0.1.0
  * Date: 2016-03-16
  * Author: Joe Watkins <krakjoe@php.net>, Phil Sturgeon <philstu@php.net>
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/typed-properties

Following the raging success of PHP 7.0 additions [[https://wiki.php.net/rfc/scalar_type_hints_v5|scalar type hints]] and [[https://wiki.php.net/rfc/return_types|return types]], the next logical step is to provide optional typed properties.

===== Introduction =====

Typed Properties allow for an optional keyword in the definition, after the visibility scope, which contains the type the property should allow. Any parameter type hint or return type will work here, there are no new set of rules.

===== Proposal =====

By providing keywords for all PHP types, you can describe your properties like so:

<code php>
<?php
class Foo {
  public int $int = 1;
  public float $flt = 2.2;
  public array $arr = [];
  public bool $bool = false;
}
</code>

This can be rather useful, as a lot of the job of setters is to ensure the values being passed in are the correct type.

If an attempt is made to assign a value of an incorrect type, a fatal error will be occur:

<code php>
class Foo {
	public int $bar = "turtle";
}

var_dump((new Foo)->bar); // Fatal error: Typed property Foo::$bar must be integer, string used
</code>

Typed Properties are entirely strict, following the same strict rules as strict type hints. This means trying to put a numeric string
into an int field will fail:

<code php>
class Foo {
	public int $bar = "2";
}

var_dump((new Foo)->bar); // Fatal error: Typed property Foo::$bar must be integer, string used
</code>

As you might expect, integers cannot be declared with floats:

<code php>
class Foo {
	public int $bar = 2.2;
}

var_dump((new Foo)->bar); // Fatal error: Typed property Foo::$bar must be integer, float used
</code>

//**Note:** There is one exception to this. Whilst integers cannot take floats at compile time, they are allowed to widen to float in runtime. This is because int's overflow to float when they get too large, so restricting this would break big ints. This may cause some confusion, but seems like something that could be fixed at a later point.
//

You can even catch runtime errors relating to type:

<code php>
class Math {
	public int $x;
	public int $y;
	
	public function __construct($x, $y) {
	    $this->x = $x;
	    $this->y = $y;
	}
	
	public function add() {
	    return $this->x + $this->y;
	}
}

try {
    (new Math(3, "nonsense"))->add();
} catch (Error $e) {
    echo "Look, I'm Python!";
}</code>

This will output "Look, I'm Python!".

==== Similarities to HHVM ====

The type system in HHVM uses matching syntax. In fact, an example taken from the [[https://docs.hhvm.com/hack/types/type-system|HHVM Type System]] works perfectly with this implementation:

<code php>
class A {
  protected float $x;
  public string $y;

  public function __construct() {
    $this->x = 4.0;
    $this->y = "Day";
  }
  public function foo(bool $b): float {
    return $b ? 2.3 * $this->x : 1.1 * $this->x;
  }
}

function bar(): string {
  // local variables are inferred, not explicitly typed
  $a = new A();
  if ($a->foo(true) > 8.0) {
    return "Good " . $a->y;
  }
  return "Bad " . $a->y;
}

var_dump(bar()); // string(8) "Good Day"
</code>

Whilst the syntax is almost identical, this works a little differently to Hack.

Hack a offers static analysis tools to detect mismatched types, but when the code is executed it will allow any type to be passed through. This implementation is done at compile time to avoid the need for this, but static analysis tools and editors/IDEs will no doubt catch up.

==== Other Languages ====

Of course, while "But Xlang does it!" is never a strong reason to do anything, it is sometimes nice to know how our friends are doing it in other languages.

  * [[https://docs.hhvm.com/hack/types/type-system||Hack/HHVM]] - See similarities above.
  * [[https://en.wikipedia.org/wiki/Property_(programming)#C.23|C#]]
  * [[https://en.wikipedia.org/wiki/Property_(programming)#C.2B.2B|C++]]
  * [[https://en.wikipedia.org/wiki/Property_(programming)#D|D]]
  * [[https://en.wikipedia.org/wiki/Property_(programming)#Delphi.2FFree_Pascal|Delphi/Free Pascal]]
  * [[https://en.wikipedia.org/wiki/Property_(programming)#ActionScript_3.0|ActionScript]]
  * [[https://en.wikipedia.org/wiki/Property_(programming)#Visual_Basic|Visual Basic]]

==== Syntax ====

Considering alternatives for this syntax could get a little whacky.

One approach could be to match how return types are done with a colon after the name of the declaration, which is also how Delphi and ActionScript handle things:

<code php>
public $bar: int;
public $bar: int = 2;
</code>

Not great, the assignment in the declaration looks like it's assigning to `int`.

We could switch that around:

<code php>
public $bar: int;
public $bar = 2: int;
</code>

Unfortunately now it looks a bit inconsistent with itself. Sure it's "at the end", but after bar or after assignment will add an element of consideration that many wont like.

Or maybe we can copy VisualBasic:

<code php>
public $bar as int;
public $bar = 2 as int;
</code>

Erf. That sticks out a bit, we don't do this anywhere else.

The current patch seems the most consistent with popular languages, avoids new reserved words, skips syntax soup and looks great regardless of assignment being used or not.

==== Weak or Strict ====

Unlike Type Hints and Return Types, there is no concept of weak or strict for this feature.

Explain further...

==== Performance ====

Using a typed property is a tiny bit more expensive than using a mixed property, but this loss will be recovered by avoiding the need for a bunch of boilerplate userland code to check types are the correct type.

===== Backward Incompatible Changes =====
None

===== Proposed PHP Version(s) =====
PHP 7.1

===== RFC Impact =====
==== To SAPIs ====
None

==== To Existing Extensions ====
None

==== To Opcache ====
Opcache has been patched, needs review.

===== Open Issues =====

  - The void keyword is currently supported for types, but should it? Not sure what the use cases are. Hack people might have some input on this.
  - There is a question around temporary nullability, with a concern that if an object is initialized and properties are not set at the end of the constructor, it should error. Currently it errors if you try to use the unset property instead? Pros/Cons undecided.

For example:

<code php>
class Foo {
    public int $foo;
} 
$foo = new Foo(); // Some would expect error here
echo $foo->foo; // Patch currently errors here
</code>


===== Future Scope =====

==== Union Types / Nullable ====

This RFC intentionally avoids the quagmire that is union types or nullable types. For example: if you specify an array, then you have to provide an array, and null will return an error. 

Future RFCs could take this on, with some `public ?array $foo;` syntax, or with union types providing `public array|null $foo;` syntax. This is just something we don't need to get into at this point. It is consistent with return types, if you specify `array` and return `null`, that too will error.

==== Typed Local Variables ====

This is an entirely different feature, and something not worth conflating into this RFC. The idea might be wanted, but to keep things simple it will not be discussed in this RFC.

==== Typed Constant Properties ====

There is currently no known value in adding a type to a constant. Seeing as constants cannot be modified, the type is just whatever the constant is set to, and seeing as it cannot change there is no chance for a constant to be assigned a invalid value afterwards.

===== Proposed Voting Choices =====

This RFC requires a 2/3 majority.

===== Patches and Tests =====

This branch will be cleaned up with feedback and squashed, and doubtlessly more tests will be provided as people seek clarification on functionality.

https://github.com/php/php-src/compare/master...krakjoe:typed-properties

===== References =====

