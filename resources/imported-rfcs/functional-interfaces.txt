====== PHP RFC: Functional Interfaces ======
  * Version: 0.1
  * Date: 2016-04-17 
  * Author: krakjoe
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/functional-interfaces

===== Introduction =====
A functional interface is an interface which declares only one abstract method, a familiar example is Countable:

<code>
<?php
interface Countable {
    public function count();
}
?>
</code>

Such interfaces are also known as SAM (Single Abstract Method) interfaces.

[[http://martinfowler.com/bliki/MinimalInterface.html|Minimal interface]] API design commonly leads to developers preferring to create many functional or SAM interfaces, over creating large, complex interfaces.

While the language has a few examples, the ecosystem has many many more.

===== Proposal =====
A closure is able to provide a way to implement a functional interface:

<code>
<?php
interface IFoo {
    public function method() : int;
}

$cb = function () implements IFoo : int {
    return 42;
};
</code>

There is enough information in the code above for the compiler to reason that $cb should implement IFoo, and obviously be a Closure.

The engine generates the appropriate class entry using the closure as the only public method, having easily determined the correct name for that method (there is, and can only be, only one possible candidate).

This is extremely powerful, because Closures have lexical scope, and so unlike an anonymous class, can access the private properties and other symbols where the Closure is declared.

The code below is not good code, it's not the most efficient version of the code that could exist. It serves to show the difference between implementing a functional interface using a closure, and provides a comparison with anonymous classes:

[[https://3v4l.org/b4AWq/rfc#tabs|Functional Interfaces - Counter Example]]

<code>
<?php
class Foo {
	private $bar = [];

	public function fill($limit = 100) {
		for ($i = 0; $i < $limit; $i++) {
			$this->bar[] = mt_rand($i, $limit);
		}
	}

	public function getEvenCounter() : Countable {
		return function () implements Countable {
			$counter = 0;
			foreach ($this->bar as $value) {
				if ($value % 2 === 0)
					$counter++;
			}
			return $counter;
		};
	}

	public function getOddCounter() : Countable {
		return function () implements Countable {
			$counter = 0;
			foreach ($this->bar as $value) {
				if ($value % 2 !== 0) {
					$counter++;
				}
			}
			return $counter;
		};
	}
}

$foo = new Foo();

$even = $foo->getEvenCounter();
$odd = $foo->getOddCounter();

$it = 0;

while (++$it<10) {
	$foo->fill(50);
	var_dump(
		count($even),
		count($odd));
}
?>
</code>

The same code using anonymous classes:

<code>
<?php
class Foo {
	private $bar = [];

	public function fill($limit = 100) {
		for ($i = 0; $i < $limit; $i++) {
			$this->bar[] = mt_rand($i, $limit);
		}
	}

	public function getEvenCounter() : Countable {
		return new class($this->bar) implements Countable {
			public function __construct(&$bar) {
				$this->bar =& $bar;
			}

			public function count() {
				$counter = 0;
				foreach ($this->bar as $value) {
					if ($value % 2 === 0)
						$counter++;
				}
				return $counter;
			}

			private $bar;
		};
	}

	public function getOddCounter() : Countable {
		return new class($this->bar) implements Countable {
			public function __construct(&$bar) {
				$this->bar =& $bar;
			}

			public function count() {
				$counter = 0;
				foreach ($this->bar as $value) {
					if ($value % 2 !== 0) {
						$counter++;
					}
				}
				return $counter;
			}

			private $bar;
		};
	}
}

$foo = new Foo();

$it = 0;

$even = $foo->getEvenCounter();
$odd = $foo->getOddCounter();

while (++$it<10) {
	$foo->fill(50);

	var_dump(
		count($even),
		count($odd));
}
?>
</code>

The anonymous class version:

  * must use referencing, or fetch a new iterator on each iteration, 
  * is extremely verbose
  * must set dependencies in the constructor
  * has no support for lexical scope

The functional interface version:

  * is sparse
  * is easier to reason about
  * does not require the use of references
  * supports lexical scope

Functional interface implementations have the behaviour of both the interface they are declared to implement, and a Closure; This means they can be called as if they are a closure, or as a normal object, and can also be rebound.

===== Backward Incompatible Changes =====
N/A

===== Proposed PHP Version(s) =====
7.1

===== RFC Impact =====

==== To Existing Extensions ====
Extensions will be able to provide implementations of functional interfaces as part of their API.

==== To Opcache ====
Opcache may need a trivial patching.

===== Open Issues =====
TBD

===== Future Scope =====
This sections details areas where the feature might be improved in future, but that are not currently proposed in this RFC.

===== Proposed Voting Choices =====
2/3 majority required, simple yes/no vote proposed.

===== Patches and Tests =====

https://github.com/php/php-src/pull/1866

===== 3v4l =====

3v4l have been kind enough to provide testing facilities for this patch.

===== References =====
Links to external references, discussions or RFCs