====== PHP RFC: Covariant Returns and Contravariant Parameters ======
  * Version: 0.2
  * Date: 2018-09-20
  * Author: Levi Morrison <levim@php.net>
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/covariant-returns-and-contravariant-parameters

===== Introduction =====
Currently PHP has mostly invariant parameter types and mostly invariant return types. This means that if a method of a super-type has a parameter or return type constraint of ''T'' then the corresponding parameter or return type constraint of method of the sub-type must also be ''T''. However, PHP does special case a few things such as removing a type constraint on a parameter or adding one where one didn't exist for a return type; here is an example of both cases:

<PHP>interface A {
  function m(B $z);
}
interface B extends A {
  // permitted
  function m($z): A;
}</PHP>

However, PHP does not permit choosing less specific parameter types or more specific return types even though these substitutions are type-safe:

<PHP>interface X {
  function m(Y $z): X;
}
interface Y extends X {
  // not permitted but type-safe
  function m(X $z): Y;
}</PHP>

This RFC aims to support these additional cases. 

===== Proposal =====
When determining the compatibility of an overridden method with its parent's the engine should now permit less specific parameter types and more specific return types as long as the new types are compatible with the types specified by the parents.

This RFC will also fix [[https://bugs.php.net/bug.php?id=76451|Bug #76451: Aliases during inheritance type checks affected by opcache]].

This RFC adds variance support to the ''object'' type. Variance on the object type was previously rejected when the ''object'' type was added, presumably on the grounds it should be added when variance is made more general, which is the purpose of this RFC.

==== Examples ====

Covariant return type with ''object'':

<PHP>interface Factory {
    function make(): object;
}

class UserFactory implements Factory {
    function make(): User;
}
</PHP>

Contravariant parameter type with ''iterable'':
<PHP>interface Concatable {
    // pehaps code that existed before iterable was added
    function concat(Traversable $input); 
}

class Collection implements Concatable {
    // accepts all iterables, not just Traversables
    function concat(iterable $input) {/* . . . */}
}
</PHP>

==== Auto-loading and Order of Definition Issues ====

Consider the following code, all of which is defined in the same file:

<PHP>
interface Collection extends Countable, IteratorAggregate {
  function getIterator(): Iterator;
}

class Vector implements Collection {
  function getIterator(): VectorIterator;
}

class VectorIterator implements Iterator {
  /* . . . */
}
</PHP>

Just after the definition of the ''class Vector'' the engine emits an opcode to verify the newly defined class. It does a few things, but relevant to this RFC it will need to verify that ''VectorIterator'' is a subtype of ''Iterator''. When return types were initially proposed this would trigger an auto-load of ''VectorIterator'', which will fail as ''VectorIterator'' is defined later on in the file. This behavior was unacceptable to me (the RFC author) and so I pulled that functionality.

To solve this, I plan to delay the verification of multiple consecutive type definitions until after the last type definition. There are a few ways to implement this. My current approach groups multiple type declarations at the grammar level. I think this can be extended to include any declaration statements, but any expressions would create a break point. The engine will emit opcodes to load the necessary types used in variance just before it emits the type verification opcodes.

For our example above, no types will need to be auto-loaded as all involved types have been declared in the file. Therefore the engine emits something like this:

<PHP>
interface Collection extends Countable, IteratorAggregate {
  function getIterator(): Iterator;
}
// Collection did not need any runtime variance checks,
// so emit its verification instead of delaying it
// verify Collection

class Vector implements Collection {
  function getIterator(): VectorIterator;
}
// Needs a runtime check on VectorIterator <: Iterator
// so delay its verification

class VectorIterator implements Iterator {
  /* . . . */
}

// auto-load any types needed for variance checks that
// weren't defined (none in this case)
// verify Vector
// verify VectorIterator
</PHP>

===== Backward Incompatible Changes =====
There are no intended incompatibilities. All incompatibilities should be reported and treated as bugs.

===== RFC Impact To Existing Extensions ====
TODO: New functions and macros should be introduced to make working with variant types in C easier.

===== Proposed PHP Versions =====
This RFC targets PHP 7.NEXT (currently PHP 7.4) because it does not have any known compatibility issues.

===== Voting =====
This RFC requires two-thirds of voters to select "yes" for this RFC to pass.

<doodle title="Accept Covariant Returns and Contravariant Parameters?" auth="levim" voteType="single" closed="true">
   * Yes
   * No
</doodle>

===== Future Scope =====
A future RFC may consider other super-types for existing types:

  * ''mixed'': includes all types that exist or will ever exist including null; this matches our usage of mixed in our documentation.
  * ''scalar'': includes bool, int, float, and string; this matches our ''is_scalar'' function.
  * ''numeric'': this probably needs even more discussion because ''is_numeric'' does not deal exclusively with types: it also checks string values.

===== Patches and Tests =====
TODO: publish WIP branch.

===== Implementation =====
After the project is implemented, this section should contain 
  - the version(s) it was merged into
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature
  - a link to the language specification section (if any)

===== References =====
Links to external references, discussions or RFCs.
