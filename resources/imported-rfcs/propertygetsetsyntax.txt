====== Request for Comments: Property get/set syntax ======
  * Version: 0.1
  * Date: 2009-09-13
  * Author: Dennis Robinson <president at basnetworks dot net>
  * Status: In the works

===== Forward =====

Variables that are attached to a class, commonly known as "class members", are sometimes referred to as "properties" in PHP.  In order to avoid confusion, from here on forward, variables attached to a class shall be called "class members", while they syntax proposed in this article will be the only thing called a "property".

===== Introduction =====

**Please do not read this RFC yet, as it is not complete.  Thanks.**

==== What Are Properties? ====

Properties provide a clean, easy to understand, and unified syntax for get/set accessors.  The allow incoming and outgoing requests (gets and sets) from a class member to be run through a method first.  This method can perform validation or a transformation, or update other areas of the class.  Properties do not even have to be associated with a class member, and can generate their own data on-the-fly.

==== The Problem ====

Currently, to emulate properties and practice class encapsulation, properties must be implemented in userland, as a pair of "get" and "set" methods.  Get and set methods are a common programming practice when using classes and encapsulation.  In userland, one might create a method in a class called GetMyVar() which will return the contents of a private variable called $myVar.  This way, someone using the class can only read or "get" the variable, but not write or "set" it.  This gives the class designer the guarantee that the contents of $myVar wont be tampered with.  Similarly, one might create a method in that class called SetMyVar() which takes one parameter, and stores it in $myVar.  Additionally, one might add some kind of validation in this method, to ensure that only the right kind of data will be stored in $myVar.  It is easy to see how get and set methods quickly become useful.  However, instead of accessing a property $object->myVar; you now have to use a set of methods instead: $myVar->Get(); $myVar->Set('test');.

==== The Current Solution ====

PHP's current solution to get and set accessors are the magic methods %%__%%get() and %%__%%set().  These methods allow the properties to be created, but all of the "get" calls are routed through a single function, as are the "set" calls.

This works great for this type of situation:

<code php>
class TimeSheet
{
    // An array full of times in seconds
    private $time_list;

    public function __get($key)
    {
        // Return the time in hours, not seconds
        return $this->time_list[$key] / 3600;
    }

    public function __set($key, $value)
    {
        // Store the time in seconds, not hours
        $this->time_list[$key] = $value * 3600;
    }
};

$sheet = new TimeSheet();
$sheet->foo = 12;// Stored as 43200
echo $sheet->foo;// Outputs 12
</code>

In the above example, the TimeSheet class can store a set of time periods.  When accessing the properties of the class, you give and receive hours, yet the time periods are stored as seconds in the $time_list array.  %%__%%get() and %%__%%set() work great here because the same code is applied to every property.

What if we want totally different code to apply to each property?

<code php>
class TimePeriod
{
    // A time period, stored as seconds
    private $seconds;

    public function __get($key)
    {
        switch ($key)
        {
            case 'seconds':
                return $this->seconds;
            break;

            case 'minutes':
                return $this->seconds / 60;
            break;

            case 'hours':
                return $this->seconds / 3600;
            break;
        }

        return null;
    }

    public function __set($key, $value)
    {
        switch ($key)
        {
            case 'seconds':
                $this->seconds = $value;
            break;

            case 'minutes':
                $this->seconds = $value * 60;
            break;

            case 'hours':
                $this->seconds = $value * 3600;
            break;
        }
    }
};

$time = new TimePeriod();
$time->seconds = 12;// Stored as 12
$time->minutes = 12;// Stored as 720
$time->hours = 12;// Stored as 43200
echo $time->seconds;// Outputs 43200
echo $time->minutes;// Outputs 720
echo $time->hours;// Outputs 12
</code>

In the above example, the code of the %%__%%get() and %%__%%set() methods quickly becomes very large, complicated, and difficult to read.  Imagine how cumbersome the code would get adding the properties days, weeks, months, and years.  What if we also wanted to add some other properties?

**__Broken Inheritance__**

Now what happens if a second class extends this class.  If the extending class were to define an empty %%__%%get() and %%__%%set() method, the properties would cease to exist in the child class.  This goes against the principles of inheritance, as something that once existed in the parent, no longer does in the child.  By using properties, once a property is defined, it is guaranteed to exist in all child classes, with the same or greater visibility.

===== Properties in C# =====

==== Why do we care about C#? ====

The current implementations of getters and setters, or properties in various programming languages are almost all have a different syntax.  In order to avoid confusing users, an existing syntax should be followed as closely as possible.  C#'s syntax is often similar to PHP's making it a good reference point.  Additionally, C# has a clean, clear and easily scanned syntax for properties.

==== C# Syntax ====

The syntax for properties in C# is as follows:

<code C#>
class TimePeriod
{
    private double seconds;

    public double Hours
    {
        get { return seconds / 3600; }
        set { seconds = value * 3600; }
    }
}
</code>

<code C#>
TimePeriod time = new TimePeriod();

// Assigning the Hours property causes the 'set' accessor to be called.
time.Hours = 24;

// Evaluating the Hours property causes the 'get' accessor to be called.
System.Console.WriteLine("Time in hours: " + time.Hours);
</code>

===== Syntax =====

==== Basic Syntax ====

This is the recommendation for a property syntax in PHP.

<code php>
class TimePeriod
{
    private $seconds;

    public property Hours
    {
        get { return $this->seconds / 3600; }
        set { $this->seconds = $value * 3600; }
    }
};
</code>

<code php>
// Accessing the property is the same as accessing a class member
$time = new TimePeriod();
$time->Hours = 12;// Stored as 43200
echo $time->Hours;// Outputs 12
</code>

==== Read-Only And Write-Only Properties ====

A property can be read-write, read-only or write-only.  This example shows the latter two.

<code php>
class TimePeriod
{
    private $seconds;

    public property Minutes
    {
        set { $this->minutes = $value * 60; }
    }

    public property Hours
    {
        get { return $this->seconds / 3600; }
    }
};
</code>

<code php>
$time = new TimePeriod();
$time->Minutes = 720;// Stored as 43200
$time->Hours = 12;// Error, this property is read-only
echo $time->Hours;// Outputs 12
echo $time->Minutes;// Error, this property is write-only
</code>

**__What about the readonly keyword?__**

There has been talk about adding a "readonly" keyword to class members in PHP, so why not use it to define read-only properties?  The short answer is, they are not exactly the same thing.  When a property without a set method (a "read-only" property) is overloaded in a child class, the set method can then be implemented and used.  However, if that property was set to read-only using the readonly keyword, the child class would not be allowed to implement a set method.

Additionally, there is no talk of a "writeonly" keyword for PHP, so write-only properties would not be possible.

==== Asymmetric Accessor Accessibility ====

Properties can have different levels of visibility for the get and set methods.  This is achieved by setting either the get or set method to a lower visibility than the property is set to.

<code php>
class TimePeriod
{
    private $seconds;

    public property Hours
    {
        get { return $this->seconds / 3600; }
        protected set { $this->seconds = $value * 3600; }
    }
};
</code>

<code php>
$time = new TimePeriod();
$time->Hours = 12;// Stored as 43200
echo $time->Hours;// Error, this property is read-only
</code>

==== Interface Properties ====

Interfaces may define property declarations, without a body.  The purpose of this is to define properties that must exist in an implementing class, and indicate if they are read-write, read-only, or write-only.

When a class implements an interface that has a read-only property, it can add in a set method to turn the property into a read-write property.  The inverse is also true for implementing an interface with a write-only property.  This is because interfaces are to enforce what //should be// in a class, and not what //should not be// in a class.

<code php>
interface ISampleInterface
{
    public property MyProperty
    {
        get;
        set;
    }

    public property MyReadOnlyProperty
    {
        get;
    }

    public property MyWriteOnlyProperty
    {
        set;
    }
};
</code>

==== Overloading Properties ====

Properties can be overloaded in extending classes.  An overloaded property can replace an existing get or set declaration without touching the other, replace both the get and set declarations, or add an omitted get or set declaration turning the property into a read-write property.  Additionally, a property may have its visibility increased through overloading.  Get or set declarations cannot be removed by the child class in any way.

<code php>
class TimePeriod
{
    protected $seconds;

    public property Hours
    {
        get { return $this->seconds / 3600; }
        set { $this->seconds = $value * 3600; }
    }

    // This property is read-only
    public property Minutes
    {
        get { return $this->seconds / 60; }
    }

    public property Milliseconds
    {
        // This method is public
        get { return $this->seconds * 60; }
        // This method is protected
        protected set { $this->seconds = $value * 3600; }
    }
};

class HalfTimePeriod extends TimePeriod
{
    public property Hours
    {
        // The get method is being overloaded
        get { return ($this->seconds / 3600) / 2; }
        // Notice that we are not also overloading the set method
        // The base set method will still be called
    }

    public property Minutes
    {
        // A set method is adding, turning this property into a read-write property instead of read-only
        set { $this->seconds = $value * 60; }
    }

    public property Milliseconds
    {
        // A property method can be made more visible in a child class, just like regular PHP methods
        // This method is now public instead of private
        public set
        {
            // You can access a base class property explicitly, just like accessing a base class member or method
            TimePeriod::$Milliseconds = $value;
        }
    }
};
</code>

==== Static Properties ====

Static properties act nearly identical to regular properties, except in a static context.

<code php>
class TimePeriod
{
    private static $seconds;

    public static property Hours
    {
        get { return self::$seconds / 3600; }
        set { self::$seconds = $value * 3600; }
    }
};
</code>

<code php>
// Accessing the static property is the same as accessing a static class member
TimePeriod::$Hours = 12;// Stored as 43200
echo TimePeriod::$Hours;// Outputs 12
</code>

===== References =====

  * [[http://bugs.php.net/bug.php?id=49526|PHP Bugs: #49526: C# style property get/set syntax]]
  * [[http://bugs.php.net/bug.php?id=34194|PHP Bugs: #34194: Real properties in PHP classes]]
  * [[http://wiki.php.net/summits/pdmnotesmay09#php_6|PDM Notes: May 2009 (See point #16)]]

===== Further Reading =====

  * [[http://en.wikipedia.org/wiki/Property_%28programming%29#PHP|Properties in programming (Wikipedia)]]
  * [[http://en.wikipedia.org/wiki/Mutator_method|Mutator methods (Wikipedia)]]
  * [[http://msdn.microsoft.com/en-us/library/x9fsa0sw%28VS.80%29.aspx|Properties (C# Programming Guide)]]
  * [[http://msdn.microsoft.com/en-us/library/75e8y5dd%28VS.80%29.aspx|Asymmetric Accessor Accessibility (C# Programming Guide)]]

===== Changelog =====

  - 2009-09-13 Dennis Robinson: Initial creation.
