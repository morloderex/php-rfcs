====== PHP RFC: Add validation functions to filter module ======
  * Version: 0.9
  * Date: 2016-08-03
  * Author: Yasuo Ohgaki <yohgaki@ohgaki.net>
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/add_validate_functions_to_filter

===== Introduction =====

Input data validation is the most important security measure in software security. 

  * [[https://www.securecoding.cert.org/confluence/display/seccode/Top+10+Secure+Coding+Practices|CERT Top 10 Secure Coding Practices]]
  * [[https://www.owasp.org/index.php/OWASP_Secure_Coding_Practices_-_Quick_Reference_Guide|OWASP Secure Coding Practices -Quick Reference Guide]]

These recommends input validation by whitelist and reject invalid. 

We have filter module for this purpose, but it has problems
  * Functions are designed to "filter/convert value and accept" basically even with validation filter.
    * Allow undefined input (empty element in input array) by default.
    * They converts invalid values to NULL/FALSE and makes it difficult to identify validation error. This is especially a problem with array value validation.
    * Input validation must pass under normal condition. Validation error should result in exception error, but they are not.
  * String validation filter is missing even if string is the most dangerous input.
  * Multiple validation filters are not allowed. There are cases that we would like to use multiple filters, especially for strings. e.g. Check string length and encoding check, then perform regex check.

==== Secure coding basics ====

A fundamental idea of secure coding is input and output control. Proposed new functions are supposed to use for input validations, not for input error check in business logic.

Input data validation is better to think as input data assertion which should never fail under normal circumstances. Nature of input validation is differ from wrong input data handling from users which would happens normal conditions. User input mistakes, logically inconsistent data, e.g. date is past date for reservations, should not handled by input data validation part, but in business logic.

{{:rfc:screenshot_from_2016-08-05_14-24-16.png?800|}}

**WARNING: Input and output handling is independent. Output code is responsible to make sure output is safe for external computer/software. Output data should be safe regardless of input validation. i.e. Programmer must escape/use secure API/validate all output data always.**

What programmers should do for input validation(assertion) is to detect and reject:

  * Broken char encoding
  * NUL, etc control chars in string.
  * Too long or too short string. e.g. JS validated values and values set by server programs like <select>/<input type=radio>/etc, 100 chars for username, 1000 chars for password, empty ID for a database record, etc.
  * Too large or too small numerics. i.e. Int/float/bool value
  * Too many or too few inputs. 
  * Broken number string for a database record ID.
  * Broken flags. i.e. Bool value
  * Newline chars in <input>, hash value, etc.
  * Broken string/data format. e.g. JS validated phone number, list items such as country names, date string, etc.
  * and so on.

Not all of them can be validated at input validation. How/what input could be validated is depended on input source spec. For example, if you do client side validation in your system, you can validate strings strictly. e.g. Date string. If you don't do client side validation at all and using plain <input> for date, your validation code cannot do much. However, a string over 100 chars, string contains control char(s) or broken char encoding for date is good enough to be rejected as a invalid input.

Dividing input data validation and user input mistake handling makes software simpler and easier to maintain. Input data format is more stable than business logic by nature. e.g. Object interface is more stable than object implementation. Simplicity and maintainability is important for security also. 

The most important input validation is application level validation, but input validation is not limited to it.

{{:rfc:screenshot_from_2016-08-05_11-25-01.png?800|}}


Please refer to mentioned secure cording practices, [[https://en.wikipedia.org/wiki/Design_by_contract|Design by Contract(DbC)]] for more details.

===== Proposal =====

Followings are filter module improvement proposals.

====Add validation functions====

  * Add filter_assert_array()/filter_assert_input_array()/filter_assert()/filter_assert_input()

<code php>
array filter_assert_array ( array $data , mixed $definition [, bool $add_empty = false ] )
mixed filter_assert ( mixed $variable , int $filter [, mixed $options ] )
array filter_assert_input_array ( int $type , mixed $definition [, bool $add_empty = false ] )
mixed filter_assert_input ( int $type , string $variable_name , int $filter [, mixed $options ] )
</code>

They are almost the same as filter_*() functions. Key differences compared to filter_*() functions are:

  * Raise UnexpectedValueException when they detect invalid input.
  * Requires to define filter. (Default must be set by user)
  * Conservative default. Empty element is not added by default. 

NOTE: Main motivation of adding these functions is "filter_var_array()/filter_input_array() is not suitable for strict input validation". See Discussion section.

  * Add filter_check_definition() - Check definition array for filter_assert_*_array()/filter_*_array()

Filter definition error is silently ignored for performance reason. Definition error could be fatal bug. This function provides check feature finds typo, format error.

Limitations:
  * filter_check_definition() only checks format, not semantics. i.e. It does not check if options/flags are suitable for filter.
  * Callback filter can be used for validations, but it is users' responsibility to raise UnexpectedValueException when there is validation error.
  * filter_assert_*() functions share filter_*() function's validation filter. Therefore, 
    * filter_assert_*() functions do not keep input data type. Data type is changed according filter used. i.e. INT/FLOAT/BOOL filters convert data type.
    * FILTER_VALIDATE_INT/FILTER_VALIDATE_FLOAT/FILTER_VALIDATE_BOOLEAN validation trims spaces and converts to int/float/bool type. 
    * FILTER_VALIDATE_INT validation converts base 10, base 8(FILTER_FLAG_ALLOW_OCTAL), base 16(FILTER_FLAG_ALLOW_HEX) integer values to int type. In addition, it detects overflow, so be careful when your program must run nicely on both 32 and 64 bit architecture. NOTE: One must not use FILTER_VALIDATE_INT for database record ID validation. Use string validation filter and FILTER_VALIDATE_STRING_NUM.
    * FILTER_VALIDATE_BOOLEAN validation converts 1/true/yes/on(case insensitive) to TRUE, 0/false/no/off(case insensitive) to FALSE.
    * Data type conversions is good for 'declare(strict_types=1)' ZendEngine switch, so it is retained.
  * Since Exception terminates execution where it is raised, return value from filter_assert_*() function is not usable when validation exception is raised. See the example code in "Allow multiple filters for an input" section.


====Allow multiple filters for an input====

Example is easier to understand. New filter module allows multiple filters for both validation/sanitize filters.

<code php>
    <?php
    // Following initialization is to illustrate exception handling.
    $myinput = array(
        'some' => 'initialization',
        'or' => 'could be return value from previous validation',
    );
    
    $args = array(
        'date'    =>
        array(
                // New filter module allows multiple filters and options as follows.
                // Array elements are evaluated in order. Non array spec is evaluated last.
                // Older implementation ignores this kind of spec silently.
                array( // This is evaluated first.
                        'filter'    => FILTER_VALIDATE_STRING,
                        'options'   => array('min_bytes' => 10, 'max_bytes' => 10)
                ),
                array(
                        'filter' => FILTER_VALIDATE_REGEXP,
                        'options' => array('regexp' => '/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/')
                ),
                array(
                        'filter' => FILTER_VALIDATE_CALLBAK,
                        'options' => array('callback' => 'check_date_and_raise_exception_for_invalid()'),
                ),
                'filter' => FILTER_UNSAFE_RAW, // Evaluated last. Does nothing. It's here for an example.
        ),
    );
    
    // Throws UnexpectedValueException for invalid inputs.
    try {
        $myinputs = filter_assert_var_array($data, $args);
        // NOTE: If you need returned array value, it MUST be inside try block
        //       or catch block MUST terminate execution. Otherwise, returned value
        //       may contain irrelevant values.
        var_dump($myinputs); 
    } catch (UnexpectedValueException $e) {
        var_dump($e->getMessage());
        die('Invalid input detected!'); // Should terminate execution when input validation fails
    }
    // If validation exception is raised and catch block didn't terminate script,
    // $myinputs will have irrelevant value from previous initialization.
    var_dump($myinputs); 
</code>


====Add string validation filter====

Add missing string validation filter (FILTER_VALIDATE_STRING). This filter has conservative default. i.e. Strict validation by default. 

Features:
  * Validate string as UTF-8 by default. (Only UTF-8 is supported. Use FILTER_STRING_ENCODING_PASS encoding option to disable encoding check)
  * min_bytes/max_bytes options for string length. min_bytes default is 1, max_bytes default is 90.
  * 'allowed_chars' option can specify allowed chars. (Only works for code value less than 127)
  * Single line is allowed by default. Use FILTER_FLAG_STRING_MULTI_LINE flag to allow multi line (\r, \n) inputs.
  * Control char other than TAB(\t) is not allowed by default. Use FILTER_FLAG_STRING_ALLOW_CNTRL flag or 'allowed_chars' option to specify allowed chars whitelist.
  * FILTER_FLAG_STRING_ALPHA to allow only alphabet
  * FILTER_FLAG_STRING_NUM to allow only number(digit)
  * FILTER_FLAG_STRING_ALNUM to allow only alphanumeric 

Limitations:
  * UTF-8 only.
  * Chars control is limited code less than 127. (Only ASCII chars) 
  * Error message is not friendly.

===== Discussions =====

== Why it should be in core? ==

Input validation is the most important security feature. PHP should provide easy to use/reliable/fast input validation feature. We should encourage strict input validation that rejects invalid(attacker) inputs by having stricter input validation features rather than filter(convert) and accept.

== Why not compare filter_var_array() result? ==
Following code may seem to work, but it would not.

<code php>
$ret = filter_var_array($arr, $validation_spec);
if ($ret != $arr) {
  die('Input does not validate');
}
</code>

  * One should never compare float equality. (Float string is converted to float type. Think of huge string value and result of float converted value comparison.)
  * They are filter(conversion) functions. e.g. URLs are converted to lowercase.
  * It allows empty input by default and add NULL element.
  * int/float/bool validation filters trim and convert type. (They cannot match by "==" comparison)

For these reasons, comparing original and return(filtered) value is not suitable for strict input validation.


===== Backward Incompatible Changes =====

None. filter_*() functions are not changed at all.

===== Proposed PHP Version(s) =====

7.1.0

===== RFC Impact =====
==== To SAPIs ====
None

==== To Existing Extensions ====
None

==== To Opcache ====
None

==== New Constants ====

  * FILTER_STRING_ENCODING_PASS - string validation filter encoding
  * FILTER_STRING_ENCODING_UTF8 - string validation filter encoding
  * FILTER_FLAG_STRING_RAW - string validation filter flag
  * FILTER_FLAG_STRING_ALLOW_CNTRL - string validation filter flag
  * FILTER_FLAG_STRING_MULTI_LINE - string validation filter flag
  * FILTER_FLAG_STRING_ALPHA - string validation filter flag
  * FILTER_FLAG_STRING_NUM - string validation filter flag
  * FILTER_FLAG_STRING_ALNUM - string validation filter flag

==== php.ini Defaults ====
No changes

===== Open Issues =====
Make sure there are no open issues when the vote starts!

===== Unaffected PHP Functionality =====
Existing filter features are not changed at all.

===== Future Scope =====

===== Proposed Voting Choices =====
This project requires a 2/3 majority



===== Patches and Tests =====

  * https://github.com/php/php-src/pull/2048


===== Implementation =====
After the project is implemented, this section should contain 
  - the version(s) it was merged to
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature

===== References =====
Links to external references, discussions or RFCs

===== Rejected Features =====
Keep this updated with features that were discussed on the mail lists.