====== PHP RFC: Improve unserialize() error handling ======
  * Version: 1.0
  * Date: 2022-09-01
  * Author: Tim Düsterhus, timwolla@php.net
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/improve_unserialize_error_handling


===== Introduction =====

PHP's current error reporting in <php>unserialize()</php> is very inconsistent, making it hard to reliably handle errors that occur during unserialization.

Depending on how exactly the input string is malformed, PHP will emit an <php>E_NOTICE</php>, an <php>E_WARNING</php> or throw an arbitrary <php>\Exception</php> or <php>\Error</php> (or even a combination of all 4 options):

<PHP>
<?php

unserialize('foo'); // Notice: unserialize(): Error at offset 0 of 3 bytes in php-src/test.php on line 3
unserialize('i:12345678901234567890;'); // Warning: unserialize(): Numerical result out of range in php-src/test.php on line 4
unserialize('E:3:"foo";'); // Warning: unserialize(): Invalid enum name 'foo' (missing colon) in php-src/test.php on line 5
                           // Notice: unserialize(): Error at offset 0 of 10 bytes in php-src/test.php on line 5
unserialize('E:3:"fo:";'); // Warning: unserialize(): Class 'fo' not found in php-src/test.php on line 7
                           // Notice: unserialize(): Error at offset 0 of 10 bytes in php-src/test.php on line 7

try {
	unserialize('O:19:"SplDoublyLinkedList":3:{i:0;i:0;i:1;N;i:2;a:0:{}}');
} catch (UnexpectedValueException $e) {
	echo $e->getMessage(), PHP_EOL; // Incomplete or ill-typed serialization data
}

?>
</PHP>

To reliably these currently, the following code is required:

<PHP>
try {
    set_error_handler(static function ($severity, $message, $file, $line) {
        throw new \ErrorException($message, 0, $severity, $file, $line);
    });
    $result = unserialize($serialized);
} catch (\Throwable $e) {
    // Unserialization failed. Catch block option if the error should not be handled.
} finally {
    restore_error_handler();
}
</PHP>

In fact adding a custom error handler before calling <php>unserialize()</php> is the example used in the documentation page for <php>restore_error_handler()</php> (https://www.php.net/manual/en/function.restore-error-handler.php). 

===== Proposal =====

The proposed solution to the described problem consists of two parts:

==== New UnserializationFailedException ====

A new <php>\UnserializationFailedException</php> will be added. Whenever a <php>\Throwable</php> is thrown during <php>unserialize</php> (e.g. within an <php>__unserialize()</php> handler or because a throwing error handler converts <php>E_NOTICE</php>/<php>E_WARNING</php> into an <php>Exception</php>), this <php>\Throwable</php> will be wrapped into a new instance of <php>\UnserializationFailedException</php>.

This allows a developer to use <php>catch(\UnserializationFailedException)</php> (a) to catch all <php>\Throwable</php>s happening during unserialization and (b) to catch only <php>\Throwable</php>s that happen during unserialization without also catching unrelated <php>\Throwable</php>s.

The original <php>\Throwable</php> will be made available as the <php>$previous</php> property of <php>\UnserializationFailedException</php>, allowing the developer to learn about the actual cause of the unserialization failure by inspecting <php>->getPrevious()</php>.

Translated into simplified PHP code, the <php>unserialize()</php> implementation could look roughly like this with the proposal implemented:

<PHP>
function unserialize(string $data, array $options = []): mixed
{
    try {
        // The existing unserialization logic happens here.
    } catch (\Throwable $e) {
        throw new \UnserializationFailedException(previous: $e);
    }
}
</PHP>

==== Increase the error reporting severity in the unserialize() parser ====

Apart from unserialize handlers (e.g. <php>__unserialize()</php>) throwing, unserialization can also fail due to a syntax error in the input string and due to out-of-range integers and similar issues.

Currently these cases will not throw. Instead an <php>E_NOTICE</php> or an <php>E_WARNING</php> (or both!) are emitted depending on the type of error.

The severity of these should be unified, because the cases that emit an <php>E_NOTICE</php> are not any more or less actionable by the developer than the cases that emit <php>E_WARNING</php>.

Specifically the severity should be increased, because unserialization failing commonly implies that an untrusted input string is passed into <php>unserialize()</php> which is not something that should be done in the first place, as unserializing arbitrary classes might allow for remote code execution.

At the very least the <php>E_NOTICE</php> cases should be adjusted to emit an <php>E_WARNING</php> instead to consistently emit a <php>E_WARNING</php>.

However changing both <php>E_NOTICE</php> and <php>E_WARNING</php> to throw the new <php>\UnserializationFailedException</php> might be a better solution. For applications that use a throwing error handler, the <php>Throwable</php> thrown by the error handler for the <php>E_NOTICE</php> / <php>E_WARNING</php> will be handled by the mechanisms described in the previous section and thus will be wrapped into <php>\UnserializationFailedException</php>.

In other words: This would only affect applications that do not use a throwing error handler.

For these applications without a throwing error handler throwing an <php>\UnserializationFailedException</php> might be a steep increase in severity, however these applications already need to be prepared to handle <php>\Throwable</php>s thrown from an unserialize handler. The fact that an unserialization failure commonly indicates something unsafe also warrants that the operation fails “loudly”, instead of silently continuing. Furthermore consistently throwing the proposed <php>\UnserializationFailedException</php> allows the developer to benefit from the benefits of unified error handling as described in the previous section, even when they are not yet ready to use a throwing error handler.

===== Backward Incompatible Changes =====

==== Addition of a new exception class ====

The UnserializationFailedException will no longer be available. The query <code>symbol:UnserializationFailedException language:php</code> in GitHub's Code Search did not return any non-namespaced results, making this a theoretical issue.

==== Existing error handling for unserialize() might need to be updated ====

This is not considered an issue, because due to the inconsistency in error handling, the only safe solution to handle all possible errors during <php>unserialize()</php> is to <php>catch(Throwable)</php>. This continues to work as-is.

Every other solution is already broken in the face of untrusted input data, because (internal) classes can and will throw various types of <php>Exception</php> and <php>Error</php>. Examples of unsafe code includes:

  * <php>@unserialize()</php> (will fail if a class throws).
  * <php>catch(Exception)</php> (will fail for ext/date which throws <php>Error</php>s).
  * <php>catch(Error)</php> (will fail for various extensions which throw <php>Exception</php> or <php>UnexpectedValueException</php>).

Nothing will change for unserializing trusted, well-formed input strings, because unserialization will not fail for them by definition.

===== Proposed PHP Version(s) =====

Next PHP 8.x.

===== RFC Impact =====

==== To SAPIs ====

None.

==== To Existing Extensions ====

Existing extensions may update their error handling in the unserialize handlers to throw <php>Exception</php>s that best describe the type of error in the serialized data without needing to concern themselves with compatibility, because anything that is thrown will automatically be wrapped in the unified <php>\UnserializationFailedException</php>.

If an extension uses <php>unserialize()</php> internally then the safe backwards compatibility concerns as with userland code applies.

Extensions replacing the serializer by a custom serializer (e.g. igbinary) may need to be adjusted to ensure their behavior is consistent with the behavior of the default serializer.

==== To Opcache ====

None.

==== New Constants ====

None.

==== php.ini Defaults ====

None.

===== Open Issues =====

None.

===== Unaffected PHP Functionality =====


Anything that does not interact with <php>unserialize()</php>. Developers who interact with <php>__unserialize()</php>, <php>__wakeup()</php>, and <php>Serializable::unserialize()</php> might affected depending on what exactly they are doing with those.

===== Future Scope =====

None.

===== Proposed Voting Choices =====

==== Adding a wrapper Exception ====

2/3 required to implement <php>\UnserializationFailedException</php> that wraps any other <php>\Throwable</php>.

<doodle title="Add the UnserializationFailedException?" auth="timwolla" voteType="single" closed="false" closeon="2022-01-01T00:00:00Z">
   * Yes
   * No
</doodle>

==== Increasing the severity of existing warnings / notices ====

2/3 required to increase the severity of errors that do not currently throw.

<doodle title="Increase the severity for syntax errors in the serialized payload?" auth="timwolla" voteType="single" closed="false" closeon="2022-01-01T00:00:00Z">
   * Yes
   * No
</doodle>

If the previous vote ("increase severity") passes then the following vote will decide which severity should be used. A simple majority (50%+1) is required. In case of a tie the <php>E_WARNING</php> option will be used, as it is the more conservative option.

<doodle title="Increase the severity of errors in serialized payload to?" auth="timwolla" voteType="single" closed="false" closeon="2022-01-01T00:00:00Z">
   * UnserializationFailedException
   * E_WARNING
</doodle>

===== Patches and Tests =====

PoC: https://github.com/php/php-src/pull/9425

===== Implementation =====

n/a

===== References =====

  * https://externals.io/message/118311
  * https://github.com/php/php-src/pull/9425

===== Rejected Features =====

n/a