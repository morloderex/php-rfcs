====== PHP RFC: Big Integer Support ======
  * Version: 0.9.6
  * Date: 2014-06-20 (Initial; 2014-07-07 latest)
  * Author: Andrea Faulds, ajf@ajf.me
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/bigint

===== Introduction =====

Since the beginning, PHP has had only two numeric types: integer, and float. The former has been a platform-dependent C long, usually either 32-bit or 64-bit, and the latter has been a platform-dependent C double, usually an IEEE 754 double-precision floating-point number.

Both work relatively well, but beyond the maximum integer value on a specific platform, things get a bit messy. Typically, PHP will have integers overflow to floats, resulting in a loss of precision. Integer size is platform-specific, so code dealing with large integers won't act the same on a 32-bit machine versus a 64-bit machine.

Some applications need to deal with very large integers beyond 32-bit or 64-bit and for this they can resort to extensions like gmp. However, dealing with these so-called "big integers" or "bigints" is rather clumsy. You must write all your code to deal with them specifically, and you must create objects for them rather than simply using numeric literals like for the built-in integer and float types.

Hence, this RFC proposes the addition of built-in bigint support to PHP. Now, you can do operations with integers of any size, so long as you have enough memory. While there are now two types internally (long and bigint), userland code will continue to see only "integers", and the two types will be indistinguishable.

The advantages of doing this are numerous. Now integers will always be consistent across platforms, with programmers not needing to worry about the size of a long – 32-bit, 64-bit or otherwise – on their platform. Operations, too, will always be consistent. This will help the portability of PHP code and mean less time wasted by programmers dealing with platform differences, strengthening PHP's cross-platform guarantees. Dealing with extremely large data sets becomes easier, as you no longer need to anticipate if your IDs will exceed 32 or 64 bits. Integer overflow is largely relegated to being an issue for internals programmers, as userland code will never have to deal with it, and there is no risk of a loss of precision as they will no longer become floats. All this combined is likely to make for more robust, less buggy applications. Finally, being able to deal with large integers "natively" makes PHP more attractive for web developers needing to do large integer math, such as  applications dealing with currency, or perhaps statistical applications.

===== Proposal =====

==== New type ====

To complement the existing internal IS_LONG and IS_DOUBLE types, a new IS_BIGINT type is introduced. IS_BIGINT is a reference-counted, copy-on-write type which is not garbage collected, much like a string. Behind-the-scenes, the GNU Multiple Precision library (aka GMP) is used to implement it, but it is abstracted with a new family of zend_bigint_* functions and the zend_bigint type, meaning that theoretically another arbitrary-precision integer library could be used in its place if we so desired. As stated in the Introduction, no new userland type is added to PHP, and instead "integer" now covers two internal types: IS_LONG and IS_BIGINT. There should be **no visible difference** to userland code between these types. Internally, a new "fake type" is also added, namely IS_BIGINT_OR_LONG. This is used by a few functions dealing with conversions and casts, and is now the "type" that ''(integer)'' will cast to.

Type specifiers for zend_parse_parameters that previously yielded a long will continue to do so. If a bigint that is outside of the range of a long is passed when the function expects a long, an E_RECOVERABLE_ERROR is raised, which was inspired by Anthony Ferrara's [[rfc:scalar_type_hinting_with_cast|Scalar Type Hinting With Casts]] RFC and Python's ''OverflowError''s. A new type specifier for a bigint will be added, and I also would like to add a type specifier for either a bigint or a long, but I haven't done these parts yet.

==== Changes to operators for the sake of consistency ====

In order to make integer arithmetic consistent between longs and bigints, certain changes to existing operator behaviour will be made:

  * Bitwise operators will now deal with integers of any size (i.e. both longs and bigints) instead of being bounded by the size of a long on a machine.
  * Left shifts will promote to bigints rather than overflowing.
  * Currently, if you right shift a long by a number greater than its maximum number of bits, then the number of bits to shift by currently "wraps around" on some processors, e.g. ''>> 65'' is the same as ''>> 1'' on some 64-bit processors. This is counter-intuitive and couldn't be emulated with bigints (bigints have no maximum number of bits), so instead the sane thing will be done and ''>> 65'' will result in zero.
  * Both left shifts and right shifts currently support negative integers as shifts. If you try to do a negative shift, say ''<< -2'', what will actually happen is that the signed long (''-2'') is treated as an unsigned long, giving us some platform-dependent overflowed value (in the case of ''-2'', this would be ''18446744073709551614'' when long is 64-bit), which is then used as our shift. So, in our ''-2'' example, if ''3844938234'' was the number we were shifting, our result would be ''-9223372036854775808''. Make sense? I don't think so either. Shifting by a negative number will now throw a warning and evaluate to FALSE, much like dividing by zero.
  * The pow (''*''''*'') operator will now error when an exponent too large is used if it is dealing with an integer. This is because gmp can't handle exponents beyond the size of an unsigned long. This restriction will not occur when using the pow operator when either operand is a float.
  * Casting the special float value ''NaN'' to an integer will result in zero. I think this makes more sense compared to the current behaviour, where the result is the minimum value of a long (''LONG_MIN''), which would make no sense with the addition of bigints.

===== Backward Incompatible Changes =====

As mentioned before, the shift left and shift right operators act differently, as does pow for very large exponents.

Integers will no longer overflow to float, but instead become bigints (which, so far as userland cares, are just integers). Code expecting large integer literals to be floats will now end up with bigints instead, which might cause problems. However, if a float is still desired, this can be fixed simply by appending ''.0''.

Some internal APIs, mostly ones dealing with numbers, will necessarily change their signatures or behaviour. For example, is_numeric_string/_ex now takes a ''zend_bigint*''''*'' parameter, and the cast_object object handler now has to deal with IS_BIGINT_OR_LONG and IS_BIGINT. (However, I am wondering if I should remove the latter)

===== Proposed PHP Version(s) =====

This is proposed for the next PHP X, probably PHP 6. The patch is based off of phpng, and my intention is for it to be merged into phpng.

===== RFC Impact =====

==== Performance ====

The performance penalties //should// be only minor, however I have not yet benchmarked my patch. While left shifts and right shifts now require overflow checks, generally bigints will just take the place of floats in existing overflow checks so I don't expect there to be much performance impact.

==== Fatal errors ====

Unfortunately, bigints would introduce two new ways to cause fatal errors in PHP.

Firstly, if you do an operation resulting in an extremely large number, you might hit your request memory limit.

Secondly, when trying to calculate a value that would require more memory than size_t can describe, GMP prints the ''overflow in mpz type'' error to the command line and ''abort()''s. Allowing this to happen and kill the PHP process would be very problematic, so instead, [[https://github.com/TazeTSchnitzel/php-src/commit/360e1b0f3212da8b59266cbdcb0966cda69fc4e0|this commit]] introduces a workaround whereby we try to check ahead-of-time if the operation would fall foul of the overflow error and, if so, throw an E_ERROR with the message "Result of integer operation would be too large to represent". 

==== Licensing and dependency issues ====

As a result of using GMP, it will now always be a requirement to build PHP. GMP is widely available, so this shouldn't cause platform issues.

However, it does cause a licensing issue. GMP is licensed under both the GNU General Public License version 2 (GPLv2) and the GNU Lesser General Public License version (LGPLv3). I don't think linking against it as a GPLv2 library is feasible due to the GPL's copyleft requirements, so instead we'll consider using it under the LGPLv3.

The LGPLv3 poses a greater burden on distributors than the PHP license does. In particular, using the LGPLv3 puts an obligation on distributors of PHP binaries to provide the source code of GMP and to provide a PHP binary which can be linked with a modified version of GMP.

I don't feel either of these obligations are particularly onerous. The first obligation means that if you distribute a PHP binary, you would need to either distribute GMP's source with it, or provide it upon request. Non-commercial redistributors of PHP binaries, if they don't provide the source themselves, would not even need to provide their own offer for the source code, as they are permitted to pass along the offer from the original distributor. The second obligation would just mean that, either along with the PHP binary or on request, you would need to provide an object form you could link a modified version of GMP against. It is also important to note that this provision and the source code one **are only true if GMP is statically linked**; if GMP is dynamically linked and GMP itself is not distributed with PHP, there is no requirement to provide the source of GMP, nor to provide the object form.

The PHP license is a non-copyleft license, i.e. you can modify PHP, compile it, and distribute the binaries, without releasing the source code of your modifications. Including GMP would not change this. All that would change is that, if GMP has been statically linked, people distributing PHP would have an obligation to distribute GMP's source code and an object form that GMP can be linked against.

Therefore, I don't think that requiring GMP will really cause any problems from a license standpoint. If the fact GMP is LGPL-licensed becomes too much a problem, it could be possible to swap it out for something more favourably licensed if such a library is available, due to the zend_bigint_* abstraction. However, I am not aware of a better alternative.

See the links in the References section below.

==== Arrays ====

A problem arising from allowing integers to be arbitrarily large is that array keys using strings for numeric keys beyond the maximum size of a long would probably seem weird. At present, bigints are just dealt with as if they were numeric strings when using them as array keys and indices, but this may not be optimal. This RFC aims for integer consistency across platforms, and this would be a remaining inconsistency. It also doesn't make sense from a user perspective to have integers over a certain value suddenly become string keys, though whether this matters much in practise with PHP's type casting and juggling is a different question.

This also presents a further issue: inconsistency between longs, bigints and doubles, which **must** be avoided, as integer consistency cross-platform is a key goal of this RFC. Currently in PHP, doubles used as indexes are simply casted to longs, without any regard for size. This means that they overflow if they are larger than the platform's long size, either 32-bit or 64-bit. However, bigints as implemented, will be treated as strings if they are outside of the bounds of a long on the platform. While bigints are likely to break existing code anyway, this would be a particularly bad breakage, as code relying on very large numbers being floats and wrapping when used as indices would break. Hence some sort of solution must be found. Either we cast bigints to longs and let them overflow (not terribly desirable), we don't change the current behaviour (inconsistent), or we change the handling of doubles. Personally, I don't like what PHP does here and would to go for this last option.

==== To 64-bit RFC ====

The [[rfc:size_t_and_int64_next|64 bit platform improvements for string length and integer in zval]] RFC would be affected by this. For one thing, there's less need to use 64-bit integers when bigints are supported, and their only benefit would now be performance. For another, GMP only supports the "long" datatype and not "long long". Hence, while Linux etc. which have longs on 64-bit systems be 64-bit would work fine, Windows poses a problem as longs on 64-bit Windows systems are still 32-bit, so some sort of trickery (likely by splitting 64-bit ints into high and low words) would need to be done to convert 64-bit ints to bigints or vice-versa. Of course, while this hurts performance, it would only be needed on Windows, and I don't expect the overhead would be too bad.

==== To SAPIs ====

This should have no impact on existing SAPIs.

==== To Existing Extensions ====

Any which request numeric parameters as zvals rather than longs or doubles from zend_parse_parameters will need changes. Those dealing with numerical operations specifically will require deeper changes. Obviously, ext/standard will need some updating. ext/gmp ought to be rewritten so that it just passes on to the built-in operator functions.

Also, extensions dealing with parts of the Zend API that deal with numbers will need to be modified to deal with changes in signatures and behaviour. (See "Backwards Incompatible Changes")

==== To Opcache ====

GMP can only have one custom allocator, so I weighed the options and made that be emalloc, not malloc. I expect this would pose a problem for opcache, as any bigints would be destroyed upon the end of a request, so opcache would need to store bigints persistently. Hence, some sort of import/export mechanism could be added to zend_bigint. It is obviously possible to use strings, but gmp also has its own format for serialisation which would be more efficient, so that might be a good way.

I have not yet dealt with opcache implementation-wise, and I might need help when the time comes.

==== New Constants ====

None.

==== php.ini Defaults ====

No changes.

===== Open Issues =====

The patch is unfinished. Many tests are still broken, I haven't gotten round to updating the extensions, and it almost certainly does not work with opcache.

==== Open Questions ====

  * This is purely an internal issue, but should we scrap convert_to_bigint in the current patch? It's not currently used anywhere and we have convert_to_bigint_or_long. Having IS_BIGINT conversion as well as IS_BIGINT_OR_LONG and IS_LONG conversion poses an extra burden on implementers of the cast_object class handler, etc. However, it would make the conversion functions incomplete to not allow converting to this basic type, and we'd be instead shifting the burden to functions needing a bigint exclusively, as they'd have to convert to IS_BIGINT_OR_LONG, then convert to bigint themselves if the result was long. Furthermore, zend_parse_parameters is probably going to have a bigint-only specifier... so we'd probably need to implement this anyway. Worth nothing that the purpose of IS_BIGINT_OR_LONG is efficiency (don't use a bigint if you don't need to), but in many cases you can just make IS_BIGINT_OR_LONG fall-through to IS_LONG or IS_BIGINT (indeed, in many cases the result can never exceed 32 bits in length, so falling through to IS_LONG is the optimal solution), so the burden isn't really that great. Therefore my current thoughts are that we should keep convert_to_bigint and hence compel implementers of cast_object to support both IS_LONG, IS_BIGINT_OR_LONG and IS_BIGINT conversion.
  * How should we handle conversion of a bigint to a long (as a function parameter, say) when the bigint is too large to fit in a long? As implemented at present, we cap the value at LONG_MAX/_MIN, but this means complete loss of information (we now only know the sign and that it was a large number) and is inconsistent with the behaviour of double to long conversion, which merely truncates, leaving the lower bits intact. While I initially thought capping was the right approach, I now think truncating is the right one, and I am going implement this.
  * We currently throw an E_RECOVERABLE_ERROR if a bigint that is too large is passed as a parameter to a function expecting a long.
    * Is this too harsh an error? Would E_WARNING be more appropriate? Old code might be caught out by this if it passed some really large double value as the value for a long parameter.
    * We don't currently do this for doubles. Should we? It would mean more consistency.
  * Is GMP using LGPL a problem? (See "Licensing and dependency issues" above)
  * Should we rework array key handling? (See "Arrays" above)

==== TODO ====

  * Possible issue: Currently, when dividing a bigint by something, we check if it's divisible, then do an integer division if that is the case, or else cast to double and then do the division. However, for very large bigints, the double we get might end up being Infinity, so we should probably calculate the double from doing an integer division and using the remainder if possible.
  * Figure out if we should deal with bigints string indices better. Currently we cast to long, but should we check for it being capped at LONG_MAX/_MIN and, if so, throw the "uninitalized index" error? (That would make the most sense)
      * Looks like there's some sort of numeric string offset thing in zend_language_scanner.l, what is that and does it affect this?
  * Truncate instead of capping when converting bigints to long (see Open Questions)
  * Fix remaining broken tests on 64-bit and 32-bit
  * Write more tests for bigints, especially for areas that aren't covered just now
  * Enable more extensions as we're only testing ''--disable-all'' just now
  * Decide whether it should be, and if so implement, throwing a warning when a bigint is capped at LONG_MAX
  * Implement bigint option for zend_parse_parameters (consider implementing IS_BIGINT_OR_LONG option)
  * Fix ext/standard and other important extensions (ext/json?)
  * Rewrite ext/gmp
  * Deal with opcache
  * Rewrite (or get someone else to rewrite) the assembly routines (currently commented out as they overflowed to double, not bigint)
  * That clz/bsr assembly TODO (or just generally use a more efficient check)
  * Eventually mark the zend_bigint_* functions as to be inlined and move them to the header
  * More stuff


===== Unaffected PHP Functionality =====

As previously mentioned, the handling of array keys might need to be looked at. Otherwise, it shouldn't affect the behaviour of other PHP functionality, but obviously the implementations of anything dealing with integers may need to be changed.

===== Future Scope =====

None I can think of particularly.

===== Proposed Voting Choices =====

In some respects this is just an implementation detail, but as this would break backwards-compatibility for some apps and arguably changes the language, I think this requires a 2/3 majority. It would be a straight Yes/No vote.

===== Patches and Tests =====

A work-in-progress, unfinished pull request is here: https://github.com/php/php-src/pull/773

The branch itself is here: https://github.com/TazeTSchnitzel/php-src/tree/phpng-bigint

It is based off the phpng branch. Many tests are still broken, as as mentioned previously, I still need to deal with extensions and opcache. It is very much unfinished, but it does work to a degree.

See the TODO section in Open Issues (above) for unfinished areas.

===== Implementation =====

If/when this is implemented, this section would/will contain 
  - the version(s) it was merged to
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature

===== References =====

==== Inspiration ====

  * I was inspired in part by Python 2's bigint support with its separate "long" type (different from the machine-dependent "int" type), and how Python 3 unified these into the single "int" type - see http://legacy.python.org/dev/peps/pep-0237/

  * Some other languages also do it: Erlang, Haskell and Smalltalk

==== Licensing issues ====

  * [[http://www.softwarefreedom.org/resources/2008/compliance-guide.html|A Practical Guide to GPL Compliance]]
  * [[https://www.gnu.org/licenses/gpl-faq.html#LGPLStaticVsDynamic|Frequently Asked Questions about the GNU Licenses: Does the LGPL have different requirements for statically vs dynamically linked modules with a covered work?]].
  * [[https://en.wikipedia.org/wiki/PHP_License|PHP License (Wikipedia)]]

==== Discussion ====

  * [[http://marc.info/?l=php-internals&m=140322457728554&w=2|php-internals discussion of draft RFC]]

==== General ====

  * https://gmplib.org/ - The GNU Multiple Precision Arithmetic Library
  * Yasuo's [[rfc:gmp_number|gmp_number]] RFC is similar in some respects

===== Rejected Features =====

None... yet!