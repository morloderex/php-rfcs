====== PHP RFC: new MyClass()->method() without parentheses ======

  * Date: 2023-12-29
  * Author: Valentin Udaltsov <vudaltsov@php.net>
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/new_without_parentheses
  * Implementation: https://github.com/php/php-src/pull/13029

===== Introduction =====

The "Class member access on instantiation" feature
[[https://php-legacy-docs.zend.com/manual/php5/en/migration54.new-features#:~:text=Class%20member%20access%20on%20instantiation%20has%20been%20added%2C%20e.g.%20(new%20Foo)%2D%3Ebar().|was introduced in PHP 5.4.0]].
Since then methods, properties and constants can be accessed on a newly created instance without an intermediate variable,
but **only** if the new expression is wrapped in parentheses:

<code php>
class MyClass
{
    public function method(): void
    {
        echo 'Hello, World!';
    }
}

(new MyClass())->method(); // Hello, World!

new MyClass()->method(); // PHP Parse error: syntax error, unexpected token "->"
</code>

The goal of this RFC is to enable the second sytax without parentheses to simplify code writing, lower the learning curve, decrease
visual debt and ease transition from other C-like languages that don't require parentheses (
[[https://onecompiler.com/java/3zxuee3bm|Java]],
[[https://onecompiler.com/csharp/3zxudhw4s|C#]],
[[https://onecompiler.com/typescript/3zxudfpyy|TypeScript]]).

===== Ambiguity? =====

At first glance ''new MyClass()->method()'' expression might seem ambiguous. But according to the same logic
''new MyClass()'' is also ambiguous: is it ''new (MyClass())'' or ''new MyClass''? However, such ambiguity
does not exist: ''new MyClass()'' is interpreted as an instantiation of class ''MyClass'' with zero
constructor arguments, not as instantiation of ''MyClass()'' function call result.

Here's how it is solved at the grammar level. The formula for the ''new'' expression is
''T_NEW class_name|new_variable|(expr) ctor_arguments'', where ''new_variable'' is a variable expression without calls.
Thus PHP offers 3 ways to provide a class:

<code php>
// class_name
new MyClass();

// new_variable
new $class();

// (expr)
new (trim(' MyClass '))();
</code>

This guarantees that the new expression is unambiguous: once the parser encounters a ''T_NEW'' token, it considers
whatever comes next as a class name. Hence it's safe and unambiguous to further use ''new <class>()'' expression on its
own without parentheses. It's like replacing ''(MyClass::new())->method()'' with simply ''MyClass::new()->method()''.

===== Proposal =====

TODO

===== Backward Incompatible Changes =====

None.

===== Proposed PHP Version(s) =====

PHP 8.4
