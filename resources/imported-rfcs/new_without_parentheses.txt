====== PHP RFC: new MyClass()->method() without parentheses ======

  * Date: 2024-04-07
  * Author: Valentin Udaltsov <vudaltsov@php.net>
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/new_without_parentheses
  * Implementation: https://github.com/php/php-src/pull/13029

===== Introduction =====

The "class member access on instantiation" feature
[[https://php-legacy-docs.zend.com/manual/php5/en/migration54.new-features#:~:text=Class%20member%20access%20on%20instantiation%20has%20been%20added%2C%20e.g.%20(new%20Foo)%2D%3Ebar().|was introduced in PHP 5.4.0]].
Since then constants, properties and methods can be accessed on a newly created instance without an intermediate
variable, but **only** if the ''new'' expression is wrapped in parentheses:

<code php>
class MyClass
{
    public function method(): void
    {
        echo 'Hello, World!';
    }
}

(new MyClass())->method(); // Hello, World!

new MyClass()->method(); // PHP Parse error: syntax error, unexpected token "->"
</code>

The goal of this RFC is to enable the second syntax to:
  * make coding with PHP more convenient
  * lower the learning curve
  * decrease the visual debt
  * ease switching between other C-like languages that don't require parentheses ([[https://onecompiler.com/java/3zxuee3bm|Java]], [[https://onecompiler.com/csharp/3zxudhw4s|C#]], [[https://onecompiler.com/typescript/3zxudfpyy|TypeScript]]).

===== Proposal =====

This RFC allows to omit parentheses around the ''new'' expression when constructor arguments' parentheses **are** present. Given class

<code php>
class MyClass
{
    const CONSTANT = 'constant';
    public static $staticProperty = 'staticProperty';
    public static function staticMethod(): string { return 'staticMethod'; }
    public $property = 'property';
    public function method(): string { return 'method'; }
    public function __invoke(): string { return '__invoke'; }
}
</code>

one will be able to write

<code php>
var_dump(
    new MyClass()::CONSTANT,        // string(8)  "constant"
    new MyClass()::$staticProperty, // string(14) "staticProperty"
    new MyClass()::staticMethod(),  // string(12) "staticMethod"
    new MyClass()->property,        // string(8)  "property"
    new MyClass()->method(),        // string(6)  "method"
    new MyClass()(),                // string(8)  "__invoke"
);

$myClass = MyClass::class;
var_dump(
    new $myClass()::CONSTANT,        // string(8)  "constant"
    new $myClass()::$staticProperty, // string(14) "staticProperty"
    new $myClass()::staticMethod(),  // string(12) "staticMethod"
    new $myClass()->property,        // string(8)  "property"
    new $myClass()->method(),        // string(6)  "method"
    new $myClass()(),                // string(8)  "__invoke"
);

var_dump(
    new (trim(' MyClass '))()::CONSTANT,        // string(8)  "constant"
    new (trim(' MyClass '))()::$staticProperty, // string(14) "staticProperty"
    new (trim(' MyClass '))()::staticMethod(),  // string(12) "staticMethod"
    new (trim(' MyClass '))()->property,        // string(8)  "property"
    new (trim(' MyClass '))()->method(),        // string(6)  "method"
    new (trim(' MyClass '))()(),                // string(8)  "__invoke"
);
</code>

This RFC still does not allow to omit parentheses around the ''new'' expression **without** constructor arguments' parentheses, because in some cases
this leads to an ambiguity:

<code php>
// Access property on a new instance or instantiate the result of expression?
new MyClass::$staticProperty;
new $myClass::$staticProperty;
new $myClass->property;

// Access method on a new instance or instantiate the result of expression?
new $myClass->method();
</code>

This RFC allows to omit parentheses around the ''new'' anonymous class expression regardless of whether constructor arguments'
parentheses are present or not:

<code php>
var_dump(
    // string(8) "constant"
    new class { const CONSTANT = 'constant'; }::CONSTANT,
    // string(14) "staticProperty"
    new class { public static $staticProperty = 'staticProperty'; }::$staticProperty,
    // string(12) "staticMethod"
    new class { public static function staticMethod() { return 'staticMethod'; } }::staticMethod(),
    // string(8) "property"
    new class { public $property = 'property'; }->property,
    // string(6) "method"
    new class { public function method() { return 'method'; } }->method(),
    // string(8) "__invoke"
    new class { public function __invoke() { return '__invoke'; } }(),
);
</code>

===== Ambiguity? =====

At first glance ''new MyClass()->method()'' expression might seem ambiguous. But according to the same logic
''new MyClass()'' is also ambiguous: is it ''new (MyClass())'' or ''new MyClass''? However, such ambiguity
does not exist: ''new MyClass()'' is interpreted as an instantiation of class ''MyClass'' with zero
constructor arguments, not as instantiation of ''MyClass()'' function call result.

Here's how it is solved at the [[https://github.com/php/php-src/blob/948b2bc2110667cfe53cec253893a3b021f22449/Zend/zend_language_parser.y#L1126|grammar level]].
The formula for the ''new'' expression is ''T_NEW class_name|new_variable|(expr) ctor_arguments'', where ''new_variable''
is a variable expression without calls. Thus PHP offers 3 ways to provide a class:

<code php>
// class_name
new MyClass();

// new_variable
new $class();

// (expr)
new (trim(' MyClass '))();
</code>

This guarantees that the ''new'' expression is unambiguous: once the parser encounters ''T_NEW'', it considers
whatever comes next a class name. Hence it's safe and unambiguous to further use the ''new'' expression on its
own without parentheses. It's like refactoring ''(MyClass::new())->method()'' to ''MyClass::new()->method()'',
nobody will ever read it as ''MyClass::(new())->method()'' or ''MyClass::(new()->method())''.

===== Backward Incompatible Changes =====

None. Any code that is valid before the change will be valid after and interpreted in the same way.

===== Proposed PHP Version(s) =====

PHP 8.4
