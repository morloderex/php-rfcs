====== PHP RFC: Lazy Objects ======

  * Version: 1.0
  * Date: 2024-06-03
  * Author: Arnaud Le Blanc <arnaud.lb@gmail.com>, Nicolas Grekas <nicolasgrekas@php.net>
  * Status: Under Discussion
  * First Published at: https://wiki.php.net/rfc/lazy-objects

===== Introduction =====

Transparent lazy-initialization of objects is an important part of many PHP applications. However, achieving this kind of laziness in userland is complex, limited, and can have a significant performance impact. This proposal aims to bring lazy initialization to the PHP engine to mitigate these drawbacks.

Martin Fowler identifies [[https://martinfowler.com/eaaCatalog/lazyLoad.html|four strategies]] to implement lazy loading using OOP: lazy initialization, value holders, virtual proxies, and ghost objects. This RFC focuses on virtual proxies and ghost objects, which provide transparent lazy-loading. Unlike lazy initialization and value holders, virtual proxies and ghost objects do not require a class to be written with the lazy-loading concept in mind. Instead, the lazy-loading behavior can be attached externally.

In both strategies, we start with empty objects typically created with <php>ReflectionClass::newInstanceWithoutConstructor()</php>, attaching an initializer that is called automatically when these objects are used. From an abstraction point of view, lazy objects from this RFC are indistinguishable from non-lazy ones: they can be used without knowing they are lazy.

Lazy-loading of objects in PHP is already used in business-critical situations. For example, Symfony uses them in its dependency injection component to provide lazy services that are fully initialized only if needed. The Doctrine ORM makes its entities lazy, allowing objects to hydrate themselves from the database only when accessed. Other use cases include a JSON parser that uses lazy objects to defer parsing unless those objects are accessed.

Implementing virtual proxies and ghost objects in userland is non-trivial. This has been explored in the [[https://packagist.org/packages/ocramius/proxy-manager|ocramius/proxy-manager]] library and later in the [[https://packagist.org/packages/symfony/var-exporter|symfony/var-exporter]] one. Current implementations have several limitations, including incompatibility with final classes, and performance overhead due to magic methods. This RFC proposes to implement ghost objects and virtual state-proxies natively in the engine to address these issues.

===== Implementation =====

Lazy objects are standard ''zend_object'' whose initialization is deferred until one of their properties is accessed. This is implemented using the same fallback mechanism as ''%%__get%%'' and ''%%__set%%'' magic methods, triggered when an uninitialized property is accessed. No performance overhead is thus added to non-lazy use cases. Execution of methods or property hooks does not trigger initialization until one of them accesses a backed property.

A lazy object can be created via the Reflection API, with the user specifying an initializer function that is called when initialization is required.

There are two kinds of lazy objects:

  * Ghost: These are initialized in-place by the initializer function.
  * Virtual: The initializer returns a new instance, and interactions with the virtual object are proxied to this instance.

Internal objects are not supported because their state is usually not managed via regular properties.

It should be noted that the proposed Reflection API has been tested successfully on the Doctrine and on the Symfony projects, allowing to [[https://github.com/nicolas-grekas/symfony/pull/44|remove a bunch of hard-to-maintain code]] while improving transparency of lazy objects and keeping the test suite green with the same public API.

===== Proposal =====

This RFC proposes adding the following Reflection class to the PHP engine:

<PHP>
class ReflectionLazyObjectFactory extends ReflectionClass
{
    public int const SKIP_INITIALIZATION_ON_SERIALIZE = 1;
    public int const SKIP_DESTRUCTOR = 2;

    public function __construct(object|string $objectOrClass);

    public function newLazyGhostInstance(callable $initializer, int $options = 0): object;
    public function newLazyProxyInstance(callable $initializer, int $options = 0): object;

    public function makeInstanceLazyGhost(object $object, callable $initializer, int $options = 0): void;
    public function makeInstanceLazyProxy(object $object, callable $initializer, int $options = 0): void;
    
    public static function isInitialized(object $instance): bool;
    
    /**
     * Initializes a lazy object (no-op if the object is already initialized.)
     *
     * The backing object is returned, which can be another instance than the lazy object when the virtual strategy is used.
     */
    public static function initialize(object $object, bool $skipInitializer = false): object;
    
    /**
     * Marks a property as *not* triggering initialization when being accessed.
     *
     * This method is useful to bypass initialization when setting a property.
     */
    public function skipInitializerForProperty(object $object, string $name, string $class = null): void;
    
    /**
     * Sets a property *without* triggering initialization while skipping hooks if any.
     */
    public function setRawPropertyValue(object $object, string $name, mixed $value, string $class = null): void;
}
</PHP>

==== Creating a Lazy Object ====

The entry points to create a lazy object are the <php>ReflectionLazyObject::newLazyGhostInstance()</php> and <php>newLazyProxyInstance()</php> methods.

<PHP>
class MyClass
{
    public function __construct(private int $foo)
    {
        // Heavy initialization logic here.
    }

    // ...
}

$initializer = static function (MyClass $ghost): void {
    $ghost->__construct(123);
};

$reflector = new ReflectionLazyObjectFactory(MyClass::class);
$object = $reflector->newLazyGhostInstance($initializer, ReflectionLazyObject::SKIP_DESTRUCTOR);

// At this point, $object is a lazy ghost object.
</PHP>

Creating a lazy virtual state-proxy requires using the <php>newLazyProxyInstance()</php> method:
<PHP>
$initializer = static function (MyClass $proxy): MyClass {
    return new MyClass(123);
};

$reflector = new ReflectionLazyObjectFactory(MyClass::class);
$object = $reflector->newLazyProxyInstance($initializer, ReflectionLazyObject::SKIP_DESTRUCTOR);
</PHP>

The <php>$options</php> argument is a bitfield that accepts the <php>ReflectionLazyObject::SKIP_INITIALIZATION_ON_SERIALIZE</php> flag. By default, serializing a lazy object triggers its initialization. This flag disables that behavior, allowing lazy objects to be serialized as empty objects. This is useful in scenarios like Doctrine entities, where cascading serialization could be problematic.

The <php>$options</php> argument also accepts the <php>ReflectionLazyObject::SKIP_DESTRUCTOR</php> flag. By default, the <php>makeInstanceLazy*()</php> methods will call the destructor of an object (if any) before making it lazy. This provides safety regarding any preexisting state in the object. But when the object has just been created and is empty, calling the destructor is not desired and can be skipped with this flag.

An <php>Error</php> is raised if the class passed to the <php>newLazy*Instance()</php> methods is internal or extends an internal class:

<PHP>
// Raises "Error: Cannot make instance of internal class lazy: ReflectionClass is internal"
ReflectionLazyObject::makeLazyGhost(new ReflectionClass(), $initializer);
</PHP>

The <php>makeInstanceLazy*()</php> methods accept an already created instance. This allows writing classes that manage their own laziness:
<PHP>
class MyLazyClass
{
    public function __construct()
    {
        $reflector = new ReflectionLazyObjectFactory(self::class);
        $reflector->makeInstanceLazyGhost($this, $this->initialize(...), ReflectionLazyObject::SKIP_DESTRUCTOR);
    }

    // ...
}
</PHP>

If an object is already lazy, a <php>ReflectionException</php> is thrown with the message "Object is already lazy".

The effect of <php>makeInstanceLazy*()</php> on the object is described later.

==== Handling the State of Lazy Objects ====

Any access to properties of a lazy object triggers its initialization (including via <php>ReflectionProperty</php>). However, certain properties might be known ahead of time and should not trigger initialization when accessed:

<PHP>
class BlogPost
{
    public function __construct(private int $id, private string $title, private string $content)
    {
    }
}

$reflector = new ReflectionLazyObjectFactory(BlogPost::class);
$initializer = // Callable that retrieves the title and content from the database.
$post = $reflector->newLazyGhostInstance($initializer, ReflectionLazyObject::SKIP_DESTRUCTOR);

// Without this line, the following call to ReflectionProperty::setValue() would trigger initialization.
$reflector->skipInitializerForProperty('id');
$reflector->getProperty('id')->setValue($post, 123);

// Alternatively, one can use this directly:
$reflector->setRawPropertyValue('id', 123);
</PHP>

The <php>skipInitializerForProperty()</php> / <php>setRawPropertyValue()</php> methods provide ways to disable lazy-initialization when a property is accessed, allowing users to choose the approach that best fits their design. The <php>$class</php> argument of these methods allows targeting the declaring class of a private property in the parent chain.

==== Lifecycle of Lazy Objects ====

An object is considered lazy if any of its properties are still hooked to the initializer passed to the <php>newLazy*Instance()</php> and <php>makeInstanceLazy*()</php> methods that made it lazy.

There are three ways to make a lazy object non-lazy:

  - Interacting with it in a way that triggers its initializer (more on this bellow).
  - Using <php>ReflectionLazyObjectFactory::skipInitializerForProperty()</php> or <php>setRawPropertyValue()</php> on all its properties.
  - Calling the <php>ReflectionLazyObjectFactory::initialize()</php> method with the instance as argument.

The <php>initialize()</php> method's <php>bool $skipInitializer</php> argument (default <php>false</php>) allows marking a lazy object as non-lazy without running the initializer, leaving uninitialized properties. This is useful for managed entity objects. Accessing a property before it is set throws an "uninitialized property" error.

==== Initialization Triggers ====

Except for the special cases listed below, any attempt to observe the state of a lazy object will trigger its initialization. This ensures that the result of the observation is the same as if the object were already initialized, maintaining full transparency. These triggers include:

  * Reading or writing a property
  * Testing if a property is set or unsetting it
  * Calling <php>ReflectionProperty::getValue()</php> and <php>setValue()</php>
  * Calling <php>ReflectionObject::getProperties()</php>

This behavior makes lazy objects fully transparent to their consumers.

The following special cases do not trigger initialization of a lazy object:

  * Calls to <php>ReflectionLazyObjectFactory::skipInitializerForProperty()</php>, <php>setRawPropertyValue()</php>, or accesses to properties on which these methods were called.
  * Calls to <php>get_object_vars()</php> and <php>get_mangled_object_vars()</php>.
  * Calls to <php>serialize()</php> when <php>ReflectionLazyObjectFactory::SKIP_INITIALIZATION_ON_SERIALIZE</php> is set, unless a property is accessed in ''%%__serialize()%%'' or ''%%__sleep()%%'' methods.
  * Calls to <php>ReflectionObject::__toString()</php>.
  * Casting to array using the <php>(array)</php> operator.
  * Calls to <php>var_dump($lazyObject)</php>, unless ''%%__debugInfo()%%'' is implemented and accesses a property.
  * Cloning, unless ''%%__clone()%%'' is implemented and accesses a property.

By excluding these cases from triggering initialization, developers can perform certain operations on lazy objects without causing them to initialize, providing finer control over the initialization process.

==== Initialization Sequence ====

=== Ghost Objects ===

  - Before calling the initializer:
    - Properties that were not initialized with <php>ReflectionLazyObjectFactory::skipInitializerForProperty()</php>, <php>ReflectionLazyObjectFactory::setRawPropertyValue()</php> are initialized to their default value if any, in the same way as using <php>new</php> or <php>ReflectionClass::newInstanceWithoutConstructor()</php>.
    - The object is marked as non-lazy.
  - During initialization, properties can be accessed directly without triggering recursive initialization. Accessing properties without a default value may throw an error, as usual.
  - The initializer must return <php>null</php> or no value

The following example demonstrates the behavior of accessing properties during initialization:

<PHP>
class MyClass {
    public $a = 1;
    public int $b;
}

$object = new ReflectionLazyObjectFactory(MyClass::class)->newLazyGhostInstance(function ($object) {
    var_dump($object->a); // int(1)
    var_dump($object->b); // Error: Typed property MyClass::$b must not be accessed before initialization
});
</PHP>

After initialization, the object is indistinguishable from an object that was never lazy.

=== Virtual Objects ===

  - Before calling the initializer, the object is marked as non-lazy.
  - The initializer is called with the lazy proxy as first parameter.
  - The return value of the initializer has to be a non-lazy instance of a parent or a child class of the lazy-object and it must have the same properties. An TypeError is thrown if that's not the case. Returning an instance of a child or parent class with the same properties does not break LSP.
  - The actual instance is set to the return value.
  - Properties that were initialized with <php>ReflectionLazyObjectFactory::skipInitializerForProperty()</php>, <php>ReflectionLazyObjectFactory::setRawPropertyValue()</php> are uninitialized.

The proxy object is _not_ replaced or substituted for the actual instance. After initialization, accesses properties on the proxy are forwarded to the actual instance. Observing properties of the proxy has the same result as observing properties of the actual instance.

The actual instance is allowed to escape the proxy and to create direct references to itself. The proxy may be released independently of the actual instance when it's not referenced anymore. The proxy and actual instance have distinct identities.

=== Common Behavior ===

After a successful initialization, the initializer function is not retained anymore by this object, and may be released if it's not referenced anywhere else.

If the initializer throws, the object properties are reverted to their pre-initialization state and the object is marked as lazy again. In other words, all effects on the object itself are reverted. Other side effects, such as side-effects on other objects, are not reverted. The goal is to not expose a half-initialized instance in case of failure.

==== Detailed API behavior ====

=== newLazyGhostInstance() ===

<PHP>
    public function newLazyGhostInstance(callable $initializer, int $options = 0): object;
</PHP>

The <php>newLazyGhostInstance()</php> method instantiates an object without calling the constructor, and marks the object as lazy.

Properties are not initialized to their default value (they are initialized before calling the initializer). This is only mentioned for completeness, as this is not observable currently. 

The <php>$options</php> argument is a bitfield that accepts the <php>ReflectionLazyObject::SKIP_INITIALIZATION_ON_SERIALIZE</php> flag. By default, serializing a lazy object triggers its initialization. This flag disables that behavior, allowing lazy objects to be serialized as empty objects. This is useful in scenarios like Doctrine entities, where cascading serialization could be problematic.

Using <php>newLazyGhostInstance()</php> with an internal class or a sub-class of an internal class is not supported, and will throw an exception.

The return value is the created object.

The behavior of the returned object is described in the Initialization Triggers and Initialization Sequence sections.

=== newLazyProxyInstance() ===

<PHP>
    public function newLazyProxyInstance(callable $initializer, int $options = 0): object;
</PHP>

The behavior of the <php>newLazyProxyInstance()</php> method is similar to <php>newLazyGhostInstance()</php>, with the difference that is uses the Proxy strategy.

=== makeInstanceLazyHost() === 

<PHP>
    public function makeInstanceLazyGhost(object $object, callable $initializer, int $options = 0): void;
</PHP>

The <php>makeInstanceLazyGhost()</php> method makes an existing object lazy. The indented use-case is for an object to manage its own lazyness by calling the method in its constructor.

The <php>$options</php> argument accepts the <php>ReflectionLazyObject::SKIP_DESTRUCTOR</php> flag in addition to the flags accepted by <php>newLazyGhostInstance()</php>. By default, the <php>makeInstanceLazy*()</php> methods will call the destructor of an object (if any) before making it lazy. This provides safety regarding any preexisting state in the object. But when the object has just been created and is empty, calling the destructor is not desired and can be skipped with this flag.

When making an object lazy, the object destructor is called (unless the <php>ReflectionLazyObject::SKIP_DESTRUCTOR</php> is given), and the object is reset to a state equivalent to an instance created by <php>newLazyGhostInstance()</php>. In particular, all properties are <php>unset()</php>. This effect could be achieved in user space with the Reflection API and Closure scopes:

<PHP>
(function () {
    $reflector = new ReflectionObject($this);
    foreach ($reflector->getProperties() as $prop) {
        unset($this->{$prop->getName()});
    }
})->bindTo($object, $object);
</PHP>

This snippet omits details such as static, private, or virtual properties for brevity.

The object is not replaced by an other one, and its identity does not change. Functionality such as <php>spl_object_id()</php>, <php>spl_object_hash()</php>, <php>SplObjectStorage</php>, <php>WeakMap</php>, <php>WeakReference</php>, or strict equality comparison are not affected by <php>makeInstanceLazy*()</php>.

<PHP>
$object = new MyClass();
$ref = WeakReference::create($object);
$id = spl_object_id($object);

new ReflectionLazyObjectFactory(MyClass::class)->makeInstanceLazyGhost($object, function () {});
var_dump($id === spl_object_id($object)); // bool(true)
var_dump($ref->get() === $object); // bool(true)

ReflectionLazyObjectFactory::initialize($object);
var_dump($id === spl_object_id($object)); // bool(true)
var_dump($ref->get() === $object); // bool(true)
</PHP>

Calling <php>newLazyGhostInstance()</php> on an already lazy object results in an exception.

After calling <php>newLazyGhostInstance()</php>, the behavior of the object is the same as an object created by <php>newLazyGhostInstance()</php>.

=== makeInstanceLazyProxy() ===

<PHP>
    public function makeInstanceLazyProxy(object $object, callable $initializer, int $options = 0): void;
</PHP>

The behavior of the <php>makeInstanceLazyProxy()</php> method is similar to <php>makeInstanceLazyHost()</php>, except that is uses the Proxy strategy.

The object itself becomes the proxy. Similarly to <php>makeInstanceLazyGhost()</php>, the object is not replaced by an other one, and its identity does not change, even after initialization. The proxy and the actual instance are distinct objects, with distinct identities.

=== isInitialized() ===

<PHP>
    public static function isInitialized(object $object): bool;
</PHP>

The <php>isInitialized</php> returns <php>true</php> if the object was initialized. It also returns <php>true</php> if the object has never been lazy, since an initialized lazy ghost is indistinguishable from an object that was never lazy.

=== initialize() ===

<PHP>
    public static function initialize(object $object, bool $skipInitializer = false): object;
</PHP>

The <php>initialize()</php> method can be use to force initialization of a lazy object. It has no effect if the object is already initialized.

If <php>$skipInitializer</php> is <php>true</php>, the behavior is the one described for Ghost Objects in the Initialization Sequence section, except that the initializer is not called.

The return value is the object itself for ghost objects (or if <php>$skipInitializer</php> is <php>true</php>), or the actual instance for proxy objects.

=== skipInitializerForProperty ===

<PHP>
    public function skipInitializerForProperty(object $object, string $name, string $class = null): void;
</PHP>

The <php>skipInitializerForProperty()</php> method marks a property as non lazy such that it can be accessed directly without triggering initialization. It also initializes the property to its default value, if any.

<PHP>
class MyClass {
    public $a;
    public $b;
}

$reflector = new ReflectionLazyObjectFactory(MyClass::class);
$object = $reflector->newLazyGhostInstance(function () {});

$reflector->skipInitializerForProperty($object, 'a');

$object->a = 1;       // does not trigger initialization
var_dump($object->a); // int(1) (does not trigger initialization)
</PHP>

Accessing the property after calling this method has the same behavior as accessing it after constructing the object with <php>ReflectionClass::newInstanceWithoutConstructor()</php>.

<PHP>
class MyClass {
    public $a = 1;
    public int $b;
    public $c;
}

$reflector = new ReflectionLazyObjectFactory(MyClass::class);
$object = $reflector->newLazyGhostInstance(function () {});

$reflector->skipInitializerForProperty($object, 'a');
$reflector->skipInitializerForProperty($object, 'b');

var_dump($object->a); // int(1) (does not trigger initialization)
var_dump($object->b); // Error: Typed property MyClass::$b must not be accessed before initialization (does not trigger initialization)
var_dump($object->c); // triggers initialization
</PHP>

The <php>$class</php> argument allows targeting the declaring class of a private property in the parent chain.

The property must be declared (can not be a dynamic property), non-static, and non-virtual.

=== setRawPropertyValue ===

<PHP>
    public function setRawPropertyValue(object $object, string $name, mixed $value, string $class = null): void;
</PHP>

The <php>setRawPropertyValue</php> is similar to <php>skipInitializerForProperty()</php>, but it allows to specify a value. It is more convenient that the latter when using the <php>$class</php> argument.

The method does not call hooks, if any, when setting the property value.

==== Cloning ====

The result of cloning an uninitialized lazy object is a new lazy object with the same initializer, and the same initialized properties (if <php>setRawPropertyValue</php> or <php>skipInitializerForProperty()</php> was used).

If the object implements the <php>__clone</php> magic method, the method may trigger initialization of the clone before it is returned by the `clone` operator.

Cloning an initialized lazy proxy returns a clone of the actual instance.

==== Destructors ====

The destructor of ghost objects is called if and only if the object has been initialized.

The destructor of virtual state proxy objects is never called. We rely on the destructor of the proxied instance instead.

When making an existing object lazy, the <php>makeInstanceLazy*()</php> methods call the destructor unless the <php>SKIP_DESTRUCTOR</php> flag is given.

===== About Lazy-Loading Strategies =====

This RFC proposes adding the ghost and virtual state-proxy strategies to the engine. One might wonder why two strategies are needed instead of just one.

The most transparent and thus default strategy should be the ghost one. Ghost objects handle initialization in place, meaning that once they are initialized, they are exactly like regular objects. However, they must be created ahead of time and populated later. This excludes their use when the initialization logic involves a factory that creates circular references.

Consider this example:

<PHP>
class Manager
{
    private Dispatcher $dispatcher;

    public function setDispatcher(Dispatcher $dispatcher)
    {
        $this->dispatcher = $dispatcher;
    }

    public static function createManager(): self
    {
        $manager = new self();
        $manager->setDispatcher(new Dispatcher($manager));
        
        return $manager;
    }
}

class Dispatcher
{
    public function __construct(private Manager $manager)
    {
    }
}
</PHP>

Using the <php>Manager::createManager()</php> factory is not compatible with ghost objects because their initializer requires initializing the ghost object in place, while the factory method returns a separate instance. Attempting to copy all properties from the factory instance to the ghost object and handling circular references would be impractical and non-performant. Moreover, integrating <php>ReflectionLazyObject</php> into the factory is not an option when the method is not under our control.

Virtual state-proxies are compatible with such situations because they return a separate instance.

However, ghost objects are necessary due to object identity. When using virtual proxies, there are two objects: the proxy and the actual instance. This can lead to issues in use cases where object identity is crucial, such as entity managers. Having more than one concrete object representing the same logical object can lead to fragile code.

===== About Virtual Proxies =====

When considering virtual proxies, one might expect the implementation to rely on decorating every method of a target class (or interface). This type of proxy is called a virtual inheritance-proxy.

Lazy virtual inheritance-proxies decorate every method of a target class or interface to prepend the initialization logic. This logic creates another instance to which all method calls are forwarded. The benefits of this strategy are compatibility with internal classes and interfaces, allowing final classes implementing an interface to be made lazy. However, this strategy has a major drawback: it breaks object identity. If a method returns <php>$this</php>, it returns the decorated object, not the proxy.

The virtual state-proxy strategy proposed by this RFC relies on proxying property accesses instead of methods. Methods are called on the state-proxy itself, so when a method returns <php>$this</php>, it returns the state-proxy object. This approach minimizes identity issues.

Since the state-proxy strategy requires accessing the properties of the decorated object, it is not compatible with internal classes or interfaces. Therefore, virtual inheritance-proxies still have use cases. However, this proposal focuses on providing ghost objects and virtual state-proxies natively, not virtual inheritance-proxies.

There are several reasons for that:

  - Ghost objects and virtual state-proxies hook into the same place in the engine, simplifying the RFC and the corresponding patch.
  - These strategies benefit the most from being in the engine: userland implementation relies on complex magic accessors, is difficult to maintain as new PHP versions are released, and is slower than what can be achieved with engine support.
  - It's unclear if the engine would significantly help with virtual inheritance-proxies: implementing or generating code to decorate methods is simpler.

<php>ReflectionLazyObjectFactory::initialize()</php> returns the backing object to aid in implementing virtual inheritance-proxies in userland. The previous description was simplified: virtual inheritance-proxies should also proxy public property accesses in addition to method calls.

Here is an example of a (non-optimized) lazy-loading virtual inheritance-proxy using this RFC:

<PHP>
class Connection
{
    public float $ttl = 1.0;

    public function send(string $data): void
    {
        // Real implementation we want to make lazy
    }
}

class LazyConnection extends Connection
{
    public function __construct()
    {
        ReflectionLazyObject::makeLazyProxy($this, $this->initialize(...), ReflectionLazyObject::SKIP_DESTRUCTOR);
    }

    public function send(string $data): void
    {
        ReflectionLazyObject::fromInstance($this)->initialize()->send($data);
    }

    private function initialize(): parent
    {
        $connection = new parent(); // Or any heavier initialization logic
        $connection->ttl = 2.0;

       return $connection;
    }
}

$connection = new LazyConnection();

echo $connection->ttl; // echoes 2.0
</PHP>

===== Future scope =====

The goal of this RFC is to permit the creation of lazy objects via the Reflection API.

Lazy objects are an advanced feature that most users will not use directly. This feature is primarily targeted at library and framework authors.

FFI and Fibers are examples of features recently added to PHP that most users may not use directly, but can benefit from greatly within libraries they use.

As such, the authors do not plan to add higher-level syntax for creating lazy objects.

It is also not planned to add class-centric constructs based on attributes or magic methods, because this RFC seeks to creates lazy objects without cooperation from the class.

However, it is possible to introduce a higher-level syntax or class-centric constructs in a future RFC. 

===== Backward Incompatible Changes =====

Introduction of class `ReflectionLazyObjectFactory` in the global namespace may break applications declaring a class with this name.

===== Proposed PHP Version(s) =====

PHP 8.4

===== Proposed Voting Choices =====

Add lazy-objects as described to the engine: yes/no (2/3 required to pass)

===== Patches and Tests =====

https://github.com/arnaud-lb/php-src/tree/lazy-objects