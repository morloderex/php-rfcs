====== PHP RFC: Lazy Objects ======

  * Version: 1.0
  * Date: 2024-06-03
  * Author: Arnaud Le Blanc <arnaud.lb@gmail.com>, Nicolas Grekas <nicolasgrekas@php.net>
  * Status: Under Discussion
  * First Published at: https://wiki.php.net/rfc/lazy-objects

===== Introduction =====

Transparent lazy-initialization of objects is an important part of many PHP applications. However, achieving this kind of laziness in userland is complex, limited, and can have a significant performance impact. This proposal aims to bring lazy initialization to the PHP engine to mitigate these drawbacks.

Martin Fowler identifies [[https://martinfowler.com/eaaCatalog/lazyLoad.html|four strategies]] to implement lazy loading using OOP: lazy initialization, value holders, virtual proxies, and ghost objects. This RFC focuses on virtual proxies and ghost objects, which provide transparent lazy-loading. Unlike lazy initialization and value holders, virtual proxies and ghost objects do not require a class to be written with the lazy-loading concept in mind. Instead, the lazy-loading behavior can be attached externally.

In both strategies, we start with empty objects typically created with <php>ReflectionClass::newInstanceWithoutConstructor()</php>, attaching an initializer that is called automatically when these objects are used. From an abstraction point of view, lazy objects from this RFC are indistinguishable from non-lazy ones: they can be used without knowing they are lazy. This is a core design principle of this RFC.

Lazy-loading of objects in PHP is already used in business-critical situations. For example, Symfony uses them in its dependency injection component to provide lazy services that are fully initialized only if needed. The Doctrine ORM makes its entities lazy, allowing objects to hydrate themselves from the database only when accessed. Other use cases include a JSON parser that uses lazy objects to defer parsing unless those objects are accessed.

Implementing virtual proxies and ghost objects in userland is non-trivial. This has been explored in the [[https://packagist.org/packages/ocramius/proxy-manager|ocramius/proxy-manager]] library and later in the [[https://packagist.org/packages/symfony/var-exporter|symfony/var-exporter]] one. Current implementations have several limitations, including incompatibility with final classes, and performance overhead due to magic methods. This RFC proposes to implement ghost objects and virtual state-proxies natively in the engine to address these issues.

===== Implementation =====

Lazy objects are standard ''zend_object'' whose initialization is deferred until one of their properties is accessed. This is implemented using the same fallback mechanism as ''%%__get%%'' and ''%%__set%%'' magic methods, triggered when an uninitialized property is accessed. No performance overhead is thus added to non-lazy use cases. Execution of methods or property hooks does not trigger initialization until one of them accesses a backed property.

A lazy object can be created via the Reflection API, with the user specifying an initializer function that is called when initialization is required.

There are two kinds of lazy objects:

  * Ghost: These are initialized in-place by the initializer function.
  * Virtual: The initializer returns a new instance, and interactions with the virtual object are proxied to this instance.

Internal objects are not supported because their state is usually not managed via regular properties.

It should be noted that the proposed Reflection API has been tested successfully on the Doctrine and on the Symfony projects, allowing to [[https://github.com/nicolas-grekas/symfony/pull/44|remove a bunch of hard-to-maintain code]] while improving transparency of lazy objects and keeping the test suite green with the same public API.

===== Proposal =====

This RFC proposes adding the following Reflection class to the PHP engine:

<PHP>
class ReflectionLazyObjectFactory extends ReflectionClass
{
    public int const SKIP_INITIALIZATION_ON_SERIALIZE = 1;
    public int const SKIP_DESTRUCTOR = 2;

    public function __construct(object|string $objectOrClass);

    public function newLazyGhostInstance(callable $initializer, int $options = 0): object;
    public function newLazyProxyInstance(callable $initializer, int $options = 0): object;

    public function makeInstanceLazyGhost(object $object, callable $initializer, int $options = 0): void;
    public function makeInstanceLazyProxy(object $object, callable $initializer, int $options = 0): void;
    
    public static function isInitialized(object $instance): bool;
    
    /**
     * Initializes a lazy object (no-op if the object is already initialized.)
     *
     * The backing object is returned, which can be another instance than the lazy object when the virtual strategy is used.
     */
    public static function initialize(object $object, bool $skipInitializer = false): object;
    
    /**
     * Marks a property as *not* triggering initialization when being accessed.
     *
     * This method is useful to bypass initialization when setting a property.
     */
    public function skipInitializerForProperty(object $object, string $name, string $class = null): void;
    
    /**
     * Sets a property *without* triggering initialization while skipping hooks if any.
     */
    public function setRawPropertyValue(object $object, string $name, mixed $value, string $class = null): void;
}
</PHP>

==== Creating a Lazy Object ====

The entry points to create a lazy object are the <php>ReflectionLazyObjectFactory::newLazyGhostInstance()</php> and <php>newLazyProxyInstance()</php> methods.

<PHP>
class MyClass
{
    public function __construct(private int $foo)
    {
        // Heavy initialization logic here.
    }

    // ...
}

$initializer = static function (MyClass $ghost): void {
    $ghost->__construct(123);
};

$reflector = new ReflectionLazyObjectFactory(MyClass::class);
$object = $reflector->newLazyGhostInstance($initializer, ReflectionLazyObjectFactory::SKIP_DESTRUCTOR);

// At this point, $object is a lazy ghost object.
</PHP>

Creating a lazy virtual state-proxy requires using the <php>newLazyProxyInstance()</php> method:
<PHP>
$initializer = static function (MyClass $proxy): MyClass {
    return new MyClass(123);
};

$reflector = new ReflectionLazyObjectFactory(MyClass::class);
$object = $reflector->newLazyProxyInstance($initializer, ReflectionLazyObjectFactory::SKIP_DESTRUCTOR);
</PHP>

The <php>makeInstanceLazy*()</php> methods accept an already created instance. This allows writing classes that manage their own laziness:
<PHP>
class MyLazyClass
{
    public function __construct()
    {
        $reflector = new ReflectionLazyObjectFactory(self::class);
        $reflector->makeInstanceLazyGhost($this, $this->initialize(...), ReflectionLazyObjectFactory::SKIP_DESTRUCTOR);
    }

    // ...
}
</PHP>

The behavior of these methods is described into more details later.

==== Handling the State of Lazy Objects ====

Any access to properties of a lazy object triggers its initialization (including via <php>ReflectionProperty</php>). However, certain properties might be known ahead of time and should not trigger initialization when accessed:

<PHP>
class BlogPost
{
    public function __construct(private int $id, private string $title, private string $content)
    {
    }
}

$reflector = new ReflectionLazyObjectFactory(BlogPost::class);
$initializer = // Callable that retrieves the title and content from the database.
$post = $reflector->newLazyGhostInstance($initializer, ReflectionLazyObjectFactory::SKIP_DESTRUCTOR);

// Without this line, the following call to ReflectionProperty::setValue() would trigger initialization.
$reflector->skipInitializerForProperty('id');
$reflector->getProperty('id')->setValue($post, 123);

// Alternatively, one can use this directly:
$reflector->setRawPropertyValue('id', 123);
</PHP>

The <php>skipInitializerForProperty()</php> / <php>setRawPropertyValue()</php> methods provide ways to disable lazy-initialization when a property is accessed, allowing users to choose the approach that best fits their design. The <php>$class</php> argument of these methods allows targeting the declaring class of a private property in the parent chain.

==== Lifecycle of Lazy Objects ====

An object is considered lazy if any of its properties are still hooked to the initializer passed to the <php>newLazy*Instance()</php> and <php>makeInstanceLazy*()</php> methods that made it lazy.

There are three ways to make a lazy object non-lazy:

  - Interacting with it in a way that triggers its initializer (more on this bellow).
  - Using <php>ReflectionLazyObjectFactory::skipInitializerForProperty()</php> or <php>setRawPropertyValue()</php> on all its properties.
  - Calling the <php>ReflectionLazyObjectFactory::initialize()</php> method with the instance as argument.

The <php>initialize()</php> method's <php>bool $skipInitializer</php> argument (default <php>false</php>) allows marking a lazy object as non-lazy without running the initializer, leaving uninitialized properties. This is useful for managed entity objects. Accessing a property before it is set throws an "uninitialized property" error.

==== Initialization Triggers ====

Except for the special cases listed below, any attempt to observe the state of a lazy object will trigger its initialization. This ensures that the result of the observation is the same as if the object were already initialized, maintaining full transparency. These triggers include:

  * Reading or writing a property
  * Testing if a property is set or unsetting it
  * Calling <php>ReflectionProperty::getValue()</php> and <php>setValue()</php>
  * Calling <php>ReflectionObject::getProperties()</php>

This behavior makes lazy objects fully transparent to their consumers.

The following special cases do not trigger initialization of a lazy object:

  * Calls to <php>ReflectionLazyObjectFactory::skipInitializerForProperty()</php>, <php>setRawPropertyValue()</php>, or accesses to properties on which these methods were called.
  * Calls to <php>get_object_vars()</php> and <php>get_mangled_object_vars()</php>.
  * Calls to <php>serialize()</php> when <php>ReflectionLazyObjectFactory::SKIP_INITIALIZATION_ON_SERIALIZE</php> is set, unless a property is accessed in ''%%__serialize()%%'' or ''%%__sleep()%%'' methods.
  * Calls to <php>ReflectionObject::__toString()</php>.
  * Casting to array using the <php>(array)</php> operator.
  * Calls to <php>var_dump($lazyObject)</php>, unless ''%%__debugInfo()%%'' is implemented and accesses a property.
  * Cloning, unless ''%%__clone()%%'' is implemented and accesses a property.

By excluding these cases from triggering initialization, developers can perform certain operations on lazy objects without causing them to initialize, providing finer control over the initialization process.

==== Initialization Sequence ====

=== Ghost Objects ===

  - Before calling the initializer:
    - Properties that were not initialized with <php>ReflectionLazyObjectFactory::skipInitializerForProperty()</php> or <php>ReflectionLazyObjectFactory::setRawPropertyValue()</php> are initialized to their default value if any, in the same way as using <php>ReflectionClass::newInstanceWithoutConstructor()</php>.
    - The object is marked as non-lazy.
  - During initialization, properties can be accessed directly without triggering recursive initialization. Accessing properties without a default value may throw an error, as usual.
  - The initializer must return <php>null</php> or no value

After initialization, the object is indistinguishable from an object that was never lazy.

=== Virtual Objects ===

  - Before calling the initializer, the object is marked as non-lazy.
  - The initializer is called with the lazy proxy as first parameter.
  - The return value of the initializer has to be a non-lazy instance of a parent or a child class of the lazy-object and it must have the same properties. An Error is thrown if that's not the case. Returning an instance of a child or parent class with the same properties does not break LSP.
  - The actual instance is set to the return value.
  - Properties that were initialized with <php>ReflectionLazyObjectFactory::skipInitializerForProperty()</php>, <php>ReflectionLazyObjectFactory::setRawPropertyValue()</php> are uninitialized.

The proxy object is _not_ replaced or substituted for the actual instance. After initialization, property accesses on the proxy are forwarded to the actual instance. Observing properties of the proxy has the same result as observing properties of the actual instance.

The actual instance is allowed to escape the proxy and to create direct references to itself. The proxy may be released independently of the actual instance when it's not referenced anymore. The proxy and actual instance have distinct identities.

=== Common Behavior ===

After a successful initialization, the initializer function is not retained anymore by this object, and may be released if it's not referenced anywhere else.

The scope and <php>$this</php> of the initializer function is not changed, and usual visibility constraints apply. Visibility should not be a concern for the common use-case of calling the constructor in the initializer. However, for more complex use-cases where the initializer wishes to access non-public properties, it is required to bind the initializer function to the right scope, or to access properties with <php>ReflectionProperty</php>.

<PHP>
class MyClass {
    private $prop;
    public function __construct($prop) {
        $this->prop = $prop;
    }
}

$reflector = new ReflectionLazyObjectFactory(MyClass::class);

// Common use-case
$object = $reflector->newLazyGhostInstance(function ($object) {
    $object->__construct('value'); // Ok
});

// Complex use-case
$object = $reflector->newLazyGhostInstance(function ($object) use ($reflector) {
    $object->prop = 'value';                    // Error: Cannot access private property MyClass::$prop
    $propReflector = $reflector->getProperty('prop');
    $propReflector->setValue($object, 'value'); // Ok
});
</PHP>

If the initializer throws, the object properties are reverted to their pre-initialization state and the object is marked as lazy again. In other words, all effects on the object itself are reverted. Other side effects, such as side-effects on other objects, are not reverted. The goal is to not expose a half-initialized instance in case of failure.

The following example demonstrates what happens when nested initialization fail: 

<PHP>
class MyClass {
    public $propA;
    public $propB;
}

// Creating two lazy objects. The initializer of $object1 causes the initialization
// of $object2, which fails.

$reflector = new ReflectionLazyObjectFactory(MyClass::class);

$object2 = $reflector->newLazyGhostInstance(function ($object2) {
    $object2->propB = 'value';
    throw new \Exception('initializer exception');
});
$reflector->setRawPropertyValue($object2, 'propA', 'object-2');

$object1 = $reflector->newLazyGhostInstance(function ($object1) use ($object2) {
    $object1->propB = 'updated';
    $object1->propB = $object2->propB;
});
$reflector->setRawPropertyValue($object1, 'propA', 'object-1');

// Both objects are uninitalized at this point

var_dump($object1); // Object(MyClass) { "propA" => "object-1" }
var_dump($object2); // Object(MyClass) { "propA" => "object-2" }

try {
    var_dump($object1->propB); // Exception: initializer exeption
} catch (Exception $e) {
    echo $e->getMessage(), "\n";
}

// The state of both objects is unchanged 

var_dump($object1); // Object(MyClass) { "propA" => "object-1" }
var_dump($object2); // Object(MyClass) { "propA" => "object-2" }
</PHP>


==== Detailed API Behavior ====

=== newLazyGhostInstance() ===

<PHP>
    public function newLazyGhostInstance(callable $initializer, int $options = 0): object;
</PHP>

The <php>newLazyGhostInstance()</php> method instantiates an object without calling the constructor, and marks the object as lazy.

Properties are not initialized to their default value (they are initialized before calling the initializer). This is only mentioned for completeness, as this is not observable currently. 

The <php>$options</php> argument is a bitfield accepting the following flags:

  * <php>ReflectionLazyObjectFactory::SKIP_INITIALIZATION_ON_SERIALIZE</php>: By default, serializing a lazy object triggers its initialization. This flag disables that behavior, allowing lazy objects to be serialized as empty objects. This is useful in scenarios like Doctrine entities, where cascading serialization could be problematic.

An <php>Error</php> is raised if the class is internal or extends an internal class:

<PHP>
$reflector = new ReflectionLazyObjectFactory(ReflectionClass::class);
// Raises "Error: Cannot make instance of internal class lazy: ReflectionClass is internal"
$reflector->newLazyGhostInstance($initializer);
</PHP>

The return value is the created object.

The behavior of the returned object is described in the Initialization Triggers and Initialization Sequence sections.

=== newLazyProxyInstance() ===

<PHP>
    public function newLazyProxyInstance(callable $initializer, int $options = 0): object;
</PHP>

The behavior of the <php>newLazyProxyInstance()</php> method is the same as <php>newLazyGhostInstance()</php>, except that it uses the Proxy strategy.

=== makeInstanceLazyHost() === 

<PHP>
    public function makeInstanceLazyGhost(object $object, callable $initializer, int $options = 0): void;
</PHP>

The <php>makeInstanceLazyGhost()</php> method makes an existing object lazy. The indented use-case is for an object to manage its own lazyness by calling the method in its constructor.

The <php>$options</php> argument accepts the same flag as <php>newLazyGhostInstance()</php> in addition to:

  * <php>ReflectionLazyObjectFactory::SKIP_DESTRUCTOR</php>: By default, the <php>makeInstanceLazy*()</php> methods will call the destructor of an object (if any) before making it lazy. This provides safety regarding any preexisting state in the object. But when the object has just been created and is empty, calling the destructor is not desired and can be skipped with this flag.
  * <php>ReflectionLazyObjectFactory::SKIP_INITIALIZED_READONLY</php>: By default, the <php>makeInstanceLazy*()</php> methods will throw an exception if a readonly property was initialized (on the object itself or on a proxy's actual instance) and the class is final. If this flag is set, these properties are skipped and no exception is thrown. The behavior around readonly properties is explained in more details later.

When making an object lazy, the object destructor is called and the object is reset to a state equivalent to an instance created by <php>newLazyGhostInstance()</php>. In particular, all non-static properties are <php>unset()</php>. This effect could be achieved in user space with the Reflection API and Closure scopes:

<PHP>
(function () {
    $reflector = new ReflectionObject($this);
    foreach ($reflector->getProperties() as $prop) {
        unset($this->{$prop->getName()});
    }
})->bindTo($object, $object);
</PHP>

This snippet omits details such as static, private, readonly, or virtual properties for brevity.

The object is not replaced by an other one, and its identity does not change. Functionality such as <php>spl_object_id()</php>, <php>spl_object_hash()</php>, <php>SplObjectStorage</php>, <php>WeakMap</php>, <php>WeakReference</php>, or strict equality comparison are not affected by <php>makeInstanceLazy*()</php>.

<PHP>
$object = new MyClass();
$ref = WeakReference::create($object);
$id = spl_object_id($object);

new ReflectionLazyObjectFactory(MyClass::class)->makeInstanceLazyGhost($object, function () {});
var_dump($id === spl_object_id($object)); // bool(true)
var_dump($ref->get() === $object);        // bool(true)

ReflectionLazyObjectFactory::initialize($object);
var_dump($id === spl_object_id($object)); // bool(true)
var_dump($ref->get() === $object);        // bool(true)
</PHP>

If the object is already lazy, a <php>ReflectionException</php> is thrown with the message "Object is already lazy".

After calling <php>newLazyGhostInstance()</php>, the behavior of the object is the same as an object created by <php>newLazyGhostInstance()</php>.

=== makeInstanceLazyProxy() ===

<PHP>
    public function makeInstanceLazyProxy(object $object, callable $initializer, int $options = 0): void;
</PHP>

The behavior of the <php>makeInstanceLazyProxy()</php> method is the same as <php>makeInstanceLazyHost()</php>, except that it uses the Proxy strategy.

The object itself becomes the proxy. Similarly to <php>makeInstanceLazyGhost()</php>, the object is not replaced by an other one, and its identity does not change, even after initialization. The proxy and the actual instance are distinct objects, with distinct identities.

=== isInitialized() ===

<PHP>
    public static function isInitialized(object $object): bool;
</PHP>

The <php>isInitialized</php> method returns <php>true</php> if the object was initialized. It also returns <php>true</php> if the object has never been lazy, since an initialized lazy ghost is indistinguishable from an object that was never lazy.

=== initialize() ===

<PHP>
    public static function initialize(object $object, bool $skipInitializer = false): object;
</PHP>

The <php>initialize()</php> method can be use to force initialization of a lazy object. It has no effect if the object is already initialized.

If <php>$skipInitializer</php> is <php>true</php>, the behavior is the one described for Ghost Objects in the Initialization Sequence section, except that the initializer is not called.

The return value is the object itself for ghost objects (or if <php>$skipInitializer</php> is <php>true</php>), or the actual instance for proxy objects.

=== skipInitializerForProperty() ===

<PHP>
    public function skipInitializerForProperty(object $object, string $name, string $class = null): void;
</PHP>

The <php>skipInitializerForProperty()</php> method marks a property as non lazy such that it can be accessed directly without triggering initialization. It also initializes the property to its default value, if any.

<PHP>
class MyClass {
    public $id;
    public $b;
}

$reflector = new ReflectionLazyObjectFactory(MyClass::class);
$object = $reflector->newLazyGhostInstance(function () {});

$reflector->skipInitializerForProperty($object, 'id');

$object->id = 1;        // does not trigger initialization
var_dump($object->id); // int(1) (does not trigger initialization)
</PHP>

Accessing the property after calling this method has the same behavior as accessing it after constructing the object with <php>ReflectionClass::newInstanceWithoutConstructor()</php>, including throwing errors when accessing uninitialized properties.

The <php>$class</php> argument allows targeting the declaring class of a private property in the parent chain.

The property must be declared (can not be a dynamic property), non-static, and non-virtual.

The primary use-case of <php>skipInitializerForProperty()</php> and <php>setRawPropertyValue</php> is to initialize properties whose value is already known and whose access should not trigger initialization. For example, an ORM may initialize the properties representing the identity of an entity.

=== setRawPropertyValue() ===

<PHP>
    public function setRawPropertyValue(object $object, string $name, mixed $value, string $class = null): void;
</PHP>

The <php>setRawPropertyValue</php> is similar to <php>skipInitializerForProperty()</php>, but it allows to specify a value. It is more convenient than the latter when using the <php>$class</php> argument.

The method does not call hooks, if any, when setting the property value.

==== Cloning ====

The result of cloning an uninitialized lazy object is a new lazy object with the same initializer, and the same initialized properties (if <php>setRawPropertyValue()</php> or <php>skipInitializerForProperty()</php> were used).

If the object implements the <php>__clone()</php> magic method, and it accesses properties, initialization may be triggered before the object is returned by the <php>clone</php> operator.

Cloning an initialized lazy proxy returns a clone of the actual instance.

==== Readonly properties ====

The proposed changes preserve the semantics of readonly properties. The <php>makeInstanceLazy*()</php> methods may change the value of a readonly property, but this is already a possibility.

Currently, two consecutive observations of the value of a readonly property can yield different results in the following cases:

  * The property was not initialized at the time of the first observation, and was initialized at the time of the second one
  * The property is unset, and access is intercepted by a <php>__get</php> magic method

The last point implies that it is possible to induce this behavior on an existing class by sub-classing it:

<PHP>
class A {
    public readonly int $prop;
}
class B extends A {
    public int $counter = 0;
    public function __construct() {
        (function () {
            unset($this->prop);
        })->bindTo($this, A::class)();
    }
    public function __get($name) {
        return ++$this->counter;
    }
}

$b = new B();
var_dump($b->prop); // int(1)
var_dump($b->prop); // int(2)
</PHP>

It follows that the observable value of a readonly property can change unless the class is final.

We preserve these semantics by never changing or unsetting a readonly property in the <php>makeInstanceLazy*()</php> methods, if the property is initialized (on the object itself or the actual instance, for initialized proxies) and the class is final. Calling <php>makeInstanceLazy*()</php> on a class with such property will throw an Error. Using the <php>SKIP_INITIALIZED_READONLY</php> flag ignores these properties instead of throwing an Error.

==== Destructors ====

The destructor of ghost objects is called if and only if the object has been initialized.

The destructor of virtual state proxy objects is never called. We rely on the destructor of the proxied instance instead.

When making an existing object lazy, the <php>makeInstanceLazy*()</php> methods call the destructor unless the <php>SKIP_DESTRUCTOR</php> flag is given.

===== About Lazy-Loading Strategies =====

This RFC proposes adding the ghost and virtual state-proxy strategies to the engine. One might wonder why two strategies are needed instead of just one.

The most transparent and thus default strategy should be the ghost one. Ghost objects handle initialization in place, meaning that once they are initialized, they are exactly like regular objects.

As an example, the Doctrine ORM implements lazy-loading of entities by employing a user-space implementation of ghost objects. The following snippet illustrates how it would use the proposed API: 

<PHP>
// User code

class BlogPost
{
    private int $id;
    private string $name;
    private string $email;
}

// ORM code

class EntityManager
{
    public function getReference(string $class, int $id)
    {
        // The reflector instances are cached in practice
        $reflector = new ReflectionLazyObjectFactory($class);

        $entity = $reflector->newLazyGhostInstance(function ($entity) use ($class, $id, $reflector) {
            $data = $this->loadFromDatabase($class, $id);
            $reflector->getProperty('name')->setValue($entity, $data['name']);
            $reflector->getProperty('email')->setValue($entity, $data['email']);
        });

        // id is already known and can be accessed without triggering initialization
        $reflector->setPropertyValue($entity, 'id', $id);

        return $entity;
    }
}
</PHP>

This strategy is suitable when we control the instantiation and initialization of the object. This excludes its use when either of these is controlled by an other party.

As an example, the Symfony Dependency Injection component allows to defer the initialization of some parts of the dependency graph by lazy-loading select dependencies. It employs the virtual state-proxy strategy when a dependency is to be instantiated and initialized by a user-provided factory. The following snippet illustrates how it would use the proposed API:

<PHP>
// User code

class ClientFactory
{
    public function createClient() {
        return new Client($this->hostname, $this->credentials);
    }
}

class Client
{
}

// Symfony code

class Container
{
    public function getClientService(): Client
    {
        $reflector = new ReflectionLazyObjectFactory(Client::class);
        
        $client = $reflector->newLazyProxyInstance(function () use ($container) {
            $clientFactory = $container->get('client_factory');
            return $clientFactory->createClient();
        });
        
        return $client;
    }
</PHP>

===== About Virtual Proxies =====

When considering virtual proxies, one might expect the implementation to rely on decorating every method of a target class (or interface). This type of proxy is called a virtual inheritance-proxy.

Lazy virtual inheritance-proxies decorate every method of a target class or interface to prepend the initialization logic. This logic creates another instance to which all method calls are forwarded. The benefits of this strategy are compatibility with internal classes and interfaces, allowing final classes implementing an interface to be made lazy. However, this strategy has a major drawback: it breaks object identity. If a method returns <php>$this</php>, it returns the decorated object, not the proxy.

The virtual state-proxy strategy proposed by this RFC relies on proxying property accesses instead of methods. Methods are called on the state-proxy itself, so when a method returns <php>$this</php>, it returns the state-proxy object. This approach minimizes identity issues.

Since the state-proxy strategy requires accessing the properties of the decorated object, it is not compatible with internal classes or interfaces. Therefore, virtual inheritance-proxies still have use cases. However, this proposal focuses on providing ghost objects and virtual state-proxies natively, not virtual inheritance-proxies.

There are several reasons for that:

  - Ghost objects and virtual state-proxies hook into the same place in the engine, simplifying the RFC and the corresponding patch.
  - These strategies benefit the most from being in the engine: userland implementation relies on complex magic accessors, is difficult to maintain as new PHP versions are released, and is slower than what can be achieved with engine support.
  - It's unclear if the engine would significantly help with virtual inheritance-proxies: implementing or generating code to decorate methods is simpler.

<php>ReflectionLazyObjectFactory::initialize()</php> returns the backing object to aid in implementing virtual inheritance-proxies in userland. The previous description was simplified: virtual inheritance-proxies should also proxy public property accesses in addition to method calls.

Here is an example of a (non-optimized) lazy-loading virtual inheritance-proxy using this RFC:

<PHP>
class Connection
{
    public float $ttl = 1.0;

    public function send(string $data): void
    {
        // Real implementation we want to make lazy
    }
}

class LazyConnection extends Connection
{
    public function __construct()
    {
        ReflectionLazyObject::makeLazyProxy($this, $this->initialize(...), ReflectionLazyObject::SKIP_DESTRUCTOR);
    }

    public function send(string $data): void
    {
        new ReflectionLazyObjectFactory($this)->initialize($this)->send($data);
    }

    private function initialize(): parent
    {
        $connection = new parent(); // Or any heavier initialization logic
        $connection->ttl = 2.0;

       return $connection;
    }
}

$connection = new LazyConnection();

echo $connection->ttl; // echoes 2.0
</PHP>

===== Future scope =====

Lazy objects are an advanced feature that most users will not use directly. This feature is primarily targeted at library and framework authors.

FFI and Fibers are examples of features recently added to PHP that most users may not use directly, but can benefit from greatly within libraries they use.

As such, the authors do not plan to add higher-level syntax for creating lazy objects.

Furthermore, it is not intended to add class-centric constructs based on attributes or magic methods, as this approach is orthogonal to the objective of this RFC, which is to create lazy objects without requiring cooperation from the class.

However, it is possible to introduce a higher-level syntax or class-centric constructs in a future RFC. 

===== Backward Incompatible Changes =====

Introduction of class <php>ReflectionLazyObjectFactory</php> in the global namespace may break applications declaring a class with this name.

===== Proposed PHP Version(s) =====

PHP 8.4

===== Proposed Voting Choices =====

Add lazy-objects as described to the engine: yes/no (2/3 required to pass)

===== Patches and Tests =====

https://github.com/arnaud-lb/php-src/tree/lazy-objects