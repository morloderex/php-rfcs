====== PHP RFC: Lazy Objects ======

  * Version: 1.0
  * Date: 2024-06-03
  * Author: Arnaud Le Blanc <arnaud.lb@gmail.com>, Nicolas Grekas <nicolasgrekas@php.net>
  * Status: Draft
  * First Published at: https://wiki.php.net/rfc/lazy-objects

===== Introduction =====

Transparent lazy-initialization of objects is an important part of many PHP applications. However, achieving this kind of laziness in userland is complex, limited, and can have a significant performance impact. This proposal aims to bring lazy initialization to the PHP engine to mitigate these drawbacks.

Martin Fowler identifies [[https://martinfowler.com/eaaCatalog/lazyLoad.html|four strategies]] to implement lazy loading using OOP: lazy initialization, value holders, virtual proxies, and ghost objects. This RFC focuses on virtual proxies and ghost objects, which provide transparent lazy-loading. Unlike lazy initialization and value holders, virtual proxies and ghost objects do not require a class to be written with the lazy-loading concept in mind. Instead, the lazy-loading behavior can be attached externally.

In both strategies, we start with empty objects typically created with <php>ReflectionClass::newInstanceWithoutConstructor()</php>, attaching an initializer that is called automatically when these objects are used. From an abstraction point of view, lazy objects from this RFC are indistinguishable from non-lazy ones: they can be used without knowing they are lazy.

Lazy-loading of objects in PHP is already used in business-critical situations. For example, Symfony uses them in its dependency injection component to provide lazy services that are fully initialized only if needed. The Doctrine ORM makes its entities lazy, allowing objects to hydrate themselves from the database only when accessed. Other use cases include a JSON parser that uses lazy objects to defer parsing unless those objects are accessed.

Implementing virtual proxies and ghost objects in userland is non-trivial. This has been explored in the [[https://packagist.org/packages/ocramius/proxy-manager|ocramius/proxy-manager]] library and later in the [[https://packagist.org/packages/symfony/var-exporter|symfony/var-exporter]]. Current implementations have several limitations, including incompatibility with final, and performance overhead due to magic methods. This RFC proposes to implement ghost objects and virtual state-proxies natively in the engine to address these issues.

===== Implementation =====

Lazy objects are standard ''zend_object'' whose initialization is deferred until one of their properties is accessed. This is implemented using the same fallback mechanism as ''%%__get%%'' and ''%%__set%%'' magic methods, triggered when an uninitialized property is accessed. No performance overhead is thus added to non-lazy use cases. Execution of methods or property hooks does not trigger initialization until one of them accesses a backed property.

A lazy object can be created via the Reflection API, with the user specifying an initializer function that is called when initialization is required.

There are two kinds of lazy objects:

  * Ghost: These are initialized in-place by the initializer function.
  * Virtual: The initializer returns a new instance, and interactions with the virtual object are proxied to this instance.

Internal objects are not supported because their state is usually not managed via regular properties.

It should be noted that the proposed Reflection API has been tested successfully on the Doctrine and on the Symfony projects, allowing to remove a bunch of hard-to-maintain code while improving transparency of lazy objects and keeping the test suite green with the same public API.

===== Proposal =====

This RFC proposes adding the following Reflection class to the PHP engine:

<PHP>
class ReflectionLazyObject extends ReflectionObject
{
    public int const SKIP_INITIALIZATION_ON_SERIALIZE = 1;
    public int const STRATEGY_GHOST = 2;
    public int const STRATEGY_VIRTUAL = 4;

    /**
     * Turns an object into a lazy object.
     *
     * When using the ghost strategy, the initializer is
     * called with the ghost object to initialize as argument
     * and it should initialize all its properties.
     *
     * When using the virtual strategy, the initializer is
     * called with the virtual proxy as argument and it should
     * return the backing instance to proxy.
     *
     * The ghost strategy is used by default.
     */
    public static function makeLazy(object $instance, callable $initializer, int $strategy = 0): self;

    /**
     * Returns whether an object is a lazy object.
     */
    public static function isLazyObject(object $instance): bool;

    /**
     * Returns a ReflectionLazyObject corresponding to the passed object if it's a lazy one, null otherwise.
     */
    public static function fromInstance(object $instance): ?self;

    /**
     * Initializes a lazy object (no-op if the object is already initialized.)
     *
     * The backing object is returned, which can be another instance than the lazy object when the virtual strategy is used.
     */
    public function initialize(bool $skipInitializer = false): object;

    /**
     * Marks a property as *not* triggering initialization when being accessed.
     * 
     * The property is set to its default value if any.
     * This method is useful to bypass initialization when setting a property.
     */
    public function skipProperty(string $name, string $class = null): void;

    /**
     * Sets a property *without* triggering initialization while getting through hooks if any.
     */
    public function setProperty(string $name, mixed $value, string $class = null): void;

    /**
     * Sets a property *without* triggering initialization while skipping hooks if any.
     */
    public function setRawProperty(string $name, mixed $value, string $class = null): void;
}
</PHP>

==== Creating a Lazy Object ====

The entry point to create a lazy object is the <php>ReflectionLazyObject::makeLazy()</php> static method.

<PHP>
class MyClass
{
    public function __construct(private int $foo)
    {
        // Heavy initialization logic here.
    }

    // ...
}

$initializer = static function (MyClass $ghost): void {
    $ghost->__construct(123);
};

$object = new ReflectionClass(MyClass::class)->newInstanceWithoutConstructor();
$lazyReflector = ReflectionLazyObject::makeLazy($object, $initializer);

// At this point, $object is a lazy ghost object.
</PHP>

Creating a lazy virtual state-proxy requires using the <php>$strategy</php> argument:

<PHP>
$initializer = static function (MyClass $proxy): MyClass {
    return new MyClass(123);
};

$object = new ReflectionClass(MyClass::class)->newInstanceWithoutConstructor();
$lazyReflector = ReflectionLazyObject::makeLazy($object, $initializer, ReflectionLazyObject::STRATEGY_VIRTUAL);
</PHP>

The <php>$strategy</php> argument is a bitfield that also accepts the <php>ReflectionLazyObject::SKIP_INITIALIZATION_ON_SERIALIZE</php> flag. By default, serializing a lazy object triggers its initialization. This flag disables that behavior, allowing lazy objects to be serialized as empty objects. This is useful in scenarios like Doctrine entities, where cascading serialization could be problematic.

Passing both ghost and virtual strategy flags triggers a <php>ReflectionException</php> with the message "Flags STRATEGY_GHOST and STRATEGY_VIRTUAL are mutually exclusive."

If an object is already lazy, a <php>ReflectionException</php> is thrown with the message "Object is already lazy".

By accepting an already created instance, the <php>makeLazy()</php> method also allows writing classes that manage their own laziness:

<PHP>
class MyLazyClass
{
    public function __construct()
    {
        ReflectionLazyObject::makeLazy($this, $this->initialize(...));
    }

    // ...
}
</PHP>

An <php>Error</php> is raised if the class passed to the <php>makeLazy()</php> method is internal or extends an internal class:

<PHP>
// Raises "Error: Cannot make instance of internal class lazy: ReflectionClass is internal"
ReflectionLazyObject::makeLazy(new ReflectionClass(), $initializer);
</PHP>

==== Handling the State of Lazy Objects ====

Any access to properties of a lazy object triggers its initialization (including via <php>ReflectionProperty</php>). However, certain properties might be known ahead of time and should not trigger initialization when accessed:

<PHP>
class BlogPost
{
    public function __construct(private int $id, private string $title, private string $content)
    {
    }
}

$classReflector = new ReflectionClass(BlogPost::class);
$post = $classReflector->newInstanceWithoutConstructor();
$initializer = // Callable that retrieves the title and content from the database.
$lazyReflector = ReflectionLazyObject::makeLazy($post, $initializer);

// Without this line, the following call to ReflectionProperty::setValue() would trigger initialization.
$lazyReflector->skipProperty('id');
$classReflector->getProperty('id')->setValue($post, 123);

// Alternatively, one can use this directly:
$lazyReflector->setProperty('id', 123);
</PHP>

The <php>skipProperty()</php> / <php>set[Raw]Property()</php> methods provide ways to disable lazy-initialization when a property is accessed, allowing users to choose the approach that best fits their design. The <php>$class</php> argument of these methods allows targeting the declaring class of a private property in the parent chain.

==== Lifecycle of Lazy Objects ====

An object is considered lazy if any of its properties are still hooked to the initializer passed to <php>makeLazy()</php>.

There are three ways to make a lazy object non-lazy:

  - Interacting with it in a way that triggers its initializer (more on this bellow).
  - Using <php>ReflectionLazyObject::skipProperty()</php> or <php>set[Raw]Property()</php> on all its properties.
  - Calling the <php>initialize()</php> method of a <php>ReflectionLazyObject</php> instance.

During the PHP application's lifetime, one can get a <php>ReflectionLazyObject</php> from a lazy object using <php>ReflectionLazyObject::fromInstance()</php>. If the object is not lazy, null is returned.

To check if an object is still lazy after obtaining a <php>ReflectionLazyObject</php> instance, use <php>ReflectionLazyObject::isLazyObject()</php>.

The <php>initialize()</php> method's <php>bool $skipInitializer</php> argument (default <php>false</php>) allows marking a lazy object as non-lazy without running the initializer, leaving uninitialized properties. This is useful for managed entity objects. Accessing a property before it is set throws an "uninitialized property" error.

If a <php>ReflectionLazyObject</php> is used after its corresponding lazy object has been initialized, the <php>initialize()</php> and <php>skipProperty()</php> methods do nothing, while the <php>set[Raw]Property()</php> methods set the corresponding property as expected.

==== Initialization Triggers ====

Except for the special cases listed below, any attempt to observe the state of a lazy object will trigger its initialization. This ensures that the result of the observation is the same as if the object were already initialized, maintaining full transparency. These triggers include:

  * Reading or writing a property
  * Testing if a property is set or unsetting it
  * Calling <php>ReflectionProperty::getValue()</php> and <php>setValue()</php>
  * Calling <php>ReflectionObject::getProperties()</php>

This behavior makes lazy objects fully transparent to their consumers.

The following special cases do not trigger initialization of a lazy object:

  * Calls to <php>ReflectionLazyObject::skipProperty()</php>, <php>setProperty()</php>, <php>setRawProperty()</php>, or accesses to properties on which these methods were called.
  * Calls to <php>get_object_vars()</php>.
  * Calls to <php>serialize()</php> when <php>ReflectionLazyObject::SKIP_INITIALIZATION_ON_SERIALIZE</php> is set, unless a property is accessed in ''%%__serialize()%%'' or ''%%__sleep()%%'' methods.
  * Calls to <php>ReflectionObject::__toString()</php>.
  * Casting to array using the <php>(array)</php> operator.

By excluding these cases from triggering initialization, developers can perform certain operations on lazy objects without causing them to initialize, providing finer control over the initialization process.

==== Initialization Sequence ====

=== Ghost Objects ===

  - Before calling the initializer, properties that were not initialized with <php>ReflectionLazyObject::skipProperty()</php>, <php>ReflectionLazyObject::setProperty()</php>, <php>ReflectionLazyObject::setRawProperty()</php> are initialized to their default value, in the same way as using <php>new</php> or <php>ReflectionClass::newInstanceWithoutConstructor()</php>.
  - The initializer is called with the object as first parameter.
  - The object is marked as non-lazy and the initializer is released.

If an exception is thrown while calling the initializer, the object is reverted to its pre-initialization state and is still considered lazy.

After initialization, properties are accessed directly.

=== Virtual Objects ===

  - The initializer is called with the lazy proxy as first parameter.
  - The actual instance is set to the return value.
  - The object is marked as initialized.
  - Properties that were initialized with <php>ReflectionLazyObject::skipProperty()</php>, <php>ReflectionLazyObject::setProperty()</php>, <php>ReflectionLazyObject::setRawProperty()</php> as uninitialized.

After initialization, property accesses are proxied to the actual instance.

==== Destructors ====

The destructor of lazy non-initialized objects is not called.

===== About Lazy-Loading Strategies =====

This RFC proposes to add the ghost and virtual state-proxy strategies to the engine. One might wonder why two and not just one strategy is needed?

The most transparent and thus the default strategy should be the ghost one. Ghost objects handle initialization in place, which means that once they are initialized, they are exactly like regular objects. But they have to be created ahead of time and populated later on. This excludes using them when the initialization logic involves a factory that ends up creating circular references.

Consider this:

<PHP>
class Manager
{
    private Dispatcher $dispatcher;

    public function setDispatcher(Dispatcher $dispatcher)
    {
        $this->dispatcher = $dispatcher;
    }

    public static function createManager(): self
    {
        $manager = new self();
        $manager->setDispatcher(new Dispatcher());
        
        return $manager;
    }
}

class Dispatcher
{
    public function __construct(private Manager $manager)
    {
    }
}
</PHP>

Using the <php>Manager::createManager()</php> factory is not compatible with ghost objects, because their initializer requires initializing the ghost object in place, while the factory method returns a separate instance. One could try to copy all properties of the factory instance onto the ghost object, but accounting for circular references would mean inspecting recursively all the dependencies of the factory instance to figure that the <php>$manager</php> property of the internal Dispatcher object should also be updated to point to the ghost object. Doing so is next to impossible, and certainly not performant.

Because they return a separate instance, virtual state-proxies are compatible with such situations.

But then, why do we need ghost objects? The reason is object identity. When using virtual proxies, there are two objects which are identical from a conceptual point of view, but are different from an identity point of view. In use cases of e.g. entity managers, where the identity of objects is used to manage them, having more that one concrete objects to represent the same logical object can lead to fragile code.

===== About Virtual Proxies =====

When thinking about virtual proxies, one might expect the implementation to rely on decorating every single methods of a target class (or interface). Let's call this kind of proxy a virtual inheritance-proxy.

Virtual inheritance-proxies decorate every methods of a target class or interface in order to prepend the initialization logic to each of them. This initialization logic is in charge of creating another instance to which all method calls are then forwarded. The main benefits of this strategy are that it's compatible with internal classes and also with interfaces, so that final classes implementing some interface can be made lazy by this interface. But this strategy has a major drawback: it trivially breaks object identity. If a method returns <php>$this</php>, this <php>$this</php> is the decorated object and not the proxy one.

That's where the virtual state-proxy strategy as proposed by this RFC shines: instead of proxying methods, it relies on proxying property accesses. Because the methods are then called on the state-proxy itself and not on the proxied instance, when such a method returns <php>$this</php>, the state-proxy object itself is returned. This makes it much harder to fall into issues with identity of objects.

Because the state-proxy strategy requires accessing the properties of the decorated object, it's not compatible with internal classes nor with interfaces. For this reason, virtual inheritance-proxies still have a use case. Yet, this proposal is specifically about providing ghost objects and virtual state-proxies natively, not virtual inheritance-proxies.

There are a few reasons for that:

  - Ghost objects and virtual state-proxies hook in the same place in the engine. This makes the RFC and the corresponding patch simpler and consistent.
  - They are also the ones that benefit the most from being in the engine: the userland implementation relies on complex magic accessors, is hard to maintain as new versions of PHP are shipped, and is way slower than what can be achieve with the help of the engine.
  - It's not sure that the engine would really be of significant help for virtual inheritance-proxies: implementing or generating code to decorate methods is way simpler.

Actually, <php>ReflectionLazyObject::initialize()</php> returns the backing object in order to help with implementing virtual inheritance-proxies in userland. Indeed, the previous description was simplified: virtual inheritance-proxies should also proxy public property accesses in addition to method calls.

Here is how one can implement a (non-optimized) lazy-loading virtual inheritance-proxy with the help of this RFC:

<PHP>
class Connection
{
    public float $ttl = 1.0;

    public function send(string $data): void
    {
        // do something, this is the real implementation we want to make lazy
    }
}

class LazyConnection extends Connection
{
    public function __construct()
    {
        ReflectionLazyObject::makeLazy($this, $this->initialize(...), ReflectionLazyObject::STRATEGY_VIRTUAL);
    }

    public function send(string $data): void
    {
        ReflectionLazyObject::fromInstance($this)->initialize()->send($data);
    }

    private function initialize(): parent
    {
        $connection = new parent(); // or any heavier initialization logic
        $connection->ttl = 2.0;

       return $connection;
    }
}

$connection = new LazyConnection();

echo $connection->ttl; // echoes 2.0
</PHP>

===== Backward Incompatible Changes =====

None - all existing semantics are preserved.

===== Proposed PHP Version(s) =====

PHP 8.4

===== Proposed Voting Choices =====

Add lazy-objects as described to the engine: yes/no (2/3 required to pass)

===== Patches and Tests =====

https://github.com/arnaud-lb/php-src/tree/lazy-objects