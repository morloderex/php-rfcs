====== PHP RFC: Lazy Objects ======

  * Version: 1.0
  * Date: 2024-06-03
  * Author: Arnaud Le Blanc <arnaud.lb@gmail.com>, Nicolas Grekas <nicolasgrekas@php.net>
  * Status: Under Discussion
  * First Published at: https://wiki.php.net/rfc/lazy-objects

===== Introduction =====

Transparent lazy-initialization of objects is an important part of many PHP applications. However, achieving this kind of laziness in userland is complex, limited, and can have a significant performance impact. This proposal aims to bring lazy initialization to the PHP engine to mitigate these drawbacks.

Martin Fowler identifies [[https://martinfowler.com/eaaCatalog/lazyLoad.html|four strategies]] to implement lazy loading using OOP: lazy initialization, value holders, virtual proxies, and ghost objects. This RFC focuses on virtual proxies and ghost objects, which provide transparent lazy-loading. Unlike lazy initialization and value holders, virtual proxies and ghost objects do not require a class to be written with the lazy-loading concept in mind. Instead, the lazy-loading behavior can be attached externally.

In both strategies, we start with empty objects typically created with <php>ReflectionClass::newInstanceWithoutConstructor()</php>, attaching an initializer that is called automatically when these objects are used. From an abstraction point of view, lazy objects from this RFC are indistinguishable from non-lazy ones: they can be used without knowing they are lazy.

Lazy-loading of objects in PHP is already used in business-critical situations. For example, Symfony uses them in its dependency injection component to provide lazy services that are fully initialized only if needed. The Doctrine ORM makes its entities lazy, allowing objects to hydrate themselves from the database only when accessed. Other use cases include a JSON parser that uses lazy objects to defer parsing unless those objects are accessed.

Implementing virtual proxies and ghost objects in userland is non-trivial. This has been explored in the [[https://packagist.org/packages/ocramius/proxy-manager|ocramius/proxy-manager]] library and later in the [[https://packagist.org/packages/symfony/var-exporter|symfony/var-exporter]] one. Current implementations have several limitations, including incompatibility with final classes, and performance overhead due to magic methods. This RFC proposes to implement ghost objects and virtual state-proxies natively in the engine to address these issues.

===== Implementation =====

Lazy objects are standard ''zend_object'' whose initialization is deferred until one of their properties is accessed. This is implemented using the same fallback mechanism as ''%%__get%%'' and ''%%__set%%'' magic methods, triggered when an uninitialized property is accessed. No performance overhead is thus added to non-lazy use cases. Execution of methods or property hooks does not trigger initialization until one of them accesses a backed property.

A lazy object can be created via the Reflection API, with the user specifying an initializer function that is called when initialization is required.

There are two kinds of lazy objects:

  * Ghost: These are initialized in-place by the initializer function.
  * Virtual: The initializer returns a new instance, and interactions with the virtual object are proxied to this instance.

Internal objects are not supported because their state is usually not managed via regular properties.

It should be noted that the proposed Reflection API has been tested successfully on the Doctrine and on the Symfony projects, allowing to remove a bunch of hard-to-maintain code while improving transparency of lazy objects and keeping the test suite green with the same public API.

===== Proposal =====

This RFC proposes adding the following Reflection class to the PHP engine:

<PHP>
class ReflectionLazyObject extends ReflectionObject
{
    public int const SKIP_INITIALIZATION_ON_SERIALIZE = 1;

    /**
     * Turns an object into a lazy ghost object.
     *
     * The initializer is called with the ghost object to initialize
     * as argument and it should initialize all its properties.
     */
    public static function makeLazyGhost(object $instance, callable $initializer, int $options = 0): self;

    /**
     * Turns an object into a lazy virtual state-proxy object.
     *
     * The initializer is called with the virtual proxy as argument
     * and it should return the backing instance to proxy.
     */
    public static function makeLazyProxy(object $instance, callable $initializer, int $options = 0): self;

    /**
     * Returns whether an object is a lazy object.
     */
    public static function isLazyObject(object $instance): bool;

    /**
     * Returns a ReflectionLazyObject corresponding to the passed object if it's a lazy one, null otherwise.
     */
    public static function fromInstance(object $instance): ?self;

    /**
     * Initializes a lazy object (no-op if the object is already initialized.)
     *
     * The backing object is returned, which can be another instance than the lazy object when the virtual strategy is used.
     */
    public function initialize(bool $skipInitializer = false): object;

    /**
     * Marks a property as *not* triggering initialization when being accessed.
     * 
     * The property is set to its default value if any.
     * This method is useful to bypass initialization when setting a property.
     */
    public function skipProperty(string $name, string $class = null): void;

    /**
     * Sets a property *without* triggering initialization while getting through hooks if any.
     */
    public function setProperty(string $name, mixed $value, string $class = null): void;

    /**
     * Sets a property *without* triggering initialization while skipping hooks if any.
     */
    public function setRawProperty(string $name, mixed $value, string $class = null): void;
}
</PHP>

==== Creating a Lazy Object ====

The entry points to create a lazy object are the <php>ReflectionLazyObject::makeLazyGhost()</php> and <php>makeLazyProxy()</php>static methods.

<PHP>
class MyClass
{
    public function __construct(private int $foo)
    {
        // Heavy initialization logic here.
    }

    // ...
}

$initializer = static function (MyClass $ghost): void {
    $ghost->__construct(123);
};

$object = new ReflectionClass(MyClass::class)->newInstanceWithoutConstructor();
$lazyReflector = ReflectionLazyObject::makeLazyGhost($object, $initializer);

// At this point, $object is a lazy ghost object.
</PHP>

Creating a lazy virtual state-proxy requires using the <php>makeLazyProxy()</php> static method.
Note how the initializer returns a new instance while the previous one was initializing the ghost in-place:

<PHP>
$initializer = static function (MyClass $proxy): MyClass {
    return new MyClass(123);
};

$object = new ReflectionClass(MyClass::class)->newInstanceWithoutConstructor();
$lazyReflector = ReflectionLazyObject::makeLazyProxy($object, $initializer);
</PHP>

The <php>$options</php> argument is a bitfield that accepts the <php>ReflectionLazyObject::SKIP_INITIALIZATION_ON_SERIALIZE</php> flag. By default, serializing a lazy object triggers its initialization. This flag disables that behavior, allowing lazy objects to be serialized as empty objects. This is useful in scenarios like Doctrine entities, where cascading serialization could be problematic.

If an object is already lazy, a <php>ReflectionException</php> is thrown with the message "Object is already lazy".

By accepting an already created instance, the <php>makeLazy*()</php> methods also allows writing classes that manage their own laziness:

<PHP>
class MyLazyClass
{
    public function __construct()
    {
        ReflectionLazyObject::makeLazyGhost($this, $this->initialize(...));
    }

    // ...
}
</PHP>

An <php>Error</php> is raised if the class passed to the <php>makeLazy*()</php> methods is internal or extends an internal class:

<PHP>
// Raises "Error: Cannot make instance of internal class lazy: ReflectionClass is internal"
ReflectionLazyObject::makeLazyGhost(new ReflectionClass(), $initializer);
</PHP>

==== Handling the State of Lazy Objects ====

Any access to properties of a lazy object triggers its initialization (including via <php>ReflectionProperty</php>). However, certain properties might be known ahead of time and should not trigger initialization when accessed:

<PHP>
class BlogPost
{
    public function __construct(private int $id, private string $title, private string $content)
    {
    }
}

$classReflector = new ReflectionClass(BlogPost::class);
$post = $classReflector->newInstanceWithoutConstructor();
$initializer = // Callable that retrieves the title and content from the database.
$lazyReflector = ReflectionLazyObject::makeLazyGhost($post, $initializer);

// Without this line, the following call to ReflectionProperty::setValue() would trigger initialization.
$lazyReflector->skipProperty('id');
$classReflector->getProperty('id')->setValue($post, 123);

// Alternatively, one can use this directly:
$lazyReflector->setProperty('id', 123);
</PHP>

The <php>skipProperty()</php> / <php>set[Raw]Property()</php> methods provide ways to disable lazy-initialization when a property is accessed, allowing users to choose the approach that best fits their design. The <php>$class</php> argument of these methods allows targeting the declaring class of a private property in the parent chain.

==== Lifecycle of Lazy Objects ====

An object is considered lazy if any of its properties are still hooked to the initializer passed to the <php>makeLazy*()</php> that made it lazy.

There are three ways to make a lazy object non-lazy:

  - Interacting with it in a way that triggers its initializer (more on this bellow).
  - Using <php>ReflectionLazyObject::skipProperty()</php> or <php>set[Raw]Property()</php> on all its properties.
  - Calling the <php>initialize()</php> method of a <php>ReflectionLazyObject</php> instance.

During the PHP application's lifetime, one can get a <php>ReflectionLazyObject</php> from a lazy object using <php>ReflectionLazyObject::fromInstance()</php>. If the object is not lazy, null is returned.

To check if an object is still lazy after obtaining a <php>ReflectionLazyObject</php> instance, use <php>ReflectionLazyObject::isLazyObject()</php>.

The <php>initialize()</php> method's <php>bool $skipInitializer</php> argument (default <php>false</php>) allows marking a lazy object as non-lazy without running the initializer, leaving uninitialized properties. This is useful for managed entity objects. Accessing a property before it is set throws an "uninitialized property" error.

If a <php>ReflectionLazyObject</php> is used after its corresponding lazy object has been initialized, the <php>initialize()</php> and <php>skipProperty()</php> methods do nothing, while the <php>set[Raw]Property()</php> methods set the corresponding property as expected.

==== Initialization Triggers ====

Except for the special cases listed below, any attempt to observe the state of a lazy object will trigger its initialization. This ensures that the result of the observation is the same as if the object were already initialized, maintaining full transparency. These triggers include:

  * Reading or writing a property
  * Testing if a property is set or unsetting it
  * Calling <php>ReflectionProperty::getValue()</php> and <php>setValue()</php>
  * Calling <php>ReflectionObject::getProperties()</php>

This behavior makes lazy objects fully transparent to their consumers.

The following special cases do not trigger initialization of a lazy object:

  * Calls to <php>ReflectionLazyObject::skipProperty()</php>, <php>setProperty()</php>, <php>setRawProperty()</php>, or accesses to properties on which these methods were called.
  * Calls to <php>get_object_vars()</php> and <php>get_mangled_object_vars()</php>.
  * Calls to <php>serialize()</php> when <php>ReflectionLazyObject::SKIP_INITIALIZATION_ON_SERIALIZE</php> is set, unless a property is accessed in ''%%__serialize()%%'' or ''%%__sleep()%%'' methods.
  * Calls to <php>ReflectionObject::__toString()</php>.
  * Casting to array using the <php>(array)</php> operator.
  * Calls to <php>var_dump($lazyObject)</php>, unless ''%%__debugInfo()%%'' is implemented and accesses a property.
  * Cloning, unless ''%%__clone()%%'' is implemented and accesses a property.

By excluding these cases from triggering initialization, developers can perform certain operations on lazy objects without causing them to initialize, providing finer control over the initialization process.

==== Initialization Sequence ====

=== Ghost Objects ===

  - Before calling the initializer, properties that were not initialized with <php>ReflectionLazyObject::skipProperty()</php>, <php>ReflectionLazyObject::setProperty()</php>, <php>ReflectionLazyObject::setRawProperty()</php> are initialized to their default value, in the same way as using <php>new</php> or <php>ReflectionClass::newInstanceWithoutConstructor()</php>.
  - The initializer is called with the object as first parameter.
  - The object is marked as non-lazy and the initializer is released.

If an exception is thrown while calling the initializer, the object is reverted to its pre-initialization state and is still considered lazy.

After initialization, properties are accessed directly.

=== Virtual Objects ===

  - The initializer is called with the lazy proxy as first parameter.
  - The return value of the initializer has to be an instance of a parent or a child class of the lazy-object and it must have the same properties. A TypeError is thrown is that's not the case.
  - The actual instance is set to the return value.
  - The object is marked as initialized.
  - Properties that were initialized with <php>ReflectionLazyObject::skipProperty()</php>, <php>ReflectionLazyObject::setProperty()</php>, <php>ReflectionLazyObject::setRawProperty()</php> are uninitialized.

After initialization, property accesses are proxied to the actual instance.

==== Destructors ====

The destructor of lazy non-initialized objects is not called.

===== About Lazy-Loading Strategies =====

This RFC proposes adding the ghost and virtual state-proxy strategies to the engine. One might wonder why two strategies are needed instead of just one.

The most transparent and thus default strategy should be the ghost one. Ghost objects handle initialization in place, meaning that once they are initialized, they are exactly like regular objects. However, they must be created ahead of time and populated later. This excludes their use when the initialization logic involves a factory that creates circular references.

Consider this example:

<PHP>
class Manager
{
    private Dispatcher $dispatcher;

    public function setDispatcher(Dispatcher $dispatcher)
    {
        $this->dispatcher = $dispatcher;
    }

    public static function createManager(): self
    {
        $manager = new self();
        $manager->setDispatcher(new Dispatcher($manager));
        
        return $manager;
    }
}

class Dispatcher
{
    public function __construct(private Manager $manager)
    {
    }
}
</PHP>

Using the <php>Manager::createManager()</php> factory is not compatible with ghost objects because their initializer requires initializing the ghost object in place, while the factory method returns a separate instance. Attempting to copy all properties from the factory instance to the ghost object and handling circular references would be impractical and non-performant.

Virtual state-proxies are compatible with such situations because they return a separate instance.

However, ghost objects are necessary due to object identity. When using virtual proxies, there are two objects: the proxy and the actual instance. This can lead to issues in use cases where object identity is crucial, such as entity managers. Having more than one concrete object representing the same logical object can lead to fragile code.

===== About Virtual Proxies =====

When considering virtual proxies, one might expect the implementation to rely on decorating every method of a target class (or interface). This type of proxy is called a virtual inheritance-proxy.

Virtual inheritance-proxies decorate every method of a target class or interface to prepend the initialization logic. This logic creates another instance to which all method calls are forwarded. The benefits of this strategy are compatibility with internal classes and interfaces, allowing final classes implementing an interface to be made lazy. However, this strategy has a major drawback: it breaks object identity. If a method returns <php>$this</php>, it returns the decorated object, not the proxy.

The virtual state-proxy strategy proposed by this RFC relies on proxying property accesses instead of methods. Methods are called on the state-proxy itself, so when a method returns <php>$this</php>, it returns the state-proxy object. This approach minimizes identity issues.

Since the state-proxy strategy requires accessing the properties of the decorated object, it is not compatible with internal classes or interfaces. Therefore, virtual inheritance-proxies still have use cases. However, this proposal focuses on providing ghost objects and virtual state-proxies natively, not virtual inheritance-proxies.

There are several reasons for that:

  - Ghost objects and virtual state-proxies hook into the same place in the engine, simplifying the RFC and the corresponding patch.
  - These strategies benefit the most from being in the engine: userland implementation relies on complex magic accessors, is difficult to maintain as new PHP versions are released, and is slower than what can be achieved with engine support.
  - It's unclear if the engine would significantly help with virtual inheritance-proxies: implementing or generating code to decorate methods is simpler.

<php>ReflectionLazyObject::initialize()</php> returns the backing object to aid in implementing virtual inheritance-proxies in userland. The previous description was simplified: virtual inheritance-proxies should also proxy public property accesses in addition to method calls.

Here is an example of a (non-optimized) lazy-loading virtual inheritance-proxy using this RFC:

<PHP>
class Connection
{
    public float $ttl = 1.0;

    public function send(string $data): void
    {
        // Real implementation we want to make lazy
    }
}

class LazyConnection extends Connection
{
    public function __construct()
    {
        ReflectionLazyObject::makeLazyProxy($this, $this->initialize(...));
    }

    public function send(string $data): void
    {
        ReflectionLazyObject::fromInstance($this)->initialize()->send($data);
    }

    private function initialize(): parent
    {
        $connection = new parent(); // Or any heavier initialization logic
        $connection->ttl = 2.0;

       return $connection;
    }
}

$connection = new LazyConnection();

echo $connection->ttl; // echoes 2.0
</PHP>

===== Backward Incompatible Changes =====

None - all existing semantics are preserved.

===== Proposed PHP Version(s) =====

PHP 8.4

===== Proposed Voting Choices =====

Add lazy-objects as described to the engine: yes/no (2/3 required to pass)

===== Patches and Tests =====

https://github.com/arnaud-lb/php-src/tree/lazy-objects