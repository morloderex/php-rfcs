====== PHP RFC: list() Reference Assignment ======
  * Version: 2.0
  * Revived Date: 2016-12-30
  * Revived Author: David Walker <dave@mudsite.com>
  * Withdrawn: 2014-05-15
  * Original Date: 2013-10-24
  * Original Author: Andrea Faulds, ajf@ajf.me
  * Status: Under Discussuon
  * First Published at: http://wiki.php.net/rfc/list_reference_assignment

===== Introduction =====
PHP has had list() assignment and reference assignment for a long time. However, it is not currently possible to use reference assignment with list(). This RFC proposes this new syntax to cover this.  The original requests for this feature date back at least 16 years now [1][2].  We will be focusing on the formers syntax proposal for this RFC.

===== Proposal =====
Under this proposal, a new syntax is introduced:

<code php>
$array = [1, 2];
list($a, &$b) = $array;
</code>

This would be equivalent to the following:

<code php>
$array = [1, 2];
$a = $array[0];
$b =& $array[1];
</code>

Of course, this works just like list() normally does, so you can use it with nested list() and skip values as well:

<code php>
$array = [1, 2, 3, [3, 4]];
list(&$a, $b,, list(&$c, $d)) = $array;
var_dump($array);
/*
array(4) {
  [0]=>
  &int(1)
  [1]=>
  int(2)
  [2]=>
  int(3)
  [3]=>
  array(2) {
    [0]=>
    &int(3)
    [1]=>
    int(4)
  }
}
*/
</code>

It also works with foreach():

<code php>
$array = [[1, 2], [3, 4]];
foreach ($array as list(&$a, $b)) {
    $a = 7;
}
var_dump($array)
/*
array(2) {
  [0]=>
  array(2) {
    [0]=>
    int(7)
    [1]=>
    int(2)
  }
  [1]=>
  array(2) {
    [0]=>
    &int(7)
    [1]=>
    int(4)
  }
}
*/
</code>
(notice here that the reference exists on ''$array[1][0]'' since $a is still in scope after the foreach())

The advantage of adding support for this is that it allows you to use reference assignment for multiple variables at once, which is not currently possible. The syntax here is different from the traditional assignment syntax which places the & before the rvar, not the lvar, but the advantage here is that you can reference assign some, but not all of the variables in list().

The RFC also takes into account the possibility of objects being the lval of the assignment implementing ArrayAccess.
<code php>
class RefArr implements ArrayAccess {
    private $s = [];
    function __construct(array $a) { $this->s = $a; }
    function offsetSet ($k, $v) { $this->s[$k] = $v; }
    function &offsetGet ($k) { return $this->s[$k]; }
    function offsetExists ($k) { return isset($this->s[$k]); }
    function offsetUnset ($k) { unset($this->s[$k]); }
}
$a = new RefArr(array(1, array(2, 3)));
list(&$one, list($two, &$three)) = $a;
$one++;
var_dump($a)
/*
object(RefArr)#1 (1) {
  ["s":"RefArr":private]=>
  array(2) {
    [0]=>
    &int(2)
    [1]=>
    array(2) {
      [0]=>
      int(2)
      [1]=>
      &int(3)
    }
  }
}
*/
</code>

===== Backward Incompatible Changes =====
This introduces no backwards incompatible changes.

===== Proposed PHP Version(s) =====
PHP 7.2

===== RFC Impact =====
==== To Opcache ====
Maybe, I don't know enough about opcache to say if changing current ops by adding an extended value would impact.

===== Open Issues =====
None Presently

===== Proposed Voting Choices =====
Will require 2/3

===== Patches and Tests =====
  * Working Implementation: https://github.com/php/php-src/compare/master...bp1222:fix-7930
  * Language Spec: https://github.com/php/php-langspec/compare/master...bp1222:fix-7930

===== Implementation =====
Link to commit and docs when completed.

===== References =====

  * [1] - https://bugs.php.net/bug.php?id=6768
  * [2] - https://bugs.php.net/bug.php?id=7930

===== Rejected Features =====

===== Change Log =====
  * v2.0 - Commandeered for revival for PHP 7 implementation.
  * v1.0(and prior) - Initial concept raised for PHP 5.x.  Was withdrawn in 2014.
    * Initial PHP 5 Implementation - https://github.com/TazeTSchnitzel/php-src/compare/ListByReference
    * **EDIT 2014-05-15:** I've withdrawn this RFC, due to discovering that PHP's current approach to parsing and opcode output makes this impossible to implement.
