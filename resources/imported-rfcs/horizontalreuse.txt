====== Request for Comments: Horizontal Reuse for PHP ======
  * Version: 2.0
  * Date: 2008-10-12
  * Author: Stefan Marr <php.at.stefan-marr.de>
  * Status: Under discussion
  * First Published at: http://www.stefan-marr.de/artikel/rfc-horizontal-reuse-for-php.html
  * reST TXT: http://www.stefan-marr.de/rfc-horizontal-reuse-for-php.txt
  * Related RFCs: [[rfc:Traits]], [[rfc:NonBreakableTraits|Non-breakable traits]]

This RFC will discuss two different approaches to reuse behavior independently
from the class hierarchy i.e. in an horizontal manner. The main motivation 
of both approaches is to provide a broader opportunity to model classes and
class hierarchies with a clear conceptual background and optimal code reuse at
the same time. Furthermore, the main distinction to other approaches is the 
explicit handling of conflicts resulting from overlapping interfaces in complex
reuse scenarios. Both approaches would be valuable extensions to the PHP 
language, but both of them have their own benefits and drawbacks. 
Thus, this RFC is meant to provide a base for further discussion to be able
to decide, which variant is the most PHP-like reuse mechanism.

====== Why Do We Need Horizontal Reuse? ======

Code reuse is one of the main goals that object-oriented languages try to 
achieve with inheritance. Unfortunately, single inheritance often forces 
the developer to take a decision in favor for either code reuse //or// 
conceptual clean class hierarchies. To achieve code reuse, methods have 
either to be duplicated or to be moved near the root of the class hierarchy,
but this hampers understandability and maintainability of code.

To circumvent this problems multiple inheritance and Mixins have been invented.
But both of them are complex and hard to understand. PHP5 has been explicitly
designed with the clean and successful model of Java in mind: 
single inheritance, but multiple interfaces. This decision has been taken
to avoid the known problems of for example C++. The presented approaches have
been designed to avoid those problems and to enable designers to build 
conceptually clean class hierarchies without the need to consider code reuse
or complexity problems, but focusing on the real problem domain and 
maintainability instead.

===== Limitations to Reuse in Single Inheritance Languages =====

There are several issues with reuse in PHP. To achieve as much reuse as
possible you will probably move methods as high as possible in your inheritance
hierarchy. At this point, there is a trade-off between conceptual consistency
and reuse, because classes starts to have methods they do not need. So, when it
is decided that the conceptual consistency is more valuable because of
understandability of the class model, code duplication is caused or needs to be
worked around by e.g. delegation, which is not always as nice as method
implemented in the class tree.

Beside conceptual issues, there are problems with third-party code you can not
or might not want to modify. The following code illustrates the current 
implementation of an extended version of the PHP reflection API which provides
detailed access to doc comment blocks. ''ReflectionMethod'' and 
''ReflectionFunction'' are classes from the reflection API and have to be 
extended with exactly the same code. In this case it is impossible to change
the classes itself, because they are not under our control i.e. they are 
implemented in C as part of the language.

<code php>
 <?php
 class ezcReflectionMethod extends ReflectionMethod {
   /* ... */
   function getReturnType() { /*1*/ }
   function getReturnDescription() { /*2*/ }
   /* ... */
 }

 class ezcReflectionFunction extends ReflectionFunction {
   /* ... */
   function getReturnType() { /*1*/ }
   function getReturnDescription() { /*2*/ }
   /* ... */
 }
 ?>
</code>

Thus, eventually, we end up with much duplicated code in both classes extending
the original extension classes.

===== Which Opportunities Does PHP Has? =====

For the sake of distinction and discussion, the two approaches 
are named differently. The idea of //Traits// for PHP has been already proposed 
in a former [[rfc:Traits|RFC]]. This RFC introduces in addition the notion 
of //Grafts// (the term is borrowed from [[http://www.robinsonlibrary.com/agriculture/plant/propagation/grafting.htm|agrarian cultivation]]).

A //Trait// is an unit of behavioral reuse. It is very lightweight, stateless and
allows for a very flexible composition of behavior into classes.
A //Graft// is a class composed into another class. It is very much like grafting is
done in the agriculture. It allows for a full-fledged reuse of classes inside
of other classes independent of the class hierarchy.
The following proposal will introduce both flavors of horizontal reuse and
compares them in the context of PHP.

