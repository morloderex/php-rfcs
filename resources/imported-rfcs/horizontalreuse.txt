====== Request for Comments: Horizontal Reuse for PHP ======
  * Version: 2.0
  * Date: 2008-10-12
  * Author: Stefan Marr <php.at.stefan-marr.de>
  * Status: Under discussion
  * First Published at: http://www.stefan-marr.de/artikel/rfc-horizontal-reuse-for-php.html
  * reST TXT: http://www.stefan-marr.de/rfc-horizontal-reuse-for-php.txt
  * Related RFCs: [[rfc:Traits]], [[rfc:NonBreakableTraits|Non-breakable traits]]

This RFC will discuss two different approaches to reuse behavior independently
from the class hierarchy i.e. in an horizontal manner. The main motivation 
of both approaches is to provide a broader opportunity to model classes and
class hierarchies with a clear conceptual background and optimal code reuse at
the same time. Furthermore, the main distinction to other approaches is the 
explicit handling of conflicts resulting from overlapping interfaces in complex
reuse scenarios. Both approaches would be valuable extensions to the PHP 
language, but both of them have their own benefits and drawbacks. 
Thus, this RFC is meant to provide a base for further discussion to be able
to decide, which variant is the most PHP-like reuse mechanism.

====== Why Do We Need Horizontal Reuse? ======

Code reuse is one of the main goals that object-oriented languages try to 
achieve with inheritance. Unfortunately, single inheritance often forces 
the developer to take a decision in favor for either code reuse //or// 
conceptual clean class hierarchies. To achieve code reuse, methods have 
either to be duplicated or to be moved near the root of the class hierarchy,
but this hampers understandability and maintainability of code.

To circumvent this problems multiple inheritance and Mixins have been invented.
But both of them are complex and hard to understand. PHP5 has been explicitly
designed with the clean and successful model of Java in mind: 
single inheritance, but multiple interfaces. This decision has been taken
to avoid the known problems of for example C++. The presented approaches have
been designed to avoid those problems and to enable designers to build 
conceptually clean class hierarchies without the need to consider code reuse
or complexity problems, but focusing on the real problem domain and 
maintainability instead.

===== Limitations to Reuse in Single Inheritance Languages =====

There are several issues with reuse in PHP. To achieve as much reuse as
possible you will probably move methods as high as possible in your inheritance
hierarchy. At this point, there is a trade-off between conceptual consistency
and reuse, because classes starts to have methods they do not need. So, when it
is decided that the conceptual consistency is more valuable because of
understandability of the class model, code duplication is caused or needs to be
worked around by e.g. delegation, which is not always as nice as method
implemented in the class tree.

Beside conceptual issues, there are problems with third-party code you can not
or might not want to modify. The following code illustrates the current 
implementation of an extended version of the PHP reflection API which provides
detailed access to doc comment blocks. ''ReflectionMethod'' and 
''ReflectionFunction'' are classes from the reflection API and have to be 
extended with exactly the same code. In this case it is impossible to change
the classes itself, because they are not under our control i.e. they are 
implemented in C as part of the language.

<code php>
 <?php
 class ezcReflectionMethod extends ReflectionMethod {
   /* ... */
   function getReturnType() { /*1*/ }
   function getReturnDescription() { /*2*/ }
   /* ... */
 }

 class ezcReflectionFunction extends ReflectionFunction {
   /* ... */
   function getReturnType() { /*1*/ }
   function getReturnDescription() { /*2*/ }
   /* ... */
 }
 ?>
</code>

Thus, eventually, we end up with much duplicated code in both classes extending
the original extension classes.

===== Which Opportunities Does PHP Has? =====

For the sake of distinction and discussion, the two approaches 
are named differently. The idea of //Traits// for PHP has been already proposed 
in a former [[rfc:Traits|RFC]]. This RFC introduces in addition the notion 
of //Grafts// (the term is borrowed from [[http://www.robinsonlibrary.com/agriculture/plant/propagation/grafting.htm|agrarian cultivation]]).

A //Trait// is an unit of behavioral reuse. It is very lightweight, stateless and
allows for a very flexible composition of behavior into classes.
A //Graft// is a class composed into another class. It is very much like grafting is
done in the agriculture. It allows for a full-fledged reuse of classes inside
of other classes independent of the class hierarchy.
The following proposal will introduce both flavors of horizontal reuse and
compares them in the context of PHP.

====== Traits - Reuse of Behavior ======

//Traits// is a mechanism for code reuse in single inheritance languages such
as PHP. A Trait is intended to reduce some limitations of single inheritance
by enabling a developer to reuse sets of methods freely in several independent
classes living in different class hierarchies.
The semantics of the combination of Traits and classes is defined in a way,
which reduces complexity and avoids the typical problems associated with 
multiple inheritance and Mixins.

They are recognized for their potential in supporting better composition
and reuse, hence their integration in languages such as Perl 6, Squeak, 
Scala, Self, Slate and Fortress. Traits have also been ported to Java and C#.
In the following, the concepts behind Traits will be adapted for PHP to propose
two different approaches which resemble the main ideas.

A Trait is similar to a class, but only intended to group functionality in a 
fine-grained and consistent way. It is not possible to instantiate a Trait on
its own. It is an addition to traditional inheritance and enables horizontal
composition of behavior.

In the introduction an example has been given illustrating reuse limitations
of single inheritance. With Traits it is possible to remove the duplicated code
without compromising conceptual consistency.

<code php>
 <?php
 trait ezcReflectionReturnInfo {
   function getReturnType() { /*1*/ }
   function getReturnDescription() { /*2*/ }
 }

 class ezcReflectionMethod extends ReflectionMethod {
   use ezcReflectionReturnInfo;
   /* ... */
 }

 class ezcReflectionFunction extends ReflectionFunction {
   use ezcReflectionReturnInfo;
   /* ... */
 }
 ?>
</code>

This is just a small example of what Traits are useful for.
The next sections will discuss more advanced techniques and describe how
Traits are used in PHP.

===== The Flattening Property =====

As already mentioned, multiple inheritance and Mixins are complex mechanisms.
Traits are an alternative which have been designed to impose no
additional semantics on classes. Traits are only entities of the literal code
written in your source files. There is no notion about Traits at runtime.
They are used to group methods and reuse code and are totally flattened 
into the classes composed from them. It is almost like a language supported and
failsafe copy'n'paste mechanism to build classes.

Even though, there is no runtime notion of Traits, since they are part of the
source code and thus, define the structure of the system, reflection about
Traits still is possible, but they do not influence the runtime behavior of the
system.

==== Precedence Order ====

Flattening is achieved by applying some simple rules on the composition
mechanism. Instead of implementing a fancy and awkward algorithm to solve
problems, the entire control about the composition is left in the hand of the
developer and fits nicely into the known inheritance model of PHP.
The following examples illustrate the semantics of Traits and their relation
to methods defined in classes.

<code php>
 <?php
 class Base {
   public function sayHello() {
     echo 'Hello ';
   }
 }
 
 trait SayWorld {
   public function sayHello() {
     parent::sayHello();
     echo 'World!';
   }
 }

 class MyHelloWorld extends Base {
   use SayWorld;
 }

 $o = new MyHelloWorld();
 $o->sayHello(); // echos Hello World!
 ?>
</code>

As shown in the above code, an inherited method from a base class is overridden
by the method inserted into ''MyHelloWorld'' from the ''SayWorld'' Trait.
The behavior is the same for methods defined in the ''MyHelloWorld'' class.
The precedence order is that methods from the current class override Trait methods,
which in return override methods from the base class.

<code php>
 <?php
 trait HelloWorld {
   public function sayHello() {
     echo 'Hello World!';
   }
 }

 class TheWorldIsNotEnough {
   use HelloWorld;
   public function sayHello() {
     echo 'Hello Universe!';
   }
 }

 $o = new TheWorldIsNotEnough();
 $o->sayHello(); // echos Hello Universe!
 ?>
</code>

==== Multiple Traits Usage ====

To keep things simple in the beginning, there has only one Trait being used at
a time, but obviously a class could use multiple Traits at the same time.

<code php>
 <?php
 trait Hello {
   public function sayHello() {
     echo 'Hello ';
   }
 }

 trait World {
   public function sayWorld() {
     echo ' World';
   }
 }
 
 class MyHelloWorld {
   use Hello, World;
   public function sayExclamationMark() {
     echo '!';
   }
 }
 
 $o = new MyHelloWorld();
 $o->sayHello();
 $o->sayWorld();
 $o->sayExclamationMark();
 // Results eventually in: Hello World!
</code>

==== Conflict Resolution ====

Traits are already used in different programming languages and it has shown
that conflicts will occur, but they are the exception, not the rule. In most
systems under investigation, the mechanisms to resolve conflicts have been used
very infrequently, but also have proven to be a valuable mechanisms. Since it
increases the composition power of the developers.
One example for a typical conflict are different Traits providing methods with the
same name.

<code php>
 <?php
 trait A {
   public function smallTalk() {
     echo 'a';
   }
   public function bigTalk() {
     echo 'A';
   }
 }

 trait B {
   public function smallTalk() {
     echo 'b';
   }
   public function bigTalk() {
     echo 'B';
   }
 }
 ?>
</code>

Both classes have to be used in a class named ''Talker''. Multiple inheritance
and Mixins define an algorithm to resolve this conflict. Traits don't. Conflicts
are not solved implicitly by any kind of precedence. Instead, to avoid implicit
complexity, the developer has full control over class composition.

<code php>
 <?php
 class Talker {
   use A, B;
 }
 ?>
</code>
 
In case of the above definition of ''Talker'', PHP will show a waring that there
have been conflicts and name the methods ''smallTalk()'' and ''bigTalk()'' 
as the reason of this conflict. Therefore, neither of the given implementations
will be available in the class.

Instead, the developer can exactly define which methods are used and how the
conflict is resolved.

<code php>
 <?php
 class Talker {
   use A, B {
     B::smallTalk instead A::smallTalk,
     A::bigTalk instead B::bigTalk
   }
 }
 ?>
</code>

This definition will result in leaving out ''smallTalk()'' from Trait A
and ''bigTalk()'' from Trait B. Therefore, the resulting class Talker would 
echo '''b''' for ''smallTalk()'' and '''A''' for ''bigTalk().''
But this simple form of exclusion of methods is not the best choice for all 
situations.

<code php>
 <?php
 class Talker {
   use A, B {
     B::smallTalk instead A::smallTalk, 
     A::bigTalk instead B::bigTalk,
     B::bigTalk as talk
   }
 }
 ?>
</code>
 
Beside leaving out methods it is possible to introduce a new name for a method
from a Trait. This is done like ''originalMethodName as additionalMethodName''.
In the example above, it has to be read as ''use B::bigTalk as talk in class
Talker''. This does not imply any renaming, instead ''talk'' is introduced as
an additional name for this method. Thus, recursion inside of ''talk'' will
still call a method with the name bigTalk.
The resulting ''Talker'' class will consist of following three methods:

  * ''bigTalk() { echo 'A'; }''
  * ''smallTalk() { echo 'b'; }''
  * ''talk() { echo 'B'; }''

Since the new name is recognized as an additional method, the ''bigTalk'' 
method still has to be excluded. Otherwise, PHP would print
a warning that two methods from Traits have a conflict and are excluded.
The introduction of a new name is not renaming and references in methods to a 
given method name aren't changed either. On the first look this may sound 
strange, but it provides the opportunity to build Traits and even hierarchies 
of Traits which fit together very well.

==== Traits Composed from Traits ====

Not explicitly mentioned jet, but implied by the flattening property is the
composition of Traits from Traits.
Since Traits are fully flattened away at compile time it is possible to use
Traits to compose Traits without any additional impact on the semantics.
The following code illustrates this:

<code php>
 <?php
 trait Hello {
   public function sayHello() {
     echo 'Hello ';
   }
 }

 trait World {
   public function sayWorld() {
     echo 'World!';
   }
 }

 trait HelloWorld {
   use Hello, World;
 }

 class MyHelloWorld {
   use HelloWorld;
 }

 $o = new MyHelloWorld();
 $o->sayHello();
 $o->sayWorld();
 // Results eventually in: Hello World!
 ?>
</code>

Traits itself can take part in arbitrary compositions, but Traits are not part
of the inheritance tree i.e., it is not possible to inherit from a Trait to
avoid confusion and misuse of Traits.

==== Express Requirements by Abstract Methods ====

Since Traits do not contain any state/properties, there is a need to describe
the requirements a Trait will rely on. In PHP it would be possible to utilize
the dynamic language features, but it is a common practice to give this
requirements explicitly.
This is possible with abstract methods like it is used for abstract classes.

<code php> 
 <?php
 trait Hello {
   public function sayHelloWorld() {
     echo 'Hello'.$this->getWorld();
   }
   abstract public function getWorld();
 }

 class MyHelloWorld {
   private $world;
   use Hello;
   public function getWorld() {
     return $this->world;
   }
   public function setWorld($val) {
     $this->world = $val;
   }
 }
 ?>
</code>

The usage of abstract methods allows to state not always obvious relation ships
and requirements explicitly. It is favored over the implicit usage of the
dynamic method resolution and property creation in the context of complex
projects for the sake of readability.

===== Traits Semantics Summarized =====

  - Traits do not add runtime semantics, they only take part in the process of building a class.
  - Traits integrate into the precedence order of method overriding.
  - To avoid complexity, conflicts between Trait methods have to be solved explicitly. Otherwise a waring is generated and the conflicting methods are excluded.
  - In combinations with conflicts, developers have to chose explicitly which method has to be used, methods not chosen will be excluded from the composition.
  - Aliases can be defined for methods to enable reuse of conflicting methods.
  - Traits can be composed from Traits.
  - Traits can state requirements explicitly by the use of abstract methods.

As a result of this semantics, at runtime, classes build using Traits are not distinguishable 
from classes not using Traits but traditional code duplication instead.
Semantics of ''parent'' and ''$this'' hasn't changed, too. Used in a Trait
method, they behave exactly the same as if the method has been defined in the
class directly.

===== Visibility =====


Visibility modifiers have not been discussed so far. Since Traits are meant as
units of reuse, modifiers should be changeable easily in the context of a
composed class. Therefore, the aliasing operation is able to change the
visibility modifier of a method, too.

<code php>
 <?php
 trait HelloWorld {
   public function sayHello() {
     echo 'Hello World!';
   }
 }

 class MyClass1 {
   use HelloWorld { sayHello as protected }
 }

 class MyClass2 {
   use HelloWorld { doHelloWorld as private sayHello }
 }
 ?>
</code>

The final modifier is supported, too. The static modifier is not supported,
because it would change the methods semantics and references to ''$this''
would break.

