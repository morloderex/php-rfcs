====== PHP RFC: Closure::apply ======
  * Version: 0.1
  * Date: 2014-07-29
  * Author: Andrea Faulds, ajf@ajf.me
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/closure_apply

===== Introduction =====

PHP has had Closures since 5.3, and since 5.4 has had ''Closure::bind'' (static method) and ''Closure::bindTo'' (method) to allow creating new closures that have ''$this'' bound to a specific method. However, it has not been possible to bind at call-time without creating a new closure, making binding to different objects and calling for multiple objects cumbersome and inefficient (at least two statements are needed, and a new closure must be created and immediately disposed of for each).

===== Proposal =====

A new method is added to ''Closure'', with the following signature:

<code php>
mixed Closure::apply(object $to[, mixed ...$parameters])
</code>

It calls the closure with the given parameters and returns the result, with ''$this'' bound to the given object ''$to'', using the closure's current scope. Like the ''bind''(''To'') methods, a static class cannot be bound (calling ''->apply'' will fail).

It can be used like so:

<code php>
$foo = new StdClass;
$foo->bar = 3;
$foobar = function ($qux) { var_dump($this->bar + $qux); };
$foobar->apply($foo, 4); // prints int(7)
</code>

Because the ''->apply'' method, unlike ''bind''(''To''), does not take a scope parameter (as scope is internally a property of the function), then if you wish to use a different scope, you must manually create a new closure with the desired scope prior to application. However, closures that are scoped must currently either be static (cannot be bound or used with ''->apply'') or bound. This would mean that you would have to bind the closure to some dummy object in order to produce a closure with the desired scope for use with ''->apply''. This is inconvenient at best. To solve this, we relax the current invariant of scoped closures having to be bound, and add a new parameter to ''bind''(''To'') to produce an unbound, scoped closure, like so:

<code php>
class Foo { private $x = 3; }
$foo = new Foo;
$foobar = function () { var_dump($this->bar); };
// without the last parameter (optional, defaults to false), we'd get a static, not unbound closure
$foobar = $foobar->bindTo(null, 'FooBar', true);
$foobar->apply($foo); // prints int(3)
</code>

My function referencing as closures proposal similarly relaxes the requirement for a scoped closure to be bound or static out of necessity, and ''->apply'' would be highly useful to that proposal, so this RFC can be considered a prerequisite to it.

===== Backward Incompatible Changes and RFC Impact =====

This has no effect on backwards compatibility.

===== Proposed PHP Version(s) =====

This is proposed for the next version of PHP, either the next 5.x or PHP NEXT, whichever comes sooner. The patch is based on master, intended for the next 5.x.

===== Future Scope =====

Partial application (where a new closure is returned that pre-fills the first X arguments) is a possibly worthwhile (though more difficult to implement) addition.

===== Proposed Voting Choices =====

This is not a language change, so a straight 50%+1 Yes/No vote can be held.

===== Patches and Tests =====

A tree on my GitHub fork based on the current master can be found here: https://github.com/TazeTSchnitzel/php-src/tree/function_reference

===== References =====

  * As aforementioned, my [[rfc:function_referencing|Function Referencing as Closures]] RFC has this RFC as a prerequisite