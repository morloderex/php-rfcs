====== PHP RFC: Shorter Attribute Syntax Change ======
  * Version: 0.3
  * Date: 2020-08-04
  * Author: Derick Rethans, Benjamin Eberlei
  * Status: In Voting
  * First Published at: https://wiki.php.net/rfc/shorter_attribute_syntax_change

===== Introduction =====

Based on the expressions of concern over using ''@@'' for Shorter Attribute Syntax RFC https://wiki.php.net/rfc/shorter_attribute_syntax, I propose to use ''#[]'', ''@[]'', or the original ''<< … >>''  instead. Please keep in mind that we want the best syntax, and not necessarily the best **looking** syntax.

The main concern is that ''@@'' has **no ending symbol** and it's **inconsistent** with the language that it would be the only declaration or statement in the whole language that has no ending termination symbol.

===== Proposal =====

Pick the **best** syntax from the following options, taking into account the different pros and cons:

^ Syntax                                        ^ ''@@Attr'' ^ ''#[Attr]'' ^ ''@[Attr]'' ^ ''<<Attr>>'' ^
| Number of required Characters                 | 2     | 3       | 3       | 4        |
| Has End Delimiter                             | //No//     | //Yes//     | //Yes//     | //Yes//      |
| Allows Grouping (Accepted in previous [[rfc:attribute_amendments|RFC]]¹)    | //No//     | //Yes//     | //Yes//     | //Yes//      |
| Forward Compatibilty in PHP 7                 | //No//     | //Yes//     | //No//      | //No//       |
| Breaks BC of valid PHP 7 code                 | //Yes//    | //Yes//     | //Yes//     | //No//       |
| Used by other language                        | //No//     | //Yes//     | //No//      | //Yes//      |
| Familiar with Docblock Usage                  | //Yes//    | //No//      | //No//      | //No//       |
| Tokens used                                   | //New T_ATTRIBUTE// | //New T_ATTRIBUTE// | //New T_ATTRIBUTE// | Existing T_SL, T_SR |
| Changes the lexing of **remaining** tokens    | //No//     | //Yes//     | //No//      | //No//       |
| Target                                        | 8.0    | 8.0     | 8.0     | 8.0      |
| Patch                                         | -      |         | [[https://github.com/php/php-src/pull/5928|patch]] | |

¹ If the chosen syntax allows grouping, it will be reintroduced.

Explanations:

**Has End Delimiter** - An attribute syntax with ending delimiter means that the declaration of attributes is "always" enclosed in a start and an ending symbol, to more clearly seperate them from other parts of the code.

**Allows Grouping** - Grouping syntax means that you can declare multiple attributes using one syntax construct.

**Forward Compatibility in PHP 7** means that you can use at least a subset of the new syntax in PHP 7 without the code causing parsing errors. It does not mean that you can already use attributes in PHP 7 already.

**Breaks BC of valid PHP 7 code** means that the syntax chosen for attribute is alreay valid code with different meaning in PHP 7. As such existing code would need to change.

**Used by other language** means that this exact syntax is or was used by at least one other programming language for the same feature (Annotations, Attributes, Metadata).

**Familiar with Docblock Usage** means that it resembles syntax that is already used at the moment in annotations made using PHP docblock comments.

**Tokens used** explains if the syntax introduces a new token into the language or re-uses existing ones.

**Changes lexing of remaining tokens** indicates that a newly introduced token changes the behaviour of existing tokens. In the example of #[ the occurance of a # would have previously always signified a comment, but that now changes to become an attribute instead when followed by [.

===== Syntax Side by Side =====

All syntaxes side by side in order of the table above. Syntaxes that would allow the use of a group syntax demonstrate grouped use on the id property and ungrouped use on the email property.

<code php>
class User
{
    @@ORM\Id @@ORM\Column("integer") @@ORM\GeneratedValue
    private $id;
 
    @@ORM\Column("string", ORM\Column::UNIQUE)
    @@Assert\Email(["message" => "The email '{{ value }}' is not a valid email."])
    private $email;
}

class User
{
    #[ORM\Id, ORM\Column("integer"), ORM\GeneratedValue]
    private $id;
 
    #[ORM\Column("string", ORM\Column::UNIQUE)]
    #[Assert\Email(["message" => "The email '{{ value }}' is not a valid email."])]
    private $email;
}

class User
{
    @[ORM\Id, ORM\Column("integer"), ORM\GeneratedValue]
    private $id;
 
    @[ORM\Column("string", ORM\Column::UNIQUE)]
    @[Assert\Email(["message" => "The email '{{ value }}' is not a valid email."])]
    private $email;
}

class User
{
    <<ORM\Id, ORM\Column("integer"), ORM\GeneratedValue>>
    private $id;
 
    <<ORM\Column("string", ORM\Column::UNIQUE)>>
    <<Assert\Email(["message" => "The email '{{ value }}' is not a valid email."])>>
    private $email;
}
</code>

===== Discussion of Backwards Compatibility Breaks =====

Three of the proposed syntaxes break backwards compatibility at varying
degrees. This section attempts to give a full overview of the BC break
potential of each choice.

==== @@ Syntax and BC Breaks ====

The following code snippets work in PHP 7 and would break if @@ becomes
attribute syntax:

<code php>
<?php
function foo() {
}

@@foo();
</code>

In Words: Using the error suppress operator twice after each other will cause
this BC break.

Realistically this BC break is going to be extremely unlikely to happen and is
the least critical from all three potential BC breaks.

This BC break can be fixed mechanically with a project-wide search and replace
from "@@" to "@ @" or "@" only even.

==== #[] Syntax and BC Breaks ====

The following code snippets work in PHP 7 and would break if #[] becomes
attribute syntax:

<code php>
<?php
// 1. starting hash comments with a [
#[author=Benjamin]
#[todo]

// 2. commenting out an old array value using #
$data = ['new']; #['old']

// 3 commenting out a line starting with [ using #
#[$foo, $bar] = explode("-", $data);
</code>

<nowiki>In Words: Commenting out a line or expression that starts with [ using #
instead of // would trigger this BC break.</nowiki>

Using grep.app a few occurrences in open source code of this BC break have been
found, but overall it looks like it is used in old exploit scripts and not in
code that is still used or widespread. The impact is higher than for @@.

https://grep.app/search?q=%23%5B&filter[lang][0]=PHP

This BC break can be fixed mechanically with a project-wide search and replace
from "#[" to "# [", with some care as #[ sometimes appears in regular
expressions.

==== @[] Syntax and BC Breaks ====

The following code snippets work in PHP 7 and would break if @[] becomes
attribute syntax:

<code php>
<?php
// 1. using the short list syntax with error suppression, likely with explode
$email = $_GET['email'];
@[$local, $domain] = explode("@", $email);

// 2. suppressing errors in an expression that starts with short array
@[foo()];
</code>

In Words: Suppressing errors on a line that immediately follows with the short
array syntax will not be possible with @[] for attributes anymore.

Using grep.app occurrences of these code patterns cannot be found, only in
regexp strings that would not be affected. Yet at least the explode case with
short list syntax seems to be something that could be used widely, but is not
at the moment.

https://grep.app/search?q=%40%5B&filter[lang][0]=PHP

This BC break can be fixed mechanically with a project-wide search and replace
from "@[" to "@ [", with some care as @[ often appears in regular expressions.

===== Forwards Compatibility Pro/Cons =====

The #[]-Syntax has the unique property of being forwards compatible, meaning
specifically that the syntax can be used in PHP 7 code without leading to a
compile fatal error, but is instead interpreted as a comment.

This is different to @@, @[] and <<>> which when used with any PHP 7 version
would lead to a compile fatal error.

The primary benefit of this forward compatibility is for libraries that want to
use a class for an Attribute in PHP 8 but use it with doc-comment based
Annotations libraries in PHP 7.

<code php>
<?php

#[Attribute]
class Route
{
    public $path;
    public $controller;
}
</code>

This code compiles fine on PHP 7, interpreting #[Attribute] as a comment.

While #[] would allow forward compatibility, it is important to mention that it
would not work for 100% of all attribute syntax uses with #[].

The forward compatibility does lead to a few theoretically problematic cases
where working code in PHP 7 and PHP 8 behaves very different:

<code php>
<?php

// on PHP 7 its a function foo with one argument $param2
// on PHP 8 its a function foo with two arguments $param1, $param2
function foo(
    #[Attribute] $param1,
    $param2
) {
}
</code>

Another example where code would be interpreted differently on PHP 7:

<code php>
$f1 = #[ExampleAttribute] function () {};

$f2 = #[ExampleAttribute] fn() => 1;

$object = new #[ExampleAttribute] class () {};
foo();

// On PHP 7 this is interpreted as
$f1 = $f2 = $object = new foo();

</code>

This example echoes the rest of the source code in php 7 and echoes "Test" in php 8.

<code php>
<?php
#[DeprecationReason('reason: <https://some-website/reason?>')]
function main() {}
const APP_SECRET = 'app-secret';
echo "Test\n";
</code>

These examples are artificially crafted and would only be problematic on new
attribute code that runs on PHP 7. Developers writing code running on multiple
versions need to handle versions differences already, so these problems might
not be a problem at all in the end.

This is especially true, because these edge cases will not happen for existing
PHP 7 code running on PHP 8, but only when new code primarily written for PHP 8
is then also run on PHP 7.

===== Proposed PHP Version(s) =====
PHP 8.0

===== Voting =====
A first vote (⅔rds) to allow the vote to change the syntax

<doodle title="Are you okay voting on a better attribute syntax for PHP 8.0?" auth="derick" voteType="single" closed="false">
   * Yes
   * No
</doodle>

An STV vote among all the qualifying syntaxes, running from August 10th, 08:00 UTC to August 23, 24:00 UTC.

With STV you SHOULD rank **all** the choices in order. Don't pick the same option more than once, as that invalidates your vote.

First choice:
<doodle title="New attribute syntax choice #1" auth="derick" voteType="single" closed="false">
   * @@Attr
   * #[Attr]
   * @[Attr]
   * <<>>
</doodle>

Second choice:
<doodle title="New attribute syntax choice #2" auth="derick" voteType="single" closed="false">
   * @@Attr
   * #[Attr]
   * @[Attr]
   * <<>>
</doodle>

Third choice:
<doodle title="New attribute syntax choice #3" auth="derick" voteType="single" closed="false">
   * @@Attr
   * #[Attr]
   * @[Attr]
   * <<>>
</doodle>

Fourth choice:
<doodle title="New attribute syntax choice #4" auth="derick" voteType="single" closed="false">
   * @@Attr
   * #[Attr]
   * @[Attr]
   * <<>>
</doodle>
===== Implementation =====
After the project is implemented, this section should contain
  * the version(s) it was merged into
  * a link to the git commit(s)
  * a link to the PHP manual entry for the feature
  * a link to the language specification section (if any)

===== References =====
Links to external references, discussions or RFCs
  * Original RFC: https://wiki.php.net/rfc/shorter_attribute_syntax
  * https://externals.io/message/111101
  * https://www.reddit.com/r/PHP/comments/hjpu79/it_is/
  * An RFC that by coincidence fixes the original parser conflict: https://wiki.php.net/rfc/namespaced_names_as_token

===== Updates ======

   * v0.3: Removed "Difficulties for Userland Parsers" as its a subjective opinion and boils down to the fact that a new token T_ATTRIBUTE is introduced in some syntaxes that would include tokens that were parsed differently in previous PHP versions. Added "Tokens used" and "Changes the lexing of remaining tokens".