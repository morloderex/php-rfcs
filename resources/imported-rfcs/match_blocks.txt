====== PHP RFC: Match blocks ======

  * Date: 2023-08-24
  * Author: Ilija Tovilo, tovilo.ilija@gmail.com
  * Status: Draft
  * Target Version: PHP 8.x
  * Implementation: https://github.com/php/php-src/pull/11933

===== Proposal =====

The [[https://wiki.php.net/rfc/match_expression_v2|match expression]] was added to PHP 8.0 with the goal of being a safer and more useful alternative to the switch statement. In its current form, each match arm is limited to a single expression. This RFC proposes to lift this restriction and allow the placement of blocks at the match arm site.

<code php>
// FIXME: Provide real-world examples

match ($key) {
    Key::Return => {
        echo "Saving...";
        save();
    },
};

$result = match($foo) {
    1 => {
        bar();
        baz() // The return value of baz() is the result of the match
    }
};
</code>

===== Semantics =====

==== Return value ====

Match blocks come in two forms: They must return a value if the match return value is used. Conversely, they must not return a value if the match return value is not used. The return value is always the last expression after a list of optional statements, with the trailing semi-colon omitted. This syntax is heavily inspired by Rust.

<code php>
$result = match($foo) {
    1 => {
        // As many statements as you want
        $l = 1;
        $r = 2;
        // The last element in the list must be an expression (e.g. no if statement), and the last
        // semicolon must be omitted.
        $l + $r
    }
};
</code>

==== Control statements ====

return, break, continue and goto statements are allowed in match blocks //only// if the return value of match is not used, or if they don't escape the block (e.g. continue in a loop contained in the block).

<code php>
match ($foo) {
    'bar' {
        // This is ok
        return 'baz';
    }
};

var_dump(match ($foo) {
    'bar' {
        // This is **not** ok
        break;
    }
});

var_dump(match ($foo) {
    'bar' {
        for ($i = 0; $i < 10; $i++) {
            // This is ok
            continue;
        }
        42
    }
});
</code>

The rationale for this decision is twofold:

  * It attempts to avoid confusing and potentially unsound control flow. For example:

<code php>
var_dump(match (1) {
    1 { break; }
});
// What is the return value of match? A value was never returned, but the var_dump is executed nonetheless.
</code>

  * There are technical challenges to correctly implementing control flow that escapes a block mid-expression. For the interested, this is explained in more detail under "Technical implications of control statements" below. Disallowing escaping of the match block completely dodges this problem.

===== Motivation =====

switch statements commonly contain more than one statement. [[https://github.com/nikic/popular-package-analysis|popular-package-analysis]] revealed that 3'507 of 6'012 switch statements contained at least one case with more than one statement (excluding breaks). Moreover, 29'690 of 67'563 cases were multi-statement. The match expression has been introduced to address some shortcomings of switch statements, but currently fails to address these use cases. It has previously been argued that limiting match arms to single expressions is beneficial for enforcing clean code. While keeping functions and consequently match arms short certainly has its merits, I personally find excessively small functions disorienting and hard to name well.

The improvements in match expressions are described in https://wiki.php.net/rfc/match_expression_v2. Moreover, [[https://wiki.php.net/rfc/pattern-matching|pattern matching]] is in the works, with planned enhancements of the match expression. Specifically, each match arm will be able to specify a pattern to match the expression against.

<code php>
match ($option) {
    is Option::Some($value) => var_dump($value),
    Option::None => var_dump('None'),
};
</code>

Match blocks would make pattern matching in match expressions immensely more useful, and cannot be substituted with a switch statement.

===== Why not language-level blocks? =====

Instead of just implementing blocks for match-expressions, I've considered adding language-level blocks instead. There are three evident use cases.

  * Match blocks
  * Arrow function blocks
  * Everything else (''??='', ''??'', ''?:'', ''? :'')

Unfortunately, these three use cases are all slightly different.

  * For match, whether the block should return a value depends on whether the match itself returns a value.
  * Arrow function blocks should never return a value, because function return values are controlled by ''return''.
  * For the remaining cases, a value should always be returned.

===== Backwards incompatible changes =====

There are no backwards incompatible changes in this RFC.

===== Technical implications of control statements =====

PHPs VM is in three-address form. As opposed to most machines, PHP opcodes are destructive in that they consume their operands. A consumed operands may not be consumed again. Moreover, an unconsumed operand may result in leaked memory. Control statements in match expression blocks pose a problem when they skip over the consuming opcodes of temporary VARs.

<code php>
new Foo() + match (1) {
    1 => { return; null }
};
</code>

<code>
0000 V0 = NEW 0 string("Foo")
0001 DO_FCALL
0002 T2 = IS_IDENTICAL int(1) int(1)
0003 JMPNZ T2 0006
0004 JMP 0005
0005 MATCH_ERROR int(1)
0006 RETURN null
0007 T3 = QM_ASSIGN null
0008 JMP 0009
0009 T4 = ADD V0 T3
0010 FREE T4
0011 RETURN int(1)
</code>

The opcode 0006 (RETURN) is always executed, skipping the 0009 (ADD) instruction, not consuming V0 and thus leaking the Foo object. This problem may be avoided by emitting a FREE opcode before RETURN. The same issue can occur when breaking out of switch statements, continuing in loops, using goto, etc. This approach is implemented in [[https://github.com/php/php-src/compare/master...iluuu1994:php-src:match-blocks-var-tracking|this PR]]. However, it has proven to be much more complex for questionable benefit.

Similarly, we run into an issue in this code.

<code php>
foo()->bar(match (1) {
    1 => { return; null }
});
</code>

<code>
0000 INIT_FCALL_BY_NAME 0 string("foo")
0001 V0 = DO_FCALL_BY_NAME
0002 INIT_METHOD_CALL 1 V0 string("bar")
0003 T1 = IS_IDENTICAL int(1) int(1)
0004 JMPNZ T1 0007
0005 JMP 0006
0006 MATCH_ERROR int(1)
0007 RETURN null
0008 T2 = QM_ASSIGN null
0009 JMP 0010
0010 SEND_VAL_EX T2 1
0011 DO_FCALL
0012 RETURN int(1)
</code>

The 0007 (RETURN) instruction skips over 0011 (DO_FCALL). However, the 0002 (INIT_METHOD_CALL) instruction has already received V0 (foo()) and increased its refcount to make sure the value is not released before the method bar() is called on it. Given that 0011 (DO_FCALL) is never executed, this value leaks.

Both of these issues arise because there are unfreed VARs at the time the escaping control statements in the match blocks are executed, skipping over their consuming opcodes. Disallowing the escaping of the match blocks prevents skipping over the consuming opcodes, and thus circumvents the issue.

===== Vote =====

Voting starts ????-??-?? and ends ????-??-??. 

As this is a language change, a 2/3 majority is required.

<doodle title="Add support for blocks at match arms in PHP 8.x?" auth="ilutov" voteType="single" closed="true">
   * Yes
   * No
</doodle>
