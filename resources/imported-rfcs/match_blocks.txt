====== PHP RFC: Match blocks ======

  * Date: 2023-08-24
  * Author: Ilija Tovilo, tovilo.ilija@gmail.com
  * Status: Draft
  * Target Version: PHP 8.x
  * Implementation: https://github.com/php/php-src/pull/11933

===== Proposal =====

The [[https://wiki.php.net/rfc/match_expression_v2|match expression]] was added to PHP 8.0 with the goal of being a safer and more useful alternative to the switch statement. In its current form, each match arm is limited to a single expression. This RFC proposes to lift this restriction and allow the placement of blocks at the match arm site.

<code php>
// FIXME: Provide real-world examples

match ($key) {
    Key::Return => {
        echo "Saving...";
        save();
    },
};

$result = match($foo) {
    1 => {
        bar();
        <- baz(); // The return value of baz() is the result of the match
    },
};
</code>

===== Semantics =====

==== Return value ====

Match blocks may have return values. The match expression will propagate the return value of the executed match arm. The return value is the last expression after an optional list of statements, preceded by a ''<-'' symbol to denote the value flowing out of the block. If the match return value is used, each block is expected to return a value, unless it terminates early.

<code php>
$result = match($foo) {
    'bar' => {
        $l = 1;
        $r = 2;
        <- $l + $r;
    },
    'baz' => {
        throw new Exception();
    },
    'qux' => {
        // Forgot to return something
        // This will throw a MatchBlockNoValueError if executed
    },
};
</code>

If the match return value is not used, the blocks must not return a value.

<code php>
match($foo) {
    'bar' => {
        echo 'This branch does not return a value';
    },
    'bar' => {
        $l = 1;
        $r = 2;
        // Compile time error: Blocks of match expression with unused result must not return a value
        <- $l + $r;
    },
};
</code>

Note that the return keyword is not reused in place of ''<-'' because it would be ambiguous whether the user meant to return from the match block, or return from the function.

==== Control statements ====

return, break, continue and goto statements are allowed in match blocks //only// if the return value of match is not used, or if they don't escape the block (e.g. continue in a loop contained in the block).

<code php>
match ($foo) {
    'bar' => {
        // This is ok
        return 'baz';
    },
};

var_dump(match ($foo) {
    'bar' => {
        // This is **not** ok
        break;
    },
});

var_dump(match ($foo) {
    'bar' => {
        for ($i = 0; $i < 10; $i++) {
            // This is ok
            continue;
        }
        <- 42;
    },
});
</code>

The rationale for this decision is twofold:

  * It attempts to avoid confusing and potentially unsound control flow. For example:

<code php>
var_dump(match (1) {
    1 => { break; <- 42; },
});
// What is the return value of match? A value was never returned, but the var_dump must receive a value nonetheless.
</code>

  * There are technical challenges to correctly implementing control flow that escapes a block mid-expression. For the interested, this is explained in more detail under "Technical implications of control statements" below. Disallowing escaping of the match block completely dodges this problem.

==== Scoping ====

Match blocks behave just like any other statement list in PHP in terms of scoping. That is, no new scope is created. All variables assigned inside the block are visible outside the block, in the same function.

<code php>
match ($foo) {
    'bar' => {
        $baz = 'I can see this';
    },
};
echo $bar; // I can see this
</code>

===== Motivation =====

switch statements commonly contain more than one statement. [[https://github.com/nikic/popular-package-analysis|popular-package-analysis]] revealed that 3 507 of 6 012 switch statements contained at least one case with more than one statement (excluding breaks). Moreover, 29 690 of 67 563 cases were multi-statement. The match expression has been introduced to address some shortcomings of switch statements, but currently fails to address these use cases. It has previously been argued that limiting match arms to single expressions is beneficial for enforcing clean code. While keeping functions and consequently match arms short certainly has its merits, I personally find excessively small functions disorienting and hard to name well.

The improvements in match expressions are described in https://wiki.php.net/rfc/match_expression_v2. Moreover, [[https://wiki.php.net/rfc/pattern-matching|pattern matching]] is in the works, with planned enhancements of the match expression. Specifically, each match arm will be able to specify a pattern to match the expression against.

<code php>
match ($option) {
    is Option::Some($value) => var_dump($value),
    is Option::None         => var_dump('None'),
};
</code>

Match blocks would make pattern matching in match expressions immensely more useful, and cannot be substituted with a switch statement.

===== Why not language-level blocks? =====

Instead of just implementing blocks for match-expressions, I've considered adding language-level blocks instead. There are three evident use cases.

  * Match blocks
  * Arrow function blocks
  * Everything else (''??='', ''??'', ''?:'', ''? :'')

Unfortunately, these three use cases are all slightly different.

  * For match, whether the block should return a value depends on whether the match itself returns a value.
  * Arrow function blocks should never return a value, because function return values are controlled by ''return''. No return value should mean ''null'', to stay consistent with other functions.
  * For the remaining cases, a value should always be returned.

Furthermore, blocks for arrow functions have been discussed and rejected in two separate RFCs.

  * https://wiki.php.net/rfc/short-functions
  * https://wiki.php.net/rfc/auto-capture-closure

It seems that most concerns for both of these RFCs were related to auto-capturing, which language-level blocks cannot properly address.

It's also note that the "everything else" use case is quite limited due to PHPs scoping rules. In other languages, blocks can be used to prevent pollution of the current scope.

<code rust>
let foo = {
    let tmp = tmp();
    // ...
    Foo { tmp }
};
</code>

In this case, ''tmp'' resides in the isolated scope and inaccessible outside of the block. However, given that PHP only has a single scope per function, there is no point in lexically nesting the temporary variables, other than potential visual benefits. The benefits are mainly limited to some of the short circuiting operators (''??='', ''??'', ''?:'', ''? :''), as they may skip the execution of the block under certain conditions.

<code php>
$foo ??= {
    $tmp = tmp();
    // ...
    <- new Foo($tmp);
};
</code>

===== Backwards incompatible changes =====

There are no backwards incompatible changes in this RFC.

===== Technical implications of control statements =====

PHPs VM is in three-address form. As opposed to most machines, PHP opcodes are destructive in that they consume their operands. A consumed operands may not be consumed again. Moreover, an unconsumed operand may result in leaked memory. Control statements in match expression blocks pose a problem when they skip over the consuming opcodes of temporary VARs.

<code php>
new Foo() + match (1) {
    1 => { return; null },
};
</code>

<code>
0000 V0 = NEW 0 string("Foo")
0001 DO_FCALL
0002 T2 = IS_IDENTICAL int(1) int(1)
0003 JMPNZ T2 0006
0004 JMP 0005
0005 MATCH_ERROR int(1)
0006 RETURN null
0007 T3 = QM_ASSIGN null
0008 JMP 0009
0009 T4 = ADD V0 T3
0010 FREE T4
0011 RETURN int(1)
</code>

The opcode 0006 (RETURN) is always executed, skipping the 0009 (ADD) instruction, not consuming V0 and thus leaking the Foo object. This problem may be avoided by emitting a FREE opcode before RETURN. The same issue can occur when breaking out of switch statements, continuing in loops, using goto, etc. This approach is implemented in [[https://github.com/php/php-src/compare/master...iluuu1994:php-src:match-blocks-var-tracking|this PR]]. However, it has proven to be much more complex for questionable benefit.

Similarly, we run into an issue in this code.

<code php>
foo()->bar(match (1) {
    1 => { return; null },
});
</code>

<code>
0000 INIT_FCALL_BY_NAME 0 string("foo")
0001 V0 = DO_FCALL_BY_NAME
0002 INIT_METHOD_CALL 1 V0 string("bar")
0003 T1 = IS_IDENTICAL int(1) int(1)
0004 JMPNZ T1 0007
0005 JMP 0006
0006 MATCH_ERROR int(1)
0007 RETURN null
0008 T2 = QM_ASSIGN null
0009 JMP 0010
0010 SEND_VAL_EX T2 1
0011 DO_FCALL
0012 RETURN int(1)
</code>

The 0007 (RETURN) instruction skips over 0011 (DO_FCALL). However, the 0002 (INIT_METHOD_CALL) instruction has already received V0 (foo()) and increased its refcount to make sure the value is not released before the method bar() is called on it. Given that 0011 (DO_FCALL) is never executed, this value leaks.

Both of these issues arise because there are unfreed VARs at the time the escaping control statements in the match blocks are executed, skipping over their consuming opcodes. Disallowing the escaping of the match blocks prevents skipping over the consuming opcodes, and thus circumvents the issue.

===== Vote =====

Voting starts ????-??-?? and ends ????-??-??. 

As this is a language change, a 2/3 majority is required.

<doodle title="Add support for blocks at match arms in PHP 8.x?" auth="ilutov" voteType="single" closed="true">
   * Yes
   * No
</doodle>
