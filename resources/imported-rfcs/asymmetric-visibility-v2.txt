====== PHP RFC: Asymmetric Visibility v2 ======
  * Version: 2.0
  * Date: 2024-05-09
  * Author: Ilija Tovilo (tovilo.ilija@gmail.com), Larry Garfield (larry@garfieldtech.com)
  * Status: In Draft
  * First Published at: http://wiki.php.net/rfc/asymmetric-visibility-v2
  * Implementation: https://github.com/php/php-src/pull/9257


===== Introduction =====

PHP has long had the ability to control the visibility of object properties -- ''public'', ''private'', or ''protected''.  However, that control is always the same for both ''get'' and ''set'' operations.  That is, they are "symmetric."  This RFC proposes to allow properties to have separate ("asymmetric") visibility, with separate visibility for read and write operations.  The syntax is mostly borrowed from Swift.

===== Proposal =====

This RFC provides a new syntax for declaring the "set" operation visibility of an object property.  Specifically:

<code php>
class Foo
{
    public private(set) string $bar;
}
</code>

This code declares a property ''$bar'' that may be read from ''public'' scope but may only be modified from ''private'' scope.  It may also be declared ''protected(set)'' to allow the property to be set from any ''protected'' scope (that is, child classes).

The behavior of the property is otherwise unchanged, aside from the restricted visibility.

Asymmetric visibility properties may also be used with constructor property promotion:

<code php>
class Foo
{
    public function __construct(
        public private(set) string $bar,
    ) {}
}
</code>

[I am strongly considering changing this for this version and allowing just set, as that would allow "private(set) string $foo" for the super-common case of public-read, private-write.  I really think it's a common enough case that we should do that.]

In the interest of explicitness, if a ''set'' visibility is specified, a normal/''get'' visibility must also be specified.  Doing otherwise results in a compile error.  That is, the following are legal:

<PHP>
public protected(set) string $foo;
protected private(set) string $bar;
</PHP>

but the following is NOT legal:

<PHP>
// Compile error
protected(set) string $foo;
</PHP>

==== References ====

While a reference to a property with restricted ''set'' visibility may still be obtained, it may only be obtained from a scope that would allow writing.  Put another way, obtaining a reference to a property follows the ''set'' visibility, not the ''get'' visibility.  Trying to obtain a reference to a property with a more restrictive scope will result in an error.

For example:

<code php>
class Foo
{
    public protected(set) int $bar = 0;

    public function test() {
        // This is allowed, because it's private scope.
        $bar = &$this->bar;
        $bar++;
    }
}

class Baz extends Foo
{
    public function stuff() {
        // This is allowed, because it's protected scope.
        $bar = &$this->bar;
        $bar++;
    }
}

$foo = new Foo();

// This is fine, because the update via reference is 
// inside the method, thus private scope.
$foo->test();

// This is also fine.
$baz = new Baz();
$baz->stuff();

// Getting this reference is not allowed here, because this is public
// scope but the property is only settable from protected scope.
$bar = &$foo->bar;
</code>

==== Object properties ===

If the property is an object, the restricted visibility applies only to changing the object referenced by the property.  It does not impact the object itself.  That is consistent with the behavior of the ''readonly'' marker.

Example:

<code php>
class Bar
{
    public string $name = 'beep';
}

class Foo
{
    public private(set) Bar $bar;
}

$f = new Foo();

// This is allowed
$f->bar->name = 'boop';

// This is NOT allowed
$f->bar = new Bar();
</code>

==== Permitted visibility ====

The ''set'' visibility, if specified explicitly, MUST be strictly lesser than the main (''get'') visibility.  That is, the ''set'' visibility may only be ''protected'' or ''private''.  If the main visibility is ''protected'', ''set'' visibility may only be ''private''.  Any violation of this rule will result in a compile time error.

==== Inheritance ====

PHP already allows child classes to redeclare parent class properties, if and only if they have the same type and their visibility is the same or wider.  That is, a ''protected string $foo'' can be overridden with ''public string $foo'' but not ''private string $foo''.  This RFC continues that rule, but independently for ''get'' and ''set'' operations.

That means, for instance, the following is legal:

<code php>
class A {
    private string $foo;
}
class B extends A {
    protected private(set) string $foo;
}

class C extends B {
    public protected(set) string $foo;
}

class D extends C {
   public string $foo;
}
</code>

As in each child class, the ''get'' visibility is the same or wider than the parent, and the ''set'' visibility is the same or wider than the parent.  Narrowing the visibility is not allowed, however.

<code php>
class A {
    public string $foo;
}

class B extends A {
    // This is an error.
    public protected(set) string $foo;
}
</code>

==== Interaction with property hooks ====

The [[rfc:property-hooks|Property Hooks]] RFC introduced the ability to insert arbitrary behavior into the ''get'' or ''set'' behavior of a property.  Hooks have no impact on who may access a property, just on what happens when they do.

In contrast, asymmetric visibility allows varying who may read and who may write a property independently, but has no impact on what happens when they are accessed legally.

In short, the behavior of asymmetric visibility and property hooks do not interact at all, and both are fully independent of each other.

There is one caveat regarding virtual properties that have no ''set'' operation.  If there is no ''set'' operation defined on a property, then it is nonsensical to specify a visibility for it.  That case will trigger a compile error.  For example:

<code php>
// This will generate a compile error, as there is 
// no set operation on which to specify visibility.
class Universe
{
    public private(set) $answer { get => 42; }
}
</code>

==== Interaction with interface properties ====

The [[rfc:property-hooks|Property Hooks]] RFC also introduced the ability for interfaces and abstract classes to declare a requirement for a public or protected (for abstract classes only) property, with ''get'' and ''set'' operations separate.  It is a deliberately "lightweight" requirement.  As noted in that RFC, it may be satisfied by either a hook or a traditional property, as long as the operation is available in the relevant scope.  One reason for the separation of ''get'' and ''set'' requirements was to enable asymmetric visibility to satisfy the requirement as well.

For example, the following is fully legal:

<code php>
interface Named
{
    public string $name { get; }
}

class ExampleA
{
    public protected(set) string $name;
}

class ExampleB
{
    public string $name { get => 'Larry'; }
}

class ExampleC
{
    public string $name;
}

class ExampleD
{
    public readonly string $name;
}
</code>

In each case, ''ExampleX::$name'' can be read from public scope, so the interface is satisfied.

If a property on an interface requires public ''set'', however, then specifying asymmetric visibility is not permitted, except in the special case of ''readonly'' (below).  (Hooks, of course, are.)

==== Interaction with __set and __unset ====

In PHP 8.3, when a property is read or written and it is not defined and visible from the calling scope, the <php>__get</php> and <php>__set</php> magic methods are called instead, if defined.

Asymmetric visibility does not change that logic; it only allows the read and write sides to behave separately.  That is, if a property is publicly readable but only private or protected writeable, and <php>__set</php> is defined, then <php>__set</php> will be called for that but <php>__get</php> will never be called for that property.  For example:

<code php>
class Example
{
    public private(set) bool $open = true;

    public private(set) string $name;
    
    public function setOpen(bool $open): void
    {
        $this->open = $open;
    }
    
    public function __set($var, $val): void
    {
        if ($var === 'name') {
            if ($this->open) {
                $this->name = $val;
            } else {
                throw new LockedException('I cannot do that, Dave.');
            }
        }
    }
    
    public function forceName(string $name): void
    {
      $this-name = $name . ' (forced)';
    }
}

$e = new Example();

// This triggers __set, and since the object
// is $open, writes the property from private scope.
$e->name = 'Larry';

$e->setOpen(false);

// This triggers __set, and since the object is not $open
// __set throws an exception.
$e->name = 'Ilija';

// This calls a normal method, which has private write
// to the property, so runs fine and sets "Ilija (forced)"
$e->forceName('Ilija');
</code>

If <php>__set()</php> is not defined, the write will fail with an error regardless.

The logic for calling ''unset()'' externally (and thus triggering <php>__unset()</php>) is the same.

==== Relationship with readonly ====

The ''readonly'' flag, introduced in PHP 8.1, is, really two flags in one: write-once and ''private(set)''.  While that is sometimes sufficient, there are cases where protected-set is desired, and while few, there are use cases for public-set-once.  

To address these use cases, we have decided to treat ''readonly'' exactly as described: Two flags in one, with one being overridable.  That is, specifying a set-visibility on a ''readonly'' property is legal, and will override the implicit ''private(set)'' of ''readonly''.  If no set-visibility is specified, then ''readonly'''s implicit ''private(set)'' remains the same.

This will naturally lead to some cases where the get and set visibility will be necessarily the same.  Therefore, the prohibition against matching visibilities is lifted for ''readonly'' properties, even if they would otherwise be redundant or unnecessary.  Specifying a wider set-visibility than get is still disallowed.

In code:

<code php>
// These two are identical. The second is redundant, but legal.
public readonly string $foo;
public private(set) readonly string $foo;

// This creates a public-read, protected-write, write-once property.
// This was previously impossible.
public protected(set) readonly string $foo;

// This creates a protected-read, protected-write, write-once property.
// The double-protected is allowed, to override the implicit private(set)
protected protected(set) readonly string $foo;


// This creates a public-read, public-write, write-once property.
// While use cases for this configuration are likely few, 
// there's no intrinsic reason it should be forbidden.
public public(set) readonly string $foo;


// This is illegal - set cannot be wider than get.
protected public(set) readonly string $foo;
</code>

If a class is marked ''readonly'', then by design its impact is identical to if every property was individually marked ''readonly''.  There is no special logic there.

==== Typed properties ====

Asymmetric visibility is only compatible with properties that have an explicit type specified.  This is mainly due to implementation complexity.  However, as any property may now be typed ''mixed'' and defaulted to ''null'', that is not a significant limitation.

==== Static properties ====

This functionality applies only to object properties.  It does not apply to static properties.  For various implementation reasons that is far harder, and also far less useful.  It has therefore been omitted from this RFC.

==== Reflection ====

The ''ReflectionProperty'' object is given two new methods: ''isProtectedSet(): bool'' and ''isPrivateSet(): bool''.  Their meaning should be self-evident.

<code php>
class Test
{
    public string $open;
    public protected(set) string $restricted;
}

$rClass = new ReflectionClass(Test::class);

$rOpen = $rClass->getProperty('open');
print $rOpen->isProtectedSet() ? 'Yep' : 'Nope'; // prints Nope

$rRestricted = $rClass->getProperty('open');
print $rRestricted->isProtectedSet() ? 'Yep' : 'Nope'; // prints Yep
</code>

Additionally, the two constants <php>ReflectionProperty::IS_PROTECTED_SET</php> and <php>ReflectionProperty::IS_PRIVATE_SET</php> are added. They are returned from <php>ReflectionProperty::getModifiers()</php>, analogous to the other visibility modifiers.

Modifying asymmetric properties via <php>ReflectionProperty::setValue()</php> is allowed, just as it is for <php>protected</php> or <php>private</php> properties, even outside of the classes scope.

===== Syntax discussion =====

Asymmetric visibility exists as a feature in several languages, most notably Swift, C#, and Kotlin.  The syntactic structure varies, however.  Translated to PHP, the two models would look like:

<code PHP>
// Option 1:
class A
{
    public private(set) string $name;
}

// Option 2:
class A
{
    public string $name { private set; }
}
</code>

In option 1, the visibility is an aspect of the property itself.  In option 2, the visibility is an aspect of the property's <php>set</php> hook.  We believe that, for PHP, Option 1 (presented here) is the superior approach, for a number of reasons.

==== Option 1 is logically consistent ====

As noted above in "Interaction with hooks", visibility controls exist independently hooks.  In fact, as implemented they do not interact at all.  Using hook syntax for visibility controls, therefore, is surprising and confusing.

==== Option 2 is not necessary from the implementation ====

There is an important difference between PHP's hooks and accessors as implemented in C# or Kotlin.  In those languages, properties effectively always have accessors, and sometimes have a backing value.  If the hook is the trivial implementation (implied if not specified), it is compiled away ahead of time.  That is, the "logical property" (that code would see) and the "physical property" (the actual storage) are already separate from the start.

In PHP, by contrast, there is no distinction between the logical and physical property... //unless// a hook is defined.  Hooks are rarely a factor, whereas accessors are always a factor in C# or Kotlin.

This is an extension of the previous point.  Bringing hook implementations into the picture when they would not otherwise exists complicates both the logic for the reader and for the engine.

==== Option 1 is more visually scannable ====

With Option 1 (proposed), reading a property definition from left to right, one is presented with all visibility options together.  By the time the user has reached the ''$'', they know all visibility information.  With Option 2, set visibility may or may not be known.  It would appear at the end of the line, whereas get visibility is at the start of the line.

Worse, if there are actual hook implementations, the set visibility may be several lines later!

<code php>
class Option1
{
    // All visibility is together in one obvious place.
    public private(set) string $phone {
        get {
            if (!$this->phone) {
                return '';
            }
            if ($this->phone[0] === 1) {
                return 'US ' . $this->phone;
            }
            return 'Intl +' . $this->phone;
        }

       set {
            implode('', array_filter(fn($c) => is_numeric($c), explode($value)))
        }
    }
}

class Option2
{
    public string $phone {
        get {
            if (!$this->phone) {
                return '';
            }
            if ($this->phone[0] === 1) {
                return 'US ' . $this->phone;
            }
            return 'Intl +' . $this->phone;
        }
      
        // The set visibility is 10 lines away from the get visibility!
        private set {
            implode('', array_filter(fn($c) => is_numeric($c), explode($value)))
        }
    }
}
</code>

==== It's non-obvious in Option 2 what hook behavior should be implied ====

One of the caveats of hooks is that, sometimes, references on properties must be prevented.  (The reasons for that are explained at length in the hooks RFC.)  For example, this would be illegal:

<code php>
class A
{
    public array $arr {
        set {
          if (array_filter(is_int(...), $value) === $value) {
            $this->arr = $value;
          }
          throw new \Exception();
        }
    }
}

$a = new A();

// This is illegal, as it would bypass the set hook.
$a->arr[] = 5;
</code>

So "arrays with hooks can do less" is already an established fact of the language.  However, if the hook-style syntax is used for visibility:

<code php>
class A
{
    public array $arr { private set; }
}

$a = new A();

// Should this be legal?
$a->arr[] = 5;
</code>

The syntax suggests that there is a set hook, and thus the assignment should not be allowed.  However, there isn't really a set hook, and thus assignment should be allowed.  Or maybe it shouldn't be, because there is a hook defined, even if it's the default.

It is not at all obvious which interpretation of the syntax should be correct, and either one will result in unexpected behavior for someone.  With the separated syntax (as proposed), this problem does not exist.

==== Option 2 is more complex to implement ====

Building on the previous point, it would probably make more sense to interpret that syntax to not mean a hook is defined, so the assignment would work.  However, that would increase the implementation complexity as the engine could no longer assume that the presence of ''{ }'' meant there were hooks.  It would have to inspect more deeply and determine if it's a for-reals set hook, or a pseudo-hook that should be skipped.

The same challenge would exist for user-space static analysis tools, which would need more complex logic to determine if a given usage is legal or not.  While it's natural for static analysis tools to need to change any time PHP's syntax changes, we should not make those changes harder than they need to be.

==== Option 2 is less extensible ====

As noted in the future-scope below, this syntax allows for the operations that can be visibility-controlled to grow in the future, should a use case be found.  Similarly, hooks were designed such that additional hooks could be defined in the future, should a use case be found.  Both being extensible lists is a good thing.

However, there's no reason why those lists need to extend at the same time.  Using the C#-style syntax would imply that some hooks have a possible visibility modifier and some do not, and that some visibility modifiers, which would be defined within the hook block, do not actually have a hook at all, despite being in the hook block.  As a pathological example:

<code php>
class A
{
    public string $name {
      // No modifier allowed.
      get => ucfirst($this->name);

      // Modifier optional.
      private set => strtolower($value);

      // Modifier, but no hook? How do I know that?
      protected init => ...;

      // How do I even know if this thing takes visibility?
      isset => ...;
    }
}
</code>

In fairness, it is unlikely that either list will be appreciably extended in the near future.  However, if we can avoid a potential landmine now by keeping separate concepts separate, we should.

==== Summary ====

For all of the above reasons, we firmly believe that the proposed syntax is the objectively better approach for PHP.  Trying to use the C# syntax would result in a more complex implementation that is harder to read and harder for static analyzers to handle.

===== Use cases and examples =====

Between ''readonly'' and property hooks, PHP already has a number of ways to do "advanced things" with properties.  However, there are still gaps in capability, which this RFC aims to fill.

==== Readonly is incompatible with inheritance ====

As noted previously, the ''readonly'' flag is, on its own, two flags in one: write-once and ''private(set)''.  While both have their use cases, there are ample times where only one or the other is desired.  For instance, the following code from Crell/Serde (slightly simplified for this example) wants to use ''readonly'', but because of the implied ''private(set)'' it causes issues:

<code php>
abstract class Serde
{
    // ...
    protected readonly TypeMapper $typeMapper;

    protected readonly ClassAnalyzer $analyzer;
}

class SerdeCommon extends Serde
{
    // This must be redefined here so that it 
    // can be set from the constructor.
    protected readonly TypeMapper $typeMapper;

    public function __construct(
        // Normally repeating a property as a promoted
        // argument is an error, BUT because the property
        // is in the parent, this overrides it with a
        // new property definition that is now local
        // to this class.
        protected readonly ClassAnalyzer $analyzer = new Analyzer(),
        array $handlers = [],
        array $formatters = [],
        array $typeMaps = [],
    ) {
        // We just want to do this...
        $this->typeMapper = new TypeMapper($typeMaps, $this->analyzer);
        
        // ...
    }
}
</code>

With asymmetric visibility, the ''readonly'' usage here can be replaced with ''public protected(set)'' or ''readonly public protected(set)'', avoiding the need to double-declare properties.

==== Readonly is limited ====

''readonly'' offered the potential to have public properties that are guaranteed to not change unexpectedly.  This has been a major benefit, and allowed the removal of a lot of needless boilerplate code.  However, it also somewhat over-shoots: It prevents a property from changing //at all//, rather than just "unexpectedly."  While fully immutable objects have their place, they are not always the answer.  It is still often desireable to have a public property (for ease of read) without making it write-once.

For example:

<code php>
class Record
{
    private bool $dirty = false;
    
    private array $data = [];
    
    public function set($key, $val): void
    {
        $this->data[$key] = $val;
        $this->dirty = true;
    }
    
    public function isDirty(): bool
    {
        return $this->dirty;
    }
    
    public function save(): void
    {
        if ($this->dirty) {
            // Do something to save the object.
            $this->dirty = false;
        }
    }
}
</code>

It's very tempting to make ''$dirty'' a public property, as the dirty status of the object is a "property" of it.  Especially with hooks, such a desire will become more common.  However, that cannot be done with ''public'' or ''readonly''.  Making the property ''public'' would open it up to modification from anyone at any time, whereas making it ''readonly'' would make it impossible to unset in ''save()'', and require using "uninitialized or true" as a quasi-boolean state.  Both options are bad.

With asymmetric visibility, it can be easily simplified to:

<code php>
class Record
{
    public private(set) bool $dirty = false;
    
    private array $data = [];
    
    public function set($key, $val): void
    {
        $this->data[$key] = $val;
        $this->dirty = true;
    }
    
    public function save(): void
    {
        if ($this->dirty) {
            // Do something to save the object.
            $this->dirty = false;
        }
    }
}
</code>

Which now offers a publicly-readable marker, internally modifiable, with no opportunity for it to change in an uncontrolled way, without any need for odd code contortions.

==== Hooks can be verbose ====

While every effort has been made to make hooks as compact as reasonable, there are some use cases that are still more clumsy than they need to be.  For example, asymmetric visibility can be emulated with hooks like so:

<code php>
class NamedThing
{
    private string $_name;
    
    public string $name { get => $this->_name; }

    public function __construct(string $name)
    {
        $this->name = $_name;
    }
}
</code>

But that's a lot of non-obvious work, and does have a small performance impact.  It is much more straightforward to do this:

<code php>
class NamedThing
{
    public function __construct(public private(set) string $name) {}
}
</code>

===== Backward Incompatible Changes =====

None.  This syntax would have been a parse error before.

===== Proposed PHP Version(s) =====

PHP 8.3

===== RFC Impact =====

===== Future Scope =====

This RFC is kept very simple.  However, it does allow for future expansion.

==== Alternate operations ====

At this time, there are only two possible operations to scope: read and write.  In concept, additional operations could be added with their own visibility controls.  Possible examples include:

  * ''init'' - Allows a property to be set only from initialization operations, such as <php>__construct</php>, <php>__clone</php>, <php>__unserialize</php>, etc.
  * ''unset'' - Allows a property to be unset from a different scope than it can be set to a real value.

This RFC does NOT include any of the above examples; they are listed only to show that this syntax supports future expansion should a use be found.

==== Additional visibility ====

Should PHP ever adopt packages and package-level visibility, this syntax would be fully compatible with it.  For example, ''public package(set)'' would be a natural syntax to use.

This RFC does NOT include any discussion of such expanded visibility definition, just notes that it in no way precludes such future developments.

==== readonly compatibility ====

As noted above, at this time asymmetric visibility cannot be combined with ''readonly'' properties.  While the implementation of interlacing the two features is not difficult, there are some edge cases that need to be sorted out.  For instance, it may require relaxing the "permitted visibility" rules in some cases.  We felt that was best pushed to a separate RFC to minimize controversy on this RFC.  The authors believe such interlacing can and should be done, just in a separate RFC.

==== Abbreviated form ====

It would be possible in the future to allow the ''get'' visibility to default to ''public'' if only a ''set'' visibility is specified.  That may help avoid long property declarations if combined with ''readonly'' or other features.  It has been omitted for now in the interest of explicitness, but could easily be reintroduced in the future.

===== Proposed Voting Choices =====

This is a simple yes-or-no vote to include this feature.  2/3 majority required to pass.

<doodle title="Include this RFC?" auth="crell" voteType="single" closed="true">
   * Yes
   * No
</doodle>


===== References =====

This syntax is borrowed directly from [[https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html|Swift's access control system]].

Syntax decisions in this RFC are supported by a poll conducted in September 2022.  The results were [[https://externals.io/message/118557#118628|posted to the Internals list]].