====== PHP RFC: Abstract syntax tree ======
  * Date: 2014-07-28
  * Author: Nikita Popov <nikic@php.net>
  * Status: Draft
  * Targeting: PHP.next

===== Introduction =====

This RFC proposes the introduction of an Abstract Syntax Tree (AST) as an intermediary structure in our compilation process. This replaces the existing practice of emitting opcodes directly from the parser.

Decoupling the parser and compiler makes the implementation removes a number of hacks and makes the implementation more maintainable and understandable in general. Furthermore it allows implementing syntax that was not with a single-pass compilation process.

The disadvantage of employing an abstract syntax tree is that it requires more memory during compilation.

===== Proposal =====

===== Implementation =====

==== AST API ====

=== AST node structure and creation ===

A standard AST node is defined as follows:

<code c>
typedef unsigned short zend_ast_kind;
typedef unsigned short zend_ast_attr;

typedef struct _zend_ast {
    zend_ast_kind kind;
    zend_ast_attr attr;
    zend_uint lineno;
    struct _zend_ast *child[1];
} zend_ast;
</code>

''kind'' is a ''ZEND_AST_*'' enum constant indicating the type of the AST node, e.g. ''ZEND_AST_BINARY_OP'' for a binary operation. ''attr'' is a unsigned short that can be used to store kind-specific flags. ''lineno'' is the start line number of the node.

Child nodes are stored in the ''child'' array. The size of this array is determined during allocation based on the kind. Nodes are created using ''zend_ast_create'' or ''zend_ast_create_ex'', depending on whether you want to make use of ''attr'':

<code c>
zend_ast *zend_ast_create_ex(zend_ast_kind kind, zend_ast_attr attr, ...);
zend_ast *zend_ast_create(zend_ast_kind kind, ...);
</code>

For example:

<code c>
zend_ast *ast = zend_ast_create_ex(ZEND_AST_BINARY_OP, ZEND_ADD, left_ast, right_ast);
</code>

AST nodes created this way have a fixed number of children determined by the AST kind. For cases where the number of children is determined dynamically (e.g. arrays, argument lists, statement lists, etc) the type ``zend_ast_list`` is used instead. It is identical to ordinary AST nodes, but contains an additional children count:

<code c>
typedef struct _zend_ast_list {
    zend_ast_kind kind;
    zend_ast_attr attr;
    zend_uint lineno;
    zend_uint children;
    zend_ast *child[1];
} zend_ast_list;
</code>

List nodes are created using ''zend_ast_create_list'' and children are appended using ''zend_ast_list_add''.

<code c>
zend_ast_list *zend_ast_create_list(zend_uint init_children, zend_ast_kind kind, ...);
zend_ast_list *zend_ast_list_add(zend_ast_list *list, zend_ast *op);
</code>

For example, creating and appending to an array AST:

<code c>
/* Initialize array with two elems */
zend_ast_list *list = zend_ast_create_list(2, ZEND_AST_ARRAY,
    zend_ast_create(ZEND_AST_ARRAY_ELEM, value1_ast, key1_ast),
    zend_ast_create(ZEND_AST_ARRAY_ELEM, value2_ast, key2_ast));

/* Add another element afterwards */
list = zend_ast_list_add(list,
    zend_ast_create(ZEND_AST_ARRAY_ELEM(value3_ast, key3_ast));
</code>

Lastly an AST node can store a ''zval''. For this purpose the ''ZEND_AST_ZVAL'' kind is used in conjunction with the ''zend_ast_zval'' structure:

<code c>
/* Lineno is stored in val.u2.lineno */
typedef struct _zend_ast_zval {
    zend_ast_kind kind;
    zend_ast_attr attr;
    zval val;
} zend_ast_zval;
</code>

Zval AST nodes are created using ''zend_ast_create_zval'' or ''zend_ast_create_zval_ex'' (in case ''attr'' is used). There are two additional convenience functions which create a zval AST node from a string or a long:

<code c>
zend_ast *zend_ast_create_zval_ex(zval *zv, zend_ast_attr attr);
zend_ast *zend_ast_create_zval(zval *zv);

zend_ast *zend_ast_create_zval_from_str(zend_string *str);
zend_ast *zend_ast_create_zval_from_long(long lval);
</code>

These functions return the node cast to ''zend_ast*'' for practical purposes. The ''zend_ast_zval'' structure is only used internally and all external code works through ''zend_ast*''.

There is another special node type for class and function declarations, which is not documented here.

=== Usage in the parser ===

The parser stack now uses ''zend_parser_stack_elem'' unions rather than ''znode''s. The union is defined as follows:

<code c>
typedef union _zend_parser_stack_elem {
	zend_ast *ast;
	zend_ast_list *list;
	zend_string *str;
	zend_ulong num;
} zend_parser_stack_elem;
</code>

The ''ast'' member is used when creating ordinary AST nodes:

<code>
callable_variable:
        simple_variable
            { $$.ast = zend_ast_create(ZEND_AST_VAR, $1.ast); }
    |   dereferencable '[' dim_offset ']'
            { $$.ast = zend_ast_create(ZEND_AST_DIM, $1.ast, $3.ast); }
    |   dereferencable '{' expr '}'
            { $$.ast = zend_ast_create(ZEND_AST_DIM, $1.ast, $3.ast); }
    |   dereferencable T_OBJECT_OPERATOR member_name argument_list
            { $$.ast = zend_ast_create(ZEND_AST_METHOD_CALL, $1.ast, $3.ast, $4.ast); }
    |   function_call { $$.ast = $1.ast; }
;
</code>

When lists are created or modified, the ''list'' member is used instead:

<code>
inner_statement_list:
        inner_statement_list inner_statement
            { $$.list = zend_ast_list_add($1.list, $2.ast); }
    |   /* empty */
            { $$.list = zend_ast_create_list(0, ZEND_AST_STMT_LIST); }
;
</code>

The ''str'' member is used to back up doc comments during parsing and ''num'' is utilized to back up line numbers or store flags.

=== Retrieving information from AST nodes ===

For ordinary AST nodes you can directly access the children using ''ast->child[0]'' and so on.

When working with a list node you must first retrieve the list using ''zend_ast_get_list'' (this is effectively just a cast to the ''zend_ast_list*'' type). Afterwards you can iterate through the list as follows:

<code c>
zend_ast_list *list = zend_ast_get_list(ast);

zend_uint i;
for (i = 0; i < list->children; ++i) {
    zend_ast *elem = list->child[i];
    /* ... */
}
</code>

The zval from a zval AST node is fetched using ''zend_ast_get_zval''. As the zval is commonly known to be a string an additional ''zend_ast_get_str'' function is provided, which returns a ''zend_string*''.

Apart from these, there are a number of introspection function, which are useful work generic code working on AST nodes:

  * ''zend_ast_get_lineno'' will return the starting line number for all AST node types. 
  * ''zend_ast_is_list'' returns whether an AST node is a list
  * ''zend_ast_get_num_children'' returns the number of children a **non-list** node has.

=== AST allocation, destruction and copy ===

As the abstract syntax tree is only necessary during compilation and discarded afterwards, AST nodes make use of an arena allocator. The arena is stored in ''CG(ast_arena)''. Before invoking ''zendparse'' this arena must be allocated using ''zend_arena_create''.

Due to the usage of an arena allocator AST nodes do not need to be individually freed, however zvals held by them still need to be destroyed. This is accomplished using ''zend_ast_destroy'', which will recursively walk the AST and dtor all held values. The following code features a sample invocation of the parser, including arena handling:

<code c>
CG(ast_arena) = zend_arena_create(1024 * 32);
compiler_result = zendparse(TSRMLS_C);
if (compiler_result != 0) {
    zend_bailout();
}
zend_compile_top_stmt(CG(ast) TSRMLS_CC);
zend_ast_destroy(CG(ast));
zend_arena_destroy(CG(ast_arena));
</code>

For constant scalar expressions AST nodes need to be preserved after compilation. For this purpose they need to be copied from the arena into ZMM allocated memory. This is accomplished using the ''zend_ast_copy'' function. The heap-allocated AST can then be destroyed using ''zend_ast_destroy_and_free''.

===== Backward Incompatible Changes =====

===== Open Issues =====


===== Patch =====

