====== PHP RFC: Operator functions ======
  * Version: 0.1
  * Date: 2017-09-05
  * Author: Andrea Faulds, ajf@ajf.me
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/operator_functions

===== Background =====
Over time, PHP has gradually acquired more facilities that enable functional programming. A frequent pattern in functional programming is the use of higher-order functions (functions that take or return functions, e.g. <php>array_map()</php>). With higher-order functions, small operations can be composed together to make more complex ones (or even an entire program). PHP's [[http://php.net/manual/en/funcref.php|standard library]] comprises a large set of operations which can potentially be used with higher-order functions. However, PHP's most fundamental set of operations, [[http://php.net/manual/en/language.operators.php|the operators]], are not functions and therefore cannot be directly used with higher-order functions. This means that either wrapper functions for operators must be written by PHP users, or otherwise-generic code which operates on functions must have specific code paths for the operators. 

===== Proposal =====
==== Basics ====
This RFC proposes that, for each of PHP's built-in operators that operate solely on expressions (no assignment operators), a corresponding function with the same symbol would be added to the PHP standard library in the root namespace (<php>\</php>). So, for the <php>+</php> operator there would be a corresponding <php>'+'</php> function, for the <php>===</php> operator a corresponding <php>'==='</php> function, and so on.

These functions could then be passed as arguments to higher-order functions:

<code php>
// Returns the numbers in $positives negated
$negatives = array_map('-', $positives);
</code>
<code php>
// Adds the numbers in $terms together (equivalent to array_sum())
$sum = array_reduce($terms, '+', 0);
// Multiplies the numbers in $terms together (equivalent to array_product())
$sum = array_reduce($terms, '*', 0);
</code>
<code php>
class Data
{
    public $values;
    public function __construct(array $values) {
        $this->values = $values;
    }
    public function sort(callable $function) {
        usort($this->values, $function);
    }
}

$data = new Data([1, 22, 3]);

// Sorts using standard comparison rules
// (equivalent to sort(), but now doesn't need its own code-path)
$data->sort($unsorted, '<=>');

// Sorts using string comparison rules
$data->sort($unsorted, 'strcmp');
</code>

This is particularly useful when combined with partial application and function composition (primitives PHP currently does not have built-in, but which can be manually written):

<code php>
// Square all the numbers in the array
$squared = array_map(partialApply('**', 2), $terms);
</code>

<code php>
// Select only the positive numbers
$positiveSubset = array_filters($numbers, partialApply('>', 0));
</code>

<code php>
// Select only the positive numbers
$positiveSubset = array_filters($numbers, partialApply('>', 0));
</code>

==== Detail ====

Because operators have symbols that aren't valid identifiers in PHP source code (e.g. <php>+</php>), these functions cannot be called directly in the same manner as a normal function (i.e. <php>+(1, 2)</php>). However, a function with any name can be called by specifying its name as a string (e.g. <php>'+'(1, 1)</php> or <php>"+"(1, 1)</php>). Therefore, you could technically use these functions in place of operators:

<code php>
// An excessively verbose version of sqrt(($x1 - $x2) ** 2 + ($y1 - $y2) ** 2)
$distance = sqrt('+'('**'('-'($x1, $x2), 2), '**'('-'($y1, $y2), 2)));
</code>

Of course, there is no practical reason to do this. The usefulness of this proposal is in composing operators with higher-order functions.

The table below lists the new functions that would be added to the root namespace (''\''). Each is named the same as its corresponding operator, including any aliases (for the sake of consistency).

^ Function signature        ^ Corresponding operation             ^
^ <php>'+'($a[, $b])</php>  ^ <php>+$a</php>, <php>$a + $b</php>  ^
^ <php>'-'($a[, $b])</php>  ^ <php>-$a</php>, <php>$a - $b</php>  ^
^ <php>'*'($a, $b)</php>    ^ <php>$a * $b</php>                  ^
^ <php>'/'($a, $b)</php>    ^ <php>$a / $b</php>                  ^
^ <php>'%'($a, $b)</php>    ^ <php>$a % $b</php>                  ^
^ <php>'**'($a, $b)</php>   ^ <php>$a ** $b</php>                 ^
^ <php>'&'($a, $b)</php>    ^ <php>$a & $b</php>                  ^
^ <php>'|'($a, $b)</php>    ^ <php>$a | $b</php>                  ^
^ <php>'^'($a, $b)</php>    ^ <php>$a ^ $b</php>                  ^
^ <php>'~'($a)</php>        ^ <php>~$a</php>                      ^
^ <php>'<<'($a, $b)</php>   ^ <php>$a << $b</php>                 ^
^ <php>'>>'($a, $b)</php>   ^ <php>$a >> $b</php>                 ^
^ <php>'=='($a, $b)</php>   ^ <php>$a == $b</php>                 ^
^ <php>'==='($a, $b)</php>  ^ <php>$a === $b</php>                ^
^ <php>'!='($a, $b)</php>   ^ <php>$a != $b</php>                 ^
^ <php>'<>'($a, $b)</php>   ^ <php>$a <> $b</php>                 ^
^ <php>'!=='($a, $b)</php>  ^ <php>$a !== $b</php>                ^
^ <php>'<'($a, $b)</php>    ^ <php>$a < $b</php>                  ^
^ <php>'>'($a, $b)</php>    ^ <php>$a > $b</php>                  ^
^ <php>'<='($a, $b)</php>   ^ <php>$a <= $b</php>                 ^
^ <php>'>='($a, $b)</php>   ^ <php>$a >= $b</php>                 ^
^ <php>'<=>'($a, $b)</php>  ^ <php>$a <=> $b</php>                ^
^ <php>'&&'($a, $b)</php>   ^ <php>$a <=> $b</php>                ^
^ <php>'and'($a, $b)</php>  ^ <php>$a and $b</php>                ^
^ <php>'||'($a, $b)</php>   ^ <php>$a || $b</php>                 ^
^ <php>'or'($a, $b)</php>   ^ <php>$a or $b</php>                 ^
^ <php>'xor'($a, $b)</php>  ^ <php>$a xor $b</php>                ^
^ <php>'!'($a)</php>        ^ <php>!$a</php>                      ^
^ <php>'.'($a, $b)</php>    ^ <php>$a . $b</php>                  ^

This table notably lacks <php>$a instanceof $b</php>, <php>$a[$b]</php> and <php>$a->$b</php>. There may be an argument for adding these latter two.

===== Backward Incompatible Changes =====
All of these operator functions create no backwards-compatibility break, since they have names that cannot be used for userland functions, and thus they cannot possibly conflict with existing code (except that using exotic extensions like runkit). 

===== Proposed PHP Version(s) =====
This would go in the next PHP 7.x, most likely 7.3.

===== RFC Impact =====
==== To Existing Extensions ====
The patch currently adds these functions to ''ext/standard''. They might make more sense in the Zend Engine instead.

==== To Opcache ====
The patch passes its test under OPcache.

===== Open Issues =====
None.

===== Unaffected PHP Functionality =====
The existing operators themselves behave the same as ever.

Quoting function names in function calls is not new, it is a consequence of [[rfc:uniform_variable_syntax|Uniform Variable Syntax]].

===== Future Scope =====
Operator functions would fit well with built-in partial application and function composition. These could be added as functions, methods on <php>\Closure</php>, or both.

If built-in operators can have corresponding functions, then user functions could have corresponding operators in future, i.e. user-defined operators. This is possible in Haskell, for example, where new operators can be defined as functions.

===== Proposed Voting Choices =====
This is technically a standard library addition, so may only require a 50%+1 majority. It would be a straight Yes/No vote on whether to accept the RFC and merge the patch for PHP 7.3.

===== Patches and Tests =====

A complete patch for php-src, including test, can be found here: https://github.com/php/php-src/pull/2738

There may be some merit to adding this to the language specification, even though it otherwise doesn't cover built-in functions. There is no patch for this at present.

===== Implementation =====
After the project is implemented, this section should contain 
  - the version(s) it was merged to
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature
  - a link to the language specification section (if any)

===== References =====
* Haskell's infix functions (any normal operator is a function and vice-versa) was an inspiration.

===== Rejected Features =====
Keep this updated with features that were discussed on the mail lists.