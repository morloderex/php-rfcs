====== PHP RFC: Improve callbacks in ext/dom and ext/xsl ======
  * Version: 0.1
  * Date: 2023-11-05
  * Author: Niels Dossche, nielsdos@php.net
  * Status: Draft
  * First Published at: https://wiki.php.net/rfc/improve_callbacks_dom_and_xsl

===== Introduction =====

The <php>DOMXPath</php> class allows developers to run XPath expression queries on a HTML/XML document.
The <php>XSLTProcessor</php> class allows developers to perform XSL transformations on HTML/XML documents. It also uses XPath expressions under the hood.
Both of these classes support support calling PHP functions inside XPath expressions. However, there is an unfortunate limitation in that only callable strings are supported. This means that closures, first-class callables, and instance methods cannot be used. This proposal aims to improve the callback support such that any callable can be used.

To better understand the proposal, I'll first give some background to demo the usage as it is today.
Then I'll introduce the proposal itself.

===== Background =====

**Important:** in all examples in this RFC, I will use the following sample document to work with. I will not repeat this code snippet.
<PHP>
// Set up a sample document with links to cats and dogs
$doc = new DOMDocument;
$doc->loadXML(<<<XML
<animals>
    <a box_preference="small" href="cat/jill">Jill</a>
    <a box_preference="medium" href="cat/kes">Kes</a>
    <a box_preference="medium" href="cat/minou">Minou</a>
    <a box_preference="large" href="cat/tessa">Tessa</a>
    <a href="dog/jack">Jack</a>
</animals>
XML);
</PHP>

Let's take a look at how to use a callback with <php>DOMXPath</php>.
We have to use <php>DOMXPath::registerPhpFunctions(string|array|null $restrict=null)</php> to register callbacks.

<PHP>
function my_callback(string $href): bool {
    return preg_match("/cat/", $href);
}

$xpath = new DOMXPath($doc);
// This is necessary to resolve the php:function expression down below to a PHP-specific feature.
$xpath->registerNamespace("php", "http://php.net/xpath");
// This registers the function "my_callback" with the XPath evaluator, such that my_callback can be called.
$xpath->registerPhpFunctions("my_callback");
// This selects all <a> tags where my_callback(their href attribute content) returns true.
$results = $xpath->evaluate("//a[php:function('my_callback', string(@href))]");
foreach ($results as $result) {
    echo "Found ", $result->textContent, "\n";
}

/* This script outputs:
Found Jill
Found Kes
Found Minou
Found Tessa
*/
</PHP>

Note that this is only the simplest example. You can do much more complex actions with it, even with side-effects.
Furthermore, I only showcased a single callback. It's possible to chain multiple callbacks.

Registering multiple callbacks at once is possible too, in that case you have to pass an array to <php>registerPhpFunctions</php>:
<PHP>
// Now my_first_callback and my_second_callback can be used within XPath
$xpath->registerPhpFunctions(["my_first_callback", "my_second_callback"]);

// registerPhpFunctions() is additive, so calling it again will make even more functions callable:
// now strtoupper() will also be callable.
$xpath->registerPhpFunctions("strtoupper");
</PHP>

Finally, if the <php>$restrict</php> argument is null, then all global functions and static class methods will be callable.

I'm not going to repeat this again for <php>XSLTProcessor</php>, but it works the same way: <php>XSLTProcessor</php> also has a <php>registerPhpFunctions</php> method that works exactly the same.

===== Proposal =====

Right now, it is impossible to call instance functions or closures.
Based on feature request https://bugs.php.net/bug.php?id=38595, I propose the following change.

If you pass an array, entries of the form <php>$key => $value</php> will be interpreted as "associate the callable $value with name $key".
Example:

<PHP>
$xpath->registerPhpFunctions(["function_name" => $callable]);
// Now you can use "php:function('function_name', ...)" in XPath expressions to call $callable.
</PHP>

<php>$callable</php> can be any kind of callable, examples: <php>"MyClass::staticFunc"</php>, <php>[$this, "instanceFunc"]</php>, <php>$object->foo(...)</php>, <php>fn ($argument1, $argument2, etc...) => whatever</php>, etc.

The behaviour of passing only a string value without a key will remain the same as before.
And you can mix them with <php>$key => $value</php> entries:

<PHP>
$xpath->registerPhpFunctions([
  "function_name" => $callable,
  "var_dump"
]);
// Now $callable can be called using "php:function('function_name', ...)"
// and var_dump using "php:function('var_dump', ...)".
</PHP>

==== Exceptions vs warnings ====

Prior to PHP 8.0, the <php>DOMXPath</php> class threw warnings in the following error conditions:
  - The handler name is not a string
  - The function callback could not be called because it isn't callable
  - The function callback wasn't registered

In PHP 8.0, these were changed to throw exceptions instead of warnings (https://github.com/php/php-src/pull/5418).
<php>XSLTProcessor</php> has the same error conditions, but still uses warnings to this day.
As part of this proposal, the duplicated code will be unified in a common place, and will therefore use exceptions instead of warnings.

Finally, both for <php>DOMXPath</php> and <php>XSLTProcessor</php>, if you never called <php>registerPhpFunctions</php> it will throw a warning instead of throwing an exception. This is inconsistent because if you //did// call the function but did not register a function that you're trying to call you get an exception instead. I believe these error conditions should be consistent.

==== Method signature ====

The method signature of <php>registerPhpFunctions</php> will remain the same, i.e. <php>registerPhpFunctions(string|array|null $restrict=null)</php>.
You might be wondering why I don't change the string type in that union to callable. There are two reasons:
  - callable|array is ambiguous: what does <php>["foo", "bar"]</php> mean? Does this mean: register both "foo" and "bar" as functions? Or does this mean: register foo::bar ?
  - XPath expressions are written as strings, so we have to give a string name to the callable.

==== Alternatives ====

TODO

===== Backward Incompatible Changes =====

Strictly speaking, as the callable validity is checked earlier (i.e. when calling <php>registerPhpFunctions</php>), this has a subtle break. If the function is not declared yet at the time of calling <php>registerPhpFunctions</php>, then this will throw an error. Previously this was accepted as long as the function was declared by the time the callback was executed. I think however that this situation is sufficiently rare and easily avoidable.

===== Proposed PHP Version(s) =====

Next PHP 8.x, that is 8.4 at the time of writing.

===== RFC Impact =====

==== To Existing Extensions ====

This affects both the ext/dom and ext/xsl extension.
Implementation-wise, the ext/dom extension will gain the shared code to deal with xpath callables because the result set handling already depends on DOM classes. Furthermore, ext/xsl already depends on ext/dom anyway.

===== Open Issues =====

None.

===== Unaffected PHP Functionality =====

Everything else. Why does this section exist?

===== Future Scope =====

None right now.

===== Proposed Voting Choices =====

One primary vote requiring 2/3rd majority: "Accept the proposed changes to ext/dom and ext/xsl callbacks?"

===== Patches and Tests =====

TODO

===== Implementation =====
After the project is implemented, this section should contain 
  - the version(s) it was merged into
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature
  - a link to the language specification section (if any)

===== References =====

  - Pre-RFC pitch: https://externals.io/message/121286
  - Feature request: https://bugs.php.net/bug.php?id=38595
  - Feature request: https://bugs.php.net/bug.php?id=49567

===== Rejected Features =====
Keep this updated with features that were discussed on the mail lists.