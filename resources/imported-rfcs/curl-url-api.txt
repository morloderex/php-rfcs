====== PHP RFC: New Curl URL API ======
  * Version: 0.9
  * Date: 2022-06-16
  * Author: Pierrick Charron <pierrick@php.net>
  * Status: Draft
  * First Published at: https://wiki.php.net/rfc/curl-url-api

===== Introduction =====

Since its version 6.62.0 [1], libcurl features a brand new URL API [2] that can be used to parse and generate URLs, using libcurlâ€™s own parser. One of the goal of this API is to tighten a problematic vulnerable area for applications where the URL parser library would believe one thing and libcurl another. This could and has sometimes lead to security problems [3].

===== Proposal =====

The current RFC propose the addition of 2 new classes :

==== CurlUrl ====

<PHP>
final class CurlUrl implements Stringable
{
    public const APPEND_QUERY = UNKNOWN;
    public const DEFAULT_PORT = UNKNOWN;
    public const DEFAULT_SCHEME = UNKNOWN;
    public const DISALLOW_USER = UNKNOWN;
    public const GUESS_SCHEME = UNKNOWN;
    public const NO_DEFAULT_PORT = UNKNOWN;
    public const ALLOW_UNSUPPORTED_SCHEME = UNKNOWN;
    public const PATH_AS_IS = UNKNOWN;
    public const URL_DECODE = UNKNOWN;
    public const URL_ENCODE = UNKNOWN;
    public const NO_AUTHORITY = UNKNOWN;
    public const ALLOW_SPACE = UNKNOWN;

    public function __construct(?string $url = null, int $flags = 0) {}

    public function get(int $flags = 0): string {}
    public function set(?string $url, int $flags = 0): CurlUrl {}

    public function getHost(): ?string {}
    public function setHost(?string $host): CurlUrl {}

    public function getScheme(): ?string {}
    public function setScheme(?string $scheme, int $flags = 0): CurlUrl {}

    public function getPort(int $flags = 0): ?int {}
    public function setPort(?int $port): CurlUrl {}

    public function getPath(int $flags = 0): string {}
    public function setPath(?string $scheme, int $flags = 0): CurlUrl {}

    public function getQuery(int $flags = 0): ?string {}
    public function setQuery(?string $query, int $flags = 0): CurlUrl {}

    public function getFragment(int $flags = 0): ?string {}
    public function setFragment(?string $fragment, int $flags = 0): CurlUrl {}

    public function getUser(int $flags = 0): ?string {}
    public function setUser(?string $user, int $flags = 0): CurlUrl {}

    public function getPassword(int $flags = 0): ?string {}
    public function setPassword(?string $password, int $flags = 0): CurlUrl {}

    public function getOptions(int $flags = 0): ?string {}
    public function setOptions(?string $options, int $flags = 0): CurlUrl {}

    public function getZoneId(int $flags = 0): ?string {}
    public function setZoneId(?string $zoneid, int $flags = 0): CurlUrl {}

    public function __toString(): string {}
}
</PHP>

=== __construct(?string $url = null, int $flags = 0) ===

Create a new CurlUrl object. The <php>$url</php> argument is the URL to be parsed and the <php>$flags</php> argument is a bitmask with independent features to specify how libcurl should parse the URL.

=== CurlUrl::get(int $flags = 0): string ===

Return the full, normalized, and possibly cleaned up URL version of what was previously parsed.

=== CurlUrl::set(?string $url, int $flags = 0): CurlUrl ===

Set the full URL of the CurlUrl instance. 
If the handle already is populated with a URL, the new URL can be relative to the previous.

=== CurlUrl::getHost(): ?string ===

Get the Host part of the URL.

=== CurlUrl::setHost(?string $host): CurlUrl ===

Set the host part of the URL. 
If it is IDNA the string must then be encoded as your locale says or UTF-8. 
If it is a bracketed IPv6 numeric address it may contain a zone id (or you can use <php>CurlUrl::setZoneid()</php>).

=== CurlUrl::getScheme(): ?string ===

Get the scheme part of the URL.

=== CurlUrl::setScheme(?string $scheme, int $flags = 0): CurlUrl ===

Set the scheme part of the URL.
Libcurl only accepts setting schemes up to 40 bytes long.

<php>CurlUrl::ALLOW_UNSUPPORTED_SCHEME</php> bit need to be used if the scheme is not supported by curl.

=== CurlUrl::getPort(int $flags = 0): ?int ===

Get the port part of the URL.

Used with <php>CurlUrl::DEFAULT_PORT</php>, this method will return the default port for the used scheme if no port was set.

Used with <php>CurlUrl::NO_DEFAULT_PORT</php>, this method will not return the port number if it matches the default port of the scheme.


=== CurlUrl::setPort(?int $port): CurlUrl ===

Set the port part of the URL. The given port number must be between 1 and 65535. Anything else will throw an exception.

=== CurlUrl::getPath(int $flags = 0): string ===

Get the path part of the URL.

=== CurlUrl::setPath(?string $scheme, int $flags = 0): CurlUrl ===

Set the path part of the URL.
If a path is set in the URL without a leading slash, a slash will be inserted automatically when this URL is read from the handle.

=== CurlUrl::getQuery(int $flags = 0): ?string ===

Get the query part of the URL.

=== CurlUrl::setQuery(?string $query, int $flags = 0): CurlUrl ===

Set the query part of the URL.

The query part will also get spaces converted to pluses when asked to URL encode on set with the <php>CurlUrl::URL_ENCODE</php> bit.

If used together with the <php>CurlUrl::APPEND_QUERY</php> bit, the provided part will be appended on the end of the existing query - and if the previous part did not end with an ampersand (&), an ampersand will be inserted before the new appended part.

When <php>CurlUrl::APPEND_QUERY</php> is used together with <php>CurlUrl::URL_ENCODE</php>, the first '=' symbol will not be URL encoded.

The question mark in the URL is not part of the actual query contents.

=== CurlUrl::getFragment(int $flags = 0): ?string ===

Get the fragment part of the URL.
The hash sign in the URL is not part of the actual fragment contents.


=== CurlUrl::setFragment(?string $fragment, int $flags = 0): CurlUrl ===

Set the fragement part of the URL.

=== CurlUrl::getUser(int $flags = 0): ?string ===

Get the user part of the URL.

The hash sign in the URL is not part of the actual fragment contents.

=== CurlUrl::setUser(?string $user, int $flags = 0): CurlUrl ===

Set the user part of the URL.

=== CurlUrl::getPassword(int $flags = 0): ?string ===

Get the password part of the URL.

=== CurlUrl::setPassword(?string $password, int $flags = 0): CurlUrl ===

Set the password part of the URL.

=== CurlUrl::getOptions(int $flags = 0): ?string ===

Get the options part of the URL.

=== CurlUrl::setOptions(?string $options, int $flags = 0): CurlUrl ===

Set the options part of the URL.

=== CurlUrl::getZoneId(int $flags = 0): ?string ===

Get the zone id part of the URL.

=== CurlUrl::setZoneId(?string $zoneid, int $flags = 0): CurlUrl ===

Set the zone id part of the URL.

=== CurlUrl::__toString(): string ===

Same as calling <php>CurlUrl::get()</php>

==== CurlUrlException ====

The <php>CurlUrlException</php> class represents an error raised by libcurl. The constants exposed in this class are all the code that <php>CurlUrlException::getCode()</php> could return. Those code are internally mapped to CURLUE_* error codes that libcurl could raise. Those constants may vary depending on the version of libcurl ext/curl was compiled with.

If ext/curl was compiled with libcurl > 7.80 then <php>CurlUrlException::getMessage()</php> will return a user friendly message that will discriber the problem. (Exemple: Malformed input to a URL function).

<PHP>
final class CurlUrlException extends Exception
{
    /* libcurl >= 7.62.0 */
    public const BAD_PORT_NUMBER = UNKNOWN;
    public const MALFORMED_INPUT = UNKNOWN;
    public const OUT_OF_MEMORY = UNKNOWN;
    public const UNSUPPORTED_SCHEME = UNKNOWN;
    public const URL_DECODING_FAILED = UNKNOWN;
    public const USER_NOT_ALLOWED = UNKNOWN;
    
    /* libcurl >= 7.81.0 */
    public const BAD_FILE_URL = UNKNOWN;
    public const BAD_FRAGMENT = UNKNOWN;
    public const BAD_HOSTNAME = UNKNOWN;
    public const BAD_IPV6 = UNKNOWN;
    public const BAD_LOGIN = UNKNOWN;
    public const BAD_PASSWORD = UNKNOWN;
    public const BAD_PATH = UNKNOWN;
    public const BAD_QUERY = UNKNOWN;
    public const BAD_SCHEME = UNKNOWN;
    public const BAD_SLASHES = UNKNOWN;
    public const BAD_USER = UNKNOWN;
}
</PHP>


===== Backward Incompatible Changes =====

None, except that the class names <php>CurlUrl</php>, <php>CurlException</php> will be declared by PHP and conflict with applications declaring one of the same class name in the global namespace.

===== Proposed PHP Version(s) =====

8.2

===== Future Scope =====

The current implementation of the <php>CurlUrl</php> class is mutable. We might want to add a new <php>ImmutableCurlUrl</php> class.

===== Proposed Voting Choices =====

As per the voting RFC a yes/no vote with a 2/3 majority is needed for this proposal to be accepted.

===== Patches and Tests =====

https://github.com/php/php-src/pull/8770

===== Implementation =====

N/A

===== References =====

  - https://daniel.haxx.se/blog/2018/10/31/curl-7-62-0-moar-stuff/
  - https://daniel.haxx.se/blog/2018/09/09/libcurl-gets-a-url-api/
  - https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf
