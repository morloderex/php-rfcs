====== PHP RFC: Improve hash_hkdf() parameter order and handling ======
  * Version: 0.9
  * Create Date: 2017-02-05
  * Author: Yasuo Ohgaki <yohgaki@ohgaki.net>
  * Status: Draft (or Under Discussion or Accepted or Declined)
  * First Published at: http://wiki.php.net/rfc/improve_hash_hkdf_parameter

===== Introduction =====

HKDF is informational internet standard defined by [[https://tools.ietf.org/html/rfc5869|RFC 5869]]. HKDF is designed to generate secure key for encryption/validation/authentication/etc from other key information such as output from hash_password(), API KEY, etc. The RFC states "**designers of applications are therefore encouraged to provide salt values to HKDF if such values can be obtained by the application.**", but current PHP implementation discourages "salt" parameter use by it signature. 

This PHP RFC will not explain HKDF in detail, please refer to RFC 5869 or other references for details.

  * https://tools.ietf.org/html/rfc5869
  * https://en.wikipedia.org/wiki/Key_derivation_function
  * https://en.wikipedia.org/wiki/HKDF

Typical HKDF usage with PHP would be:

  * Generate new encryption keys for user, session, domain, groups, etc, from existing keys/seeds and attributes.
  * Generate security tokens for CSRF protection, Object Access, etc, from existing keys/seeds and attributes.

hash_hkdf() is added to master without PHP RFC already. It has following signature currently.

<code>
  string hash_hkdf(string algo, string ikm [, int length = 0 [, string info = '' [, string salt = '']]])
</code>

"salt" is the last optional parameter that user would omit blindly.

RFC 5869 "Notes for HKDF Users" states,

<blockquote>3.1.  To Salt or not to Salt

**HKDF is defined to operate with and without random salt.  This is
done to accommodate applications where a salt value is not available.
**We stress, however, that the use of **salt adds significantly to the
strength of HKDF**, ensuring independence between different uses of the
hash function, supporting "source-independent" extraction, and
strengthening the analytical results that back the HKDF design.

Random salt differs fundamentally from the initial keying material in
two ways: it is non-secret and can be re-used.  As such, salt values
are available to many applications.  For example, a pseudorandom
number generator (PRNG) that continuously produces outputs by
applying HKDF to renewable pools of entropy (e.g., sampled system
events) can fix a salt value and use it for multiple applications of
HKDF without having to protect the secrecy of the salt.  In a
different application domain, a key agreement protocol deriving
cryptographic keys from a Diffie-Hellman exchange can derive a salt
value from public nonces exchanged and authenticated between
communicating parties as part of the key agreement (this is the
approach taken in [IKEv2]).

Ideally, the salt value is a random (or pseudorandom) string of the
length HashLen.  Yet, even a salt value of less quality (shorter in
size or with limited entropy) may still make a significant
contribution to the security of the output keying material; **designers
of applications are therefore encouraged to provide salt values to
HKDF if such values can be obtained by the application.**

It is worth noting that, while not the typical case, some
applications may even have a secret salt value available for use; in
such a case, HKDF provides an even stronger security guarantee.  An
example of such application is IKEv1 in its "public-key encryption
mode", where the "salt" to the extractor is computed from nonces that
are secret; similarly, the pre-shared mode of IKEv1 uses a secret
salt derived from the pre-shared key.
</blockquote>

<blockquote>
3.2.  The 'info' Input to HKDF

**While the 'info' value is optional in the definition of HKDF, it is
often of great importance in applications**.  Its main objective is to
bind the derived key material to application- and context-specific
information.  For example, 'info' may contain a protocol number,
algorithm identifiers, user identities, etc.  In particular, it may
prevent the derivation of the same keying material for different
contexts (when the same input key material (IKM) is used in such
different contexts).  It may also accommodate additional inputs to
the key expansion part, if so desired (e.g., an application may want
to bind the key material to its length L, thus making L part of the
'info' field).  There is one technical requirement from 'info': it
should be independent of the input key material value IKM.
</blockquote>


The RFC describes "salt" as "**HKDF is defined to operate with and without random salt. This is done to accommodate applications where a salt value is not available.**", "**salt adds significantly to the strength of HKDF**" and "**designers of applications are therefore encouraged to provide salt values to HKDF if such values can be obtained by the application.**" while "info" as optional and "**it is often of great importance in applications**". It is obvious from the RFC "salt" is more important.

In short, if salt value can be used, users should use it whenever it is possible.


==== hash_hkdf() applications =====

Typical PHP HKDF application can be used with "salt". Application can provide much better security with "salt". This PHP RFC only describes 2 examples here, but there are many PHP HKDF usages that can/should/must use with salt. Developers must consider salt use for better security rather than omitting salt without proper consideration.

Please note that HKDF is designed for super secret key like master key for critical systems. There is nothing wrong to use with hash_password() generated string as input key.

=== Per user data encryption ===

  - Get the secret password hash generated by hash_password() for the user.   $ikm
  - Get application secret salt stored in secure place. e.g. $_ENV   $salt
  - Generate HKDF hash value with 1 and 2. <nowiki> hash_hkdf('sha256', $ikm, 0, '', $salt) </nowiki>
  - Encrypt the user data with the key from 3

Although "salt" can be omitted, per user data encryption can be much stronger for attacks with "salt". 

Suppose your application had SQL injection vulnerability and your data is stolen including password hash and encrypted user data. Secret encrypted data can be decrypted by attackers if "salt" is NOT used. 

See also **Security Note** section blow. The same technique can be used for per user encryption key.

Other way to encrypt per user

  - Get system shared secret encryption key from secure place. $ikm
  - Get user ID which is unique in the system. $info
  - Generate HKDF hash value 1 and 2. <nowiki>hash_hkdf('sha256', $ikm, 0, $info)</nowiki>


Note that both method uses "secret" information for $ikm. However, there is notable difference between these 2. This method uses only 1 secret key (encryption key) and info (user ID) is known to public, 1 stolen key allows attackers to decrypt all encrypted data while previous method requires 2 secret information(password hash and secret salt) to attack. (In addition, attackers have to steal all users password hash)

In fact, latter example is considered as bad HKDF usage. See 'Other Use Cases' section for better.



=== CSRF token ===

When session ID is used for CSRF token, there is risk that session ID can leak to others by saving & sending HTML page, by malware web browser plugins that read page content, etc. Therefore, session ID should not be used as CSRF token. HKDF can be used to generate CSRF token belong to specific session with salt.

Setting up CSRF token
  - Get expiration timestamp. ($salt)
  - Generate HKDF value with 1 and session ID ($ikm).  <nowiki>hash_hkdf('sha256', $ikm, 0, '', $salt)</nowiki>
  - Send key from 2 and timestamp from 1 to browser as CSRF token.

Note: Optimal salt is random value with used hash length. However, as the RFC states weak/low entropy salt is enough. For better security, users may concatenate known random value to timestamp.

Verifying CSRF token
  - Get HKDF key and timestamp($salt) value from request.
  - Check if timestamp is not expired.
  - Generate HKDF value from session ID($ikm) and timestamp($salt). <nowiki> hash_hkdf('sha256', $ikm, 0, '', $salt)</nowiki>
  - Compare HKDF value sent by browser and server generated HKDF value if it matches.

Secure CSRF token expiration can be defined with this method regardless of session ID lifetime. i.e. You can set short CSRF token expiration securely.

==Security Note== 
Users must regenerate session ID periodically regardless of SSL usage for security reasons. Current OWASP recommends to regenerate rather short period. (Absolute timeout discussion is described in next section.)

<blockquote>Common idle timeouts ranges are 2-5 minutes for high-value applications and 15- 30 minutes for low risk applications.</blockquote>
https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Session_Expiration

Therefore, use of session ID as CSRF token key source is not recommended. You are better to use separate key for CSRF token generation in $_SESSION. e.g. $_SESSION['CSRF_TOKEN_IKM'] = session_create_id(); Use secret $_SESSION['CSRF_TOKEN_IKM'] for HKDF key generation where above example uses session ID. With this method, you can generate secure HKDF CSRF token even when session ID is regenerated with your defined token expiration time. 

==Use of info parameter==

"info" parameter may be used to specify domain for generated key. In CSRF context, domain could be "admin", "editor", "user", "visitor", etc. For example, if "admin" is required for all administrative features, even if administrator's CSRF token for other domains, e.g. "user", are stolen, administrative features are protected from CSRF attacks.

===== Proposal =====

Internet RFC clearly recommends "salt" value whenever it is possible. **Users are likely to omit optional parameters without consideration, especially the last one when there are less likely used parameters.**

Change hash_hkdf() signature from

<code>
string hash_hkdf(string algo, string ikm [, int length = 0 [, string info = '' [, string salt = '']]])
</code>

to

<code>
string hash_hkdf(string algo, string ikm, string salt [, string info = '' [, int length = 0 [, bool raw = TRUE]])
 - Return value: HEX string hash value by default, i.e. raw = TRUE
 - algo: Hash algorithm. e.g. "sha1", "sha256"
 - ikm: Secret Input Key Material. Some kind of key. e.g. Super secret master key, password, API key, etc.
 - salt: Secret or non secret salt value. Set NULL to use without salt, raise exception for empty string. e.g Random value such as nonce, timestamp, etc.
 - info: Public Info value. e.g Protocol number, user ID, domain belong to Secret/Public, etc.
 - length: Output length. If omitted, default output size of specified hash function. 
</code>

Note: Parameter order and internal salt parameter handling is changed, i.e. Type and salt length check, is changed. Make return HEX string by default by considering PHP use case and consistency for existing hash functions.

From user perspective, "salt" and "info" parameters can be used interchangeably when compatibility with other systems is not considered. However, it would be good idea to follow RFC 5869 semantics. 
Unlike "info" which could be an optional in many cases, "salt" cannot be an optional with expiration enabled keys for instance. This kind of expiration is common. e.g. Amazon AWS S3 uses HKDF with expiration to allow access to objects. 

Typical PHP applications that need HKDF can use (or should use) salt for security reasons as examples above. Users should consider if salt can be used or not. If salt could be secret, it should be kept as secret. Users shouldn't omit salt blindly. It could lead serious security issue. i.e. When input key is weak and no/weak salt, input key can be guessed from hash_hkdf() output. HKDF with salt makes derived keys considerably stronger. Salt is better to be required parameter because typical PHP applications can supply salt. Salt should set to be empty only when salt cannot be used.

Salt summary for typical PHP HKDF usage:
  * Use salt always when it is possible.
  * Use strong salt if possible.
  * Use secret salt if possible.
  * When input key is weak, must use strong secret salt.
  * Omit salt only when salt cannot be used.

Return value:
  * Most use cases with PHP will require string return values. Make it default.
  * HEX string return value and "raw" flag parameter is required to be consistent with existing hash functions. 

===== Discussions =====

=== Salt is optional. - Salt could be optional, but should be provided always whenever it is possible. ===

<blockquote>
On Mon, Jan 16, 2017 at 8:16 PM, Andrey Andreev <narf@devilix.net> wrote:

There's no comment from you on the PR, inline or not, but I can assure you this was not overlooked.

Salt is optional because RFC 5869 allows it to be optional. There's a reason for each of the current defaults work as they do, as well as the parameter positions:

- Length is in no way actually described as optional, and that makes sense as the function's purpose is to create cryptographic keys, which by nature have fixed lengths. The only reason we could make Length optional is because hash functions' output sizes are known values, and matching the desired OKM length with the hash function size makes for better performance.

- Info can be empty, but the algorithm is pretty much meaningless without it. The purpose of HKDF is to derive 2+ outputs from a single input, with the Info parameter serving as the differentiating factor.

- Salt is ... while recommended, the only thing actually optional.</blockquote>

Incorrect argument. Salt could be optional, but as the RFC describes "salt" as "**salt adds significantly to the strength of HKDF**" and "**designers of applications are therefore encouraged to provide salt values to HKDF if such values can be obtained by the application.**", "info" is actually optional as the RFC states   "Salt" should be provided always whenever it is possible as the RFC recommend.



<blockquote>On Mon, Jan 16, 2017 at 8:08 PM, Nikita Popov <nikita.ppv@gmail.com> wrote:

Making the salt required makes no sense to me.

HKDF has a number of different applications:

a) Derive multiple strong keys from strong keying material. Typical case for this is deriving independent encryption and authentication keys from a master key. This requires only specification of $length. A salt is neither necessary nor useful in this case, because you start with strong cryptographic keying material.

b) Generating per-session (or similar) keys from a (strong cryptographic) master key. For this purpose you can specify the $info parameter. again, a salt is neither necessary nor useful in this case. (You could probably also use $salt instead of $info in this case, but the design of the function implies that $info should be used for this purpose.)

c) Extracting strong cryptographic keying material from weak cryptographic keying material. Standard example here is extracting strong keys from DH g^xy values (which are non-uniform) and similar. This is the usage that benefits from a $salt.

d) Combinations thereof.

Remember that HKDF is an extract-and-expand algorithm, and the extract step (which uses the salt) is only necessary if the input keying material is weak. We always include the extract step for compatibility with the overall HKDF construction (per the RFCs recommendation), but it's essentially just an unnecessary operation if you work on strong keying material.

The only thing that we may want to discuss is whether we should swap the $info and the $salt parameters. This depends on which usage (b or c) we consider more likely.
</blockquote>

a) When deriving keys, "salt" should be supplied whenever it's possible. Simply deriving other key w/o salt would not be typical, not recommended at least, usage with PHP because PHP is not used to implement basic cryptographic algorithms.

b) For per-session encryption/etc, simple choice for secret input key("ikm") would be session ID, random string as "salt" which is a part of final key, optional "info" could be used for additional information such as "confidential"/"public". 

Other way is to use session ID as "info" like Nikita suggested. The RFC states identities as "info" value example. Session ID is secret key by definition, but it could be used as identity. 

While it works, the RFC states "info" as are public information, i.e. "a protocol number, algorithm identifiers, user identities, etc.". We don't have to follow RFC recommendations, this method violates the RFC recommendation.

We are implementing RFC 5689. Not following the RFC recommendation does not make sense.


c) True.

d) True.


"**the extract step (which uses the salt) is only necessary if the input keying material is weak**", this is not what RFC states. 

What it states are "**designers of applications are therefore encouraged to provide salt values to HKDF if such values can be obtained by the application.**" and "**HKDF is defined to operate with and without random salt.  This is done to accommodate applications where a salt value is not available.**"


=== Should not be used with weak key. - It is ok by HKDF definition. ===

<blockquote>On Sun, Feb 5, 2017 at 1:20 AM, Tom Worster <fsb@thefsb.org> wrote:
The salt defends against certain attacks on predictable input key material, i.e. weak passwords. But HKDF should not normally be used for passwords because it is unsuitable.
</blockquote>

Strong key is prefered, but input key shouldn't not have be strong.


===== Other Use Cases =====

Following use case examples are using new hash_hkdf() signiture. $ikm could be any valid keys. Secret master key is assumed for convenience. Generally speaking, secret master key is difficult to maintain, developers are better to avoid it if it is possible.

As you can understand from bad examples, omitting salt is as optional parameter results in optimal implementation.

==== Create Strong Key From Weak Key For a User====

Bad example first

  - Get plain text password for user. ($ikm)
  - Get random string to make strong password. ($info) Provide it as a part of key.
  - Generate encryption key. hash('sha256', $ikm, NULL, $info);
 
Developer shouldn't do this because $info is intended to be public information as per the RFC.

Correct way is

  - Get plain text password for user. ($ikm)
  - Get random string to make strong password. ($salt) Provide it as a part of key.
  - Generate encryption key. hash('sha256', $ikm, $salt);

Note: "salt" is intended to be secret or non secret as per the RFC.

==== Per User Encryption Key ====

Bad example first

  - Get secure secret master key. ($ikm)
  - Get user ID. ($info)
  - Generate encryption key. hash('sha256', $ikm, NULL, $info);

Developers shouldn't do this because once encryption key is stolen, they cannot issue new encryption key.

Correct way is

  - Get secure secret master key. ($ikm)
  - Generate secret or non secret random slat. ($salt) Save salt and provide salt as part of key to user also if it is needed.
  - Get user ID. ($info)
  - Generate encryption key. hash('sha256', $ikm, $salt, $info);

Developers can issue new encryption keys as many as they needed with this way for user.

==== Per Session Encryption Key ====

Bad example first

  - Get secure secret master key. ($ikm)
  - Get session ID. ($info)
  - Generate encryption key. hash('sha256', $ikm, NULL, $info);
 
Developer shouldn't do this because $info is intended to be public information as per the RFC.

Correct way is

  - Get secure secret master key. ($ikm)
  - Get session ID as secret salt. ($salt)
  - Generate encryption key. hash('sha256', $ikm, $salt);

==== URL access key ====

Bad example first

  - Get secure secret master key. ($ikm)
  - Get URL should be protected. ($info)
  - Generate access key. hash('sha256', $ikm, NULL, $info);

Developers shouldn't do this unless they are absolutely sure that URL is accessible with the generated key regardless of stolen key.

Better way is

  - Get secure secret master key. ($ikm)
  - Get random salt. ($salt) Save salt and provide salt as a part of key to user.
  - Get URL should be protected. ($info)
  - Generate encryption key. hash('sha256', $ikm, $salt, $info);

By keeping track valid $salt values, developers can control key validity.

==== Limited URL access key ====

Good example only

  - Get secure secret master key. ($ikm)
  - Get timestamp for access control as non secret salt. ($salt) Provide salt as a part of key.
  - Get URL should be protected. ($info)
  - Generate access key. hash('sha256', $ikm, $salt, $info);

Any keys that have timeout can build similarly.

==== Generate Key with Timeout ====

Good example only

  - Get secure secret master key. ($ikm)
  - Get timestamp + random string for access control as non secret salt. ($salt) Provide salt as a part of key.
  - Generate access key. hash('sha256', $ikm, $salt);

==== Generate Key Whatever Purpose For a User ==== 

Bad example first

  - Get user's password information. ($ikm)
  - Get user ID. ($info) 
  - Generate access key. hash('sha256', $ikm, NULL, $info);

Developers shouldn't do this because developers cannot issue new key for the user.

Better way is

  - Get user's password information. ($ikm)
  - Get random salt. ($salt) Save salt and provide salt as a part of key.
  - Generate access key. hash('sha256', $ikm, $salt);

By keeping track valid $salt values, developers can control key validity and can issue as many as new keys as needed.

==== Generate Key for Group ====

Good example only

  - Get secure secret master key. ($ikm)
  - Get random salt. ($salt) Save salt and provide salt as a part of key.
  - Get group ID. ($info)
  - Generate access key. hash('sha256', $ikm, $salt, $info);

By keeping track valid $salt values, developers can control key validity and can issue as many as new keys as needed.


===== Backward Incompatible Changes =====

None. hash_hkdf() is new function.

===== Proposed PHP Version(s) =====

Next PHP 7.x

===== RFC Impact =====

None.

===== Open Issues =====

Please comment if any.

===== Unaffected PHP Functionality =====

Nothing is affected. hash_hkdf() is new function does not affect any.

===== Future Scope =====

Please comment if any

===== Proposed Voting Choices =====
State whether this project requires a 2/3



===== Patches and Tests =====

TBD

===== Implementation =====
After the project is implemented, this section should contain 
  - the version(s) it was merged to
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature
  - a link to the language specification section (if any)

===== References =====
Links to external references, discussions or RFCs

===== Rejected Features =====
Keep this updated with features that were discussed on the mail lists.