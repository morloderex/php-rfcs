====== PHP RFC: Improve hash_hkdf() parameter order and handling ======
  * Version: 0.9
  * Create Date: 2017-02-05
  * Discussion Start: 2017-02-12
  * Author: Yasuo Ohgaki <yohgaki@ohgaki.net>
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/improve_hash_hkdf_parameter

===== Introduction =====

HKDF is informational internet standard defined by [[https://tools.ietf.org/html/rfc5869|RFC 5869]]. Although the RFC describes HKDF in low level crypto context, HKDF is designed as general purpose key derivation function. It derives secure keys for encryption/validation/authentication/etc from other weak/strong key information such as encryption key, API key, master key, password, etc. However, current hash_hkdf() signature is overly optimized for specialized cryptographic operation. (i.e. To derive "binary" output key with "specified length" for "strong input key". This is hardly be common/most used use case with PHP. In addition, it violates what the RFC recommends.) This PHP RFC proposes more generic and suitable signature/behavior to use HKDF with PHP.

This PHP RFC will not explain HKDF in detail, please refer to RFC 5869 or other references for details.

  * https://tools.ietf.org/html/rfc5869
  * https://en.wikipedia.org/wiki/Key_derivation_function
  * https://en.wikipedia.org/wiki/HKDF

In short, HKDF is a general purpose hash function that is designed to create new key(s) from certain key using cryptographic hash function and HMAC. 

TL;DR; 

Please read "[[#current_status|Current Status]]" section for the issue.

== Terms ==

  * IKM - Input Key Material which is secret.
  * OKM - Output Key Material which is derived by HKDF function.
  * salt - Some entropy value which could be both secret and non secret. Poor entropy like timestamp is acceptable when IKM is strong. Ideally random value of used hash size. Poor IKM example is user defined plain password.
  * info - Context and application specific information such as a protocol number, algorithm identifiers, user identities, etc. These are non secret values by definition.
  * length - Controls HKDF result length.
  * strong key - Cryptographically secure(true) random bytes. Example 256 bit strong key is random_bytes(64). 
  * weak key - Anything not cryptographically secure(true) random bytes. Example 256 bit weak key is hash('sha256', 'myrandompassword', FALSE). This key is extremely weak key.

== Absolute requirement for safe HKDF usage ==

  * Either IKM or salt must be strong.

== Typical HKDF usage with PHP ==

  * Generate security tokens for CSRF protection, Object Access, etc, from "IKM", ""salt" and "info".
  * Generate new encryption keys for user, session, domain, groups, etc, from "IKM", "salt" and "info".
  * Generate secure URL that could be access with password without stored key nor user information in server.

== Current Status ==

hash_hkdf() is added to master without a PHP RFC already. It has following signature currently.

<code PHP>
  string hash_hkdf(string algo, string ikm [, int length = 0 [, string info = '' [, string salt = '']]])
  Return value: "Binary" hash value ONLY.
</code>

In general, "salt" is mandatory or usable in most cases with PHP and improves security, "length" is optional mostly, "info" is what HKDF makes useful but it is optional. The RFC states "**designers of applications are therefore encouraged to provide salt values to HKDF if such values can be obtained by the application**". Nonetheless, current PHP implementation discourages "salt" parameter use by signature. i.e. "salt" is the last optional parameter.

To understand what HKDF does, HMAC should be understood

<code php>
string hash_hmac ( string $algo , string $data , string $key [, bool $raw_output = false ] )
Returns "HEX" or "Binary" string hash value by $raw_output
</code>

HKDF is HMAC extension, therefore followings are cryptographically equivalent. ((HKDF always apply Extend step always, i.e. apply additional HMAC with serial value, so it could be said Extend step adds additionally security. However, it has little significance in the sense of cryptographic strength.))

Example: Derive new strong 256 bits AES key from 128 bits AES key
<code php>
$derivation_key = random_bytes(32); // Create and save a random 256 bit key used to derive new key
// By hash_hmac()
$key256 = hash_hmac('sha256', $key128, $derivation_key, TRUE);
// By hash_hkdf()
$key256 = hash_hkdf('sha256', $key128, 0, '', $derivation_key);
</code>

Although hash_hmac() and hash_hkdf() has equivalent usage, new hash_hkdf() has inconsistent signature and return value, "Binary" and "HEX". ((You should provide more entropy to derive strong 256 bit key from 128 bit key. Without entropy(salt or pre-shared key), derived key simply will not have enough entropy.)) It makes little sense to have the most important parameter as the last optional parameter. These are unnecessary inconsistencies with hash_hmac() and RFC 5869. 

Current hash_hkdf() also encourages poor key derivation.

Example: Poor 256 bits (32 bytes) AES key derivation from 128 bits AES key
<code php>
// Weak key expansion from 128 bit key to 256 bit key 
$key256 = hash_hkdf('sha256', $key128); 
// Or even worse
$key256 = hash_hkdf('sha1', $key128, 32);
</code>
Users must not do this unless derivation key(salt) cannot be used((Entropy in derived keys do not change at all with these methods, i.e. Not strong as it should be. Therefore, they are much weaker than methods use appropriate derivation key, i.e. salt)). Although aboves are misuse, it is clear that current hash_hkdf() encourages poor usage/misuse by ignoring strong RFC 5869 recommendation.

== RFC 5869 Notes for HKDF users==

In many use cases, IKM could be strong key. However, in real world, IKM could be user defined poor plain text password. 

RFC 5869 "Notes for HKDF Users" states,

<blockquote>3.1.  To Salt or not to Salt

**HKDF is defined to operate with and without random salt.  This is
done to accommodate applications where a salt value is not available.
We stress, however, that the use of salt adds significantly to the
strength of HKDF**, ensuring independence between different uses of the
hash function, supporting "source-independent" extraction, and
strengthening the analytical results that back the HKDF design.
</blockquote>

Primary purpose of "salt" is to generate stronger key from IKM by "salt" entropy.
"Salt" is also often used as pre shared key. i.e. Salt is combined final key. 

<blockquote>
3.2.  The 'info' Input to HKDF

**While the 'info' value is optional in the definition of HKDF, it is
often of great importance in applications**.  Its main objective is to
bind the derived key material to application- and context-specific
information.
</blockquote>

Primary purpose of "info" is to distinguish key context so that generated key 
is only usable to specific context. i.e. Users should not use secret value for
"info".

==== Summary of ikm, salt and info parameter ====

  * Either IKM or salt must be strong key.
  * IKM could be weak or strong key, strong key is preferred but it's not mandatory requirement. IKM is user controllable. 
  * salt could be weak or strong key, secret or non secret, often used as pre-shared key such as nonce. salt must not be user controllable.
  * info is non secret optional value, shouldn't use secret value while it could be used as combined key like salt.
  * length is optional unless you need to change existing key(IKM) length. Modified length results in weaker output key almost always.

Although it may seem IKM and salt is interchangeable, there is important difference that salt must be not be user controllable. salt and info may seem they are interchangeable. However unlike salt, info must always be non secret.  

==== hash_hkdf() behavior and other hash functions ====

md5() is used to obtains shorter result from hash_hkdf(). In practice, developers should consider SHA2 or better.

<blockquote>
[yohgaki@dev PHP-master]$ ./php-bin -r 'var_dump(bin2hex(hash_hkdf("md5","123456")));'

string(32) "**1a4f9cd30ab214082d93ba850f1fa2b0**"

[yohgaki@dev PHP-master]$ ./php-bin -r 'var_dump(bin2hex(hash_hkdf("md5","123456", 20)));'

string(40) "**1a4f9cd30ab214082d93ba850f1fa2b0**54cfcd49"

[yohgaki@dev PHP-master]$ ./php-bin -r 'var_dump(bin2hex(hash_hkdf("md5","123456", 20, "1")));'

string(40) "d0d1bbee08810d08a1e54f3a401308353cedd30b"

[yohgaki@dev PHP-master]$ ./php-bin -r 'var_dump(bin2hex(hash_hkdf("md5","123456", 20, "1", "1")));'

string(40) "ca16de591ad40f02e599428bf9f50772ebead3ff"
</blockquote>

Both "salt" and "info" parameters affect hash_hkdf() result.  Although hash_hkdf() does some hash calculations (HMAC with specified hash) to derive secure key from IKM, salt and info, it could be understood as simple hash calculation by using separate parameters with hash_hmac(string $algo, string $data, string $key), i.e. $key is devided into $salt (secret or non secret) and $info (non secret) from user point of view. "length" parameter works in a way that weaken derived key.

Therefore, following code is equivalent. ((hash_hkdf() adds more security by extra hash_hmac($hash, $PRK, "\x01"), but single hash_hmac() should be sufficient by HAMC definition)) 

<code php>
// Although the value returned differs due to algorithm difference, they are equivalent
$key = hash_hmac('sha256', $ikm, $salt);
$key = bin2hex(hash_hkdf('sha256', $ikm, 0, '', $salt)); // Need bin2hex() because hash_hkdf() return binary result always
</code>

Although followings are supposed to be equivalent if hash is truly cryptographic, but 
they aren't because hash functions have some characteristics that allow analysis. 

<code php>
// Trying to add 'Admin' only context information to derived $key
$key = hash('sha256', $ikm . $salt . 'Admin'); // This should work in theory, but has greater risks than blow
$key = hash_hmac('sha256', $ikm, $salt . 'Admin'); // Better, but involves risk by string concatenation 
$key = bin2hex(hash_hkdf('sha256', $ikm, 0, 'Admin', $salt)); // More secure than aboves because $info parameter('Admin') is designed for non secret
</code>


==== hash_hkdf() applications with PHP =====

Typical PHP HKDF application can be used with "salt". Application can provide better security with "salt", strong salt is mandatory in many cases. There are many PHP HKDF usages that can/should/must use with salt. This PHP RFC only describes 4 examples here. Developers must consider salt use for better security rather than omitting salt without proper consideration. Salt is often a part of final key which is combined key for users to access resources. Developers should use strong salt if it is possible. When IKM is weak, developer must use strong salt to keep IKM and OKM security.

There are more usages for low level crypto, but these would not be common for average PHP developers/applications, so these are not covered. Crypto specialists should be able to use HKDF hash properly regardless of examples here.

=== Example #1: Generating strong encryption key from weak key (password) ===

Although this usage would not be the most used with PHP, but following 3 examples. This would be one of most common example usage for HKDF application. There will be this usage with PHP also.

  - Get user enter password for encryption. $ikm
  - Get random strong salt for the user. $salt e.g. random_bytes(32) Keep salt secret.
  - Specify key context if it is possible. $info e.g. "Confidential", "Secret", "Restricted" and "Non secret"
  - Specify key size if it is needed. $length
  - Derive strong key from weak $ikm by hash_hkdf('sha256', $ikm, $length, $info, $salt);
  - Use the output key from 5 for encryption.

User entered password is extremely weak key. Therefore, strong salt is mandatory for security unless such salt cannot be used. Omitting strong salt or non secret salt results in extremely weak encryption key that attackers can crack easily. $info and $length is optional.

Note: Salt generated by 2 is better to belong only to the user. i.e. Generate random strong salt for each user and keep it for the user. It could be application wide shared salt, but this is more vulnerable.

=== Example #2: Web page with expiration that requires specific password ===

This is second example that HKDF could be used with weak IKM (password). Note that this method fundamentally differs from user ID based access control. i.e No user registration required nor stored keys on server side.

With this method, system does not have to store each combinations of $_GET['salt'], $_GET['timestamp'] (info) and $_POST['password'] (ikm). Except IKM is weak so that user can type it, other keys are cryptographically secured. 

Step1: Setting up keys
  - Generate random password for the URL. e.g. <nowiki>base64_encode(random_byte(8))</nowiki> $ikm
  - Generate random secret and strong salt stored in the URL. $salt is pre-shared key.
  - Get expiration $timestamp
  - Get the URL and set expiration time. $info e.g. **<nowiki>http://example.com/the_page?expire=$timestamp</nowiki>**
  - Generate HKDF hash value ( $hk ) with 1, 2 and 3. <nowiki>hash_hkdf('sha256', $ikm, 0, $info, $salt)</nowiki> as a part of combined key.
  - Send final URL includes $salt (e.g. **<nowiki>http://example.com/the_page?expire=$timestamp&salt=$salt&hk=$hk</nowiki>**) via mail/etc.
  - Notify password ($ikm) via SMS/etc.

Step2: Validating keys
  - Ask and get user to enter password ($ikm) that is supposed to be generated by Step1.
  - Get salt and hk parameters in the URL. $salt, $hk
  - Get the URL ($info) without $salt and $hk. i.e. **<nowiki>http://example.com/the_page?expire=$timestamp</nowiki>**  
  - Generate HKDF hash value with 1, 2 and 3. <nowiki>hash_hkdf('sha256', $ikm, 0, $info, $salt)</nowiki>
  - Compare computed HKDF hash value by 4 and $hk from 2, allow access to the page only when they match.

Note: You would be better to deploy password brute force attack countermeasure. hash_password()/crypt() is designed for password, but developers shouldn't use it unless performance and DoS is not your concern, because hash_password()/crypt() is designed to be inefficient to calculate password hash. 

=== Example #3: Per user data encryption ===

This is an example that "salt" over "info" results in better design.

Less secure design

  - Get application secret and strong secret master key stored in secure place. e.g. $_ENV   $ikm
  - Get user ID for key to be user specific. $info  
  - Compute HKDF hash value with 1 and 2. <nowiki> hash_hkdf('sha256', $ikm, 0, $info) </nowiki>
  - Encrypt the user data with the key from 3

Suppose your application had SQL injection vulnerability and your data is stolen including password hash and encrypted user data. Secret encrypted data can be decrypted by attackers. 

Better design

  - Get application secret and strong secret master key stored in secure place. e.g. $_ENV  $ikm
  - Get strong random salt as combined key, store it as secret key for the user. $salt
  - Compute HKDF hash value with 1 and 2. <nowiki> hash_hkdf('sha256', $ikm, 0, '', $salt) </nowiki>
  - Encrypt the user data with the key from 3

Both method uses application wie "secret" $ikm. However, there is notable difference between these 2. This method uses only 1 secret $ikm key (master encryption key) and $info (user ID) is known to public, one stolen key allows attackers to decrypt all encrypted data. Latter method requires 2 secret information(master encryption $ikm key and secret $salt as combined key) to attack. 


=== Example #4: Advanced CSRF token ===

This example shows how HKDF could be used for CSRF token that has both expiration time and context limitation, i.e. URL specific CSRF token without server resource.

When session ID is used for CSRF token, there is risk that session ID can leak to others by saving & sending HTML page, by malware web browser plugins that read page content, etc. Therefore, session ID should not be used as CSRF token. HKDF can be used to generate CSRF token belongs to specific session with "salt".

Setting up CSRF token

Generate strong CSRF token seed, store it in $_SESSION. ( $_SESSION['CSRF_TOKEN_SEED'] = random_bytes(32) )

  - Use CSRF_TOKEN_SEED as secret key. ( $ikm ) (Simple CSRF token use this value as token)
  - Get expiration timestamp. ( $salt ) Weak salt is OK, since $ikm is strong.
  - Compute HKDF hash value with 1 and 2.  <nowiki>hash_hkdf('sha256', $ikm, 0, '', $salt)</nowiki>
  - Send key from 3 and timestamp from 2 to browser as CSRF token.

Verifying CSRF token
  - Get HKDF key and timestamp ( $salt ) value from request.
  - Check if timestamp is not expired.
  - Compute HKDF hash value from CSRF_TOKEN_SEED ( $ikm ) and timestamp ( $salt ). <nowiki> hash_hkdf('sha256', $ikm, 0, '', $salt)</nowiki>
  - Compare HKDF hash value sent by browser and server computed HKDF hash value if it matches.

Secure CSRF token expiration and used context can be defined with this method regardless of session ID lifetime. Developers do not need hash_hkdf() because this could be done by safely with hash_hmac().
 
Above example could be extended to "CSRF token for specific URL" easily with optional $info parameter.

Setting up CSRF token
  Generate strong CSRF token seed, store it in $_SESSION. ( $_SESSION['CSRF_TOKEN_SEED'] = random_bytes(32) )
  - Use CSRF_TOKEN_SEED as secret key. ( $ikm ) (Simple CSRF token use this value as token)
  - Get expiration timestamp. ( $salt ) Weak salt is OK, since $ikm is strong.
  - Get URL for this CSRF token. ( $info )
  - Compute HKDF hash value with 1 and 2.  <nowiki>hash_hkdf('sha256', $ikm, 0, '', $salt)</nowiki>
  - Send key from 3 and timestamp from 2 to browser as CSRF token.

Verifying CSRF token
  - Get HKDF key and timestamp ( $salt ) value from request.
  - Check if timestamp is not expired.
  - Get requested URL. ( $info )
  - Compute HKDF hash value from CSRF_TOKEN_SEED ( $ikm ), timestamp ( $salt ) and URL ( $info ). <nowiki> hash_hkdf('sha256', $ikm, 0, $info, $salt)</nowiki>
  - Compare HKDF hash value sent by browser and server computed HKDF hash value if it matches.



===== Proposal =====

Change hash_hkdf() signature from

<code php>
string hash_hkdf(string $algo, string $ikm [, int $length = 0 [, string $info = '' [, string $salt = '' ]]])
Return value: Binary hash value ONLY.
</code>
  * $algo: Hash algorithm. e.g. "sha1", "sha256"
  * $ikm: Secret or non secret Input Key Material. Some kind of key. e.g. Super secret master key, password, API key, etc.
  * $length: Optional Output length. If omitted, default output size of specified hash function. 
  * $info: Optional Generated key context. e.g Protocol number, user ID, group ID, applicable URI, etc.
  * $salt: Optional secret or non secret salt value. e.g Random value such as nonce, timestamp, etc.

to

<code php>
string hash_hkdf(string $algo, string $ikm, string $salt , string $info [, int $length = 0 [, bool $raw_output = FALSE]])
Return value: HEX string hash value by default.
</code>
  * $salt: Set empty string to use without salt. More precedence over $info because HKDF security depends on $salt or $ikm strength.
  * $info: Set empty string to use without salt. Optional context but user should use hash_hmac() without $info.
  * $length: Mostly needless unless users need key derivations for low level crypto operations.
  * $raw_output: Return raw(binary) or HEX. API consistency. Majority of PHP use cases would require non binary output and HEX is good enough.

Note: Only changed/added are described.

Insecure usage is easily possible with current signature.
<code php>
$key = hash_hkdf('sha256', $weak_key); // Generate secure $key!! <= This isn't secure at all w/o strong salt
$key = hash_hkdf('sha256', $weak_key, 80); // Generate even more secure $key!! <= Length does not add strength to OKM.
$key = hash_hkdf('sha256', $weak_key, 80, 'Admin'); // Generate even more secure $key only usable in 'Admin' context!! <= info does not add strength to OKM because it supposed to be non secret.
</code>

$salt is described as more important parameter than "info" in RFC 5869, and it recommends there should be appropriate $salt whenever it is possible. $info makes HKDF more valuable because simpler and faster hash_hmac(string $algo , string $data , string $key [, bool $raw_output = false ] ) could be used instead when $info could be omitted. hash_hkdf() could be viewed as hash_hmac() extension. (It is HMAC extension indeed) It should be better to have compatible signatures for API consistency. 

i.e.
<code php>
string hash_hmac(string $algo, string $data, string $key [, bool $raw_output = FALSE ])
Return value: HEX string hash value by default.

string hash_hkdf(string $algo, string $ikm, string $salt , string $info [, int $length = 0 [, bool $raw_output = FALSE ]])
Return value: HEX string hash value by default.
</code>

For these reasons, $salt and $info are made to required parameters and made return to HEX hash value by default.


=== Rationale behind salt as required parameter ===

  * Should use salt always when it is possible as per the RFC.
    * Must use strong salt if it is possible.
    * Must use secret salt if it is possible.
    * Must use strong secret salt when input key is weak.
  * Omitting salt is usually a bad(weak) design. See 'hash_hkdf() applications with PHP' and 'Other Use Cases' section.

=== Rationale behind info as required parameter ===

  * hash_hmac() could be used when info has no use.
  * info has well defined purpose, derive key(s) for context specific by non secret information. 

=== Rationale behind changed return value ===

  * HEX string return value and "raw" flag parameter is required to be consistent with existing hash functions.  
  * Most use cases with PHP will require string return values.

hash('sha256', something) and hash_hmac('sha256', something) returns HEX. hash_hkdf() which is HMAC returns "binary" breaks API consistency and disturbs common usage with PHP.

===== Discussions =====

=== Salt is optional. - Salt could be optional, but it should be provided always whenever it is possible. ===

<blockquote>
On Mon, Jan 16, 2017 at 8:16 PM, Andrey Andreev <narf@devilix.net> wrote:

There's no comment from you on the PR, inline or not, but I can assure you this was not overlooked.

Salt is optional because RFC 5869 allows it to be optional. There's a reason for each of the current defaults work as they do, as well as the parameter positions:

- Length is in no way actually described as optional, and that makes sense as the function's purpose is to create cryptographic keys, which by nature have fixed lengths. The only reason we could make Length optional is because hash functions' output sizes are known values, and matching the desired OKM length with the hash function size makes for better performance.

- Info can be empty, but the algorithm is pretty much meaningless without it. The purpose of HKDF is to derive 2+ outputs from a single input, with the Info parameter serving as the differentiating factor.

- Salt is ... while recommended, the only thing actually optional.</blockquote>

Incorrect argument. Salt could be optional, but as the RFC describes "salt" as "**salt adds significantly to the strength of HKDF**" and "**designers of applications are therefore encouraged to provide salt values to HKDF if such values can be obtained by the application.**", "info" is actually optional.  "Salt" should be used always whenever it is possible as the RFC recommends.

In order to obtain strong output key, either input key or salt must be cryptographically strong. i.e. When input key is weak, strong salt is mandatory by HKDF definition.

In any cases, 'info'(context) has less importance than 'salt'(entropy) at least.

<blockquote>On Mon, Jan 16, 2017 at 8:08 PM, Nikita Popov <nikita.ppv@gmail.com> wrote:

Making the salt required makes no sense to me.

HKDF has a number of different applications:

a) Derive multiple strong keys from strong keying material. Typical case for this is deriving independent encryption and authentication keys from a master key. This requires only specification of $length. A salt is neither necessary nor useful in this case, because you start with strong cryptographic keying material.

b) Generating per-session (or similar) keys from a (strong cryptographic) master key. For this purpose you can specify the $info parameter. again, a salt is neither necessary nor useful in this case. (You could probably also use $salt instead of $info in this case, but the design of the function implies that $info should be used for this purpose.)

c) Extracting strong cryptographic keying material from weak cryptographic keying material. Standard example here is extracting strong keys from DH g^xy values (which are non-uniform) and similar. This is the usage that benefits from a $salt.

d) Combinations thereof.

Remember that HKDF is an extract-and-expand algorithm, and the extract step (which uses the salt) is only necessary if the input keying material is weak. We always include the extract step for compatibility with the overall HKDF construction (per the RFCs recommendation), but it's essentially just an unnecessary operation if you work on strong keying material.

The only thing that we may want to discuss is whether we should swap the $info and the $salt parameters. This depends on which usage (b or c) we consider more likely.
</blockquote>

a) When deriving keys, "salt" should be supplied whenever it's possible. Simply deriving other key w/o salt would not be typical, not recommended at least, usage with PHP because PHP is not used to implement basic cryptographic algorithms.

b) If I assume 'user identity' is used for "info", then derived key wouldn't be "per session" key, but "per user" key. So assuming session ID is used as "info". While it works, the RFC states "info" as are non secret information, i.e. "a protocol number, algorithm identifiers, user identities, etc.". Session ID is secret key. We don't have to follow RFC recommendations always, but storing secret key in "info"(context) violates the RFC.

For per-session encryption/etc, simple choice for secret input key(IKM) would be per-session master key stored in $_SESSION, random string as "salt" which is a part of final key, optional "info"(context) could be used for additional information such as "confidential","public", etc. 

We are implementing RFC 5869. Not following the RFC recommendation does not make sense.


c) True, but "salt" is not only good for generating strong key from weak key according to the RFC. "salt" can be used as part of final key just like crypt() calculates password hash by "salt and password".

d) True, but you seems to be missed "non secret salt" usage. 'Other Use Cases' section includes many "non secret salt" that are used as final key. Like examples in this PHP RFC, there are valid use cases with very weak IKM. 


"**the extract step (which uses the salt) is only necessary if the input keying material is weak**", this cannot be true by the RFC.

What the RFC states is 

<blockquote>
Yet, even a salt value of less quality (shorter in
size or with limited entropy) may still make a significant
contribution to the security of the output keying material
</blockquote>

It does not say salt is only good for weak input keys, but generated key will have significantly better security. 


=== Should not be used with weak key. - It is ok by HKDF definition. ===

<blockquote>On Sun, Feb 5, 2017 at 1:20 AM, Tom Worster <fsb@thefsb.org> wrote:
The salt defends against certain attacks on predictable input key material, i.e. weak passwords. But HKDF should not normally be used for passwords because it is unsuitable.
</blockquote>

Strong key is prefered, but input key shouldn't not have to be strong. For weak keys, strong salt should be used though.


===== Other Use Cases =====

Following use case examples are using new hash_hkdf() signiture. $ikm could be any valid keys. Secret master key is assumed for convenience. Generally speaking, secret master key is difficult to maintain, developers are better to avoid it if it is possible.

As you can understand from bad examples, omitting salt is as optional parameter results in optimal implementation.

==== Create Strong Key From Weak Key For a User====

Bad example first

  - Get plain text password. ($ikm)
  - Get random string to make strong password. ($info) 
  - Generate encryption key. hash('sha256', $ikm, NULL, $info);
 
Although it works, developers shouldn't do this because $info is intended for context which is public information as per the RFC.

Correct way is

  - Get plain text password for user. ($ikm)
  - Get secret random string to make strong password. ($salt) 
  - Generate encryption key. hash('sha256', $ikm, $salt);

Note: "salt" is intended to be secret or non secret as per the RFC, but salt should be secret.
Since $ikm is very weak, salt must be strong. 


==== Per User Encryption Key ====

Bad example first

  - Get secure secret master key. ($ikm)
  - Get user ID. ($info)
  - Generate encryption key. hash('sha256', $ikm, NULL, $info);

Developers shouldn't do this because once encryption key is stolen, they cannot issue new encryption key.

Correct way is

  - Get secure secret master key. ($ikm)
  - Generate secret or non secret random slat. ($salt) Save salt and provide salt as part of key to user also if it is needed.
  - Get user ID. ($info)
  - Generate encryption key. hash('sha256', $ikm, $salt, $info);

Developers can issue new encryption keys as many as they needed with this way for user.

Combined key, output key and salt, may be disclosed to user as encryption key.

==== Per Session Encryption Key ====

Bad example first

  - Get secure secret master key. ($ikm)
  - Get session ID. ($info)
  - Generate encryption key. hash('sha256', $ikm, NULL, $info);
 
Although it works, developers shouldn't do this because $info is intended for context(public information) as per the RFC.

Correct way is

  - Get secure secret master key. ($ikm)
  - Set secret random salt to session, get it as salt. ($salt) 
  - Generate encryption key. hash('sha256', $ikm, $salt);

==== URL access key ====

Bad example first

  - Get secure secret master key. ($ikm)
  - Get URL should be protected. ($info)
  - Generate access key. hash('sha256', $ikm, NULL, $info);

Developers shouldn't do this unless they are absolutely sure that URL is accessible with the generated key regardless of stolen key.

Better way is

  - Get secure secret master key. ($ikm)
  - Get random salt. ($salt) Save salt and provide salt as a part of key to user.
  - Get URL should be protected. ($info)
  - Generate encryption key. hash('sha256', $ikm, $salt, $info);

By keeping track valid $salt values, developers can control key validity.

Combined key, output key and salt, may be disclosed to user as encryption key.


==== Limited URL access key ====

Good example only

  - Get secure secret master key. ($ikm)
  - Get timestamp for access control as non secret salt. ($salt) Provide salt as a part of key.
  - Get URL should be protected. ($info) Accessed URL is known to server when user accesses it.
  - Generate access key. hash('sha256', $ikm, $salt, $info);

Any keys that have timeout can build similarly.

==== Generate Key with Timeout ====

Good example only

  - Get secure secret master key. ($ikm)
  - Get timestamp + random string for access control as non secret salt. ($salt) Provide salt as a part of key.
  - Generate access key. hash('sha256', $ikm, $salt);

==== Generate Key Whatever Purpose For a User ==== 

Bad example first

  - Get user's password information. ($ikm)
  - Get user ID. ($info) 
  - Generate access key. hash('sha256', $ikm, NULL, $info);

Developers shouldn't do this because developers cannot issue new key for the user, cannot revoke keys. Since input is weak, there must be strong salt also.

Better way is

Note: this example's salt is secret partially, non secret partially.

  - Get user's password information. ($ikm)
  - Get random secret master salt (Per system or per user. Per user prefered.) + get random salt(user key) as combined key. ($salt) Save user key salt and provide it as a part of key.
  - Generate access key. hash('sha256', $ikm, $salt);

By keeping track salt values, developers can control key validity.


==== Generate Key from Whatever ID ==== 

Bad example first

  - Get secret master key. ($ikm) 
  - Get ID. ($info) Could be non secret ID like group ID display in URL.
  - Generate access key. hash('sha256', $ikm, NULL, $info);

Developers shouldn't do this because developers cannot issue new key for the user, cannot revoke keys. Since input is weak, there must be strong salt also.

  - Get secret master key. ($ikm)
  - Get random secret salt for ID ($salt)
  - Get ID ($info) Could be non secret ID like group ID display in URL.
  - Get key version ($info)
  - Generate key. hash('sha256', $ikm, $salt, $info);

Use output key, ID and key version as combined key. Users may revoke keys by checking ID and/or key version.


==== Generate Key for Group ====

Good example only

  - Get secure secret master key. ($ikm)
  - Get random salt. ($salt) Save salt and provide salt as a part of key.
  - Get group ID. ($info)
  - Generate access key. hash('sha256', $ikm, $salt, $info);

By keeping track valid $salt values, developers can control key validity and can issue as many as new keys as needed.


===== Backward Incompatible Changes =====

None. hash_hkdf() is new function.

===== Proposed PHP Version(s) =====

Next PHP 7.x

===== RFC Impact =====

None.

===== Open Issues =====

Please comment if any.

===== Unaffected PHP Functionality =====

Nothing is affected. hash_hkdf() is new function does not affect any.

===== Future Scope =====

Please comment if any

===== Proposed Voting Choices =====
State whether this project requires a 2/3



===== Patches and Tests =====

TBD

===== Implementation =====
After the project is implemented, this section should contain 
  - the version(s) it was merged to
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature
  - a link to the language specification section (if any)

===== References =====
Links to external references, discussions or RFCs

===== Rejected Features =====
Keep this updated with features that were discussed on the mail lists.