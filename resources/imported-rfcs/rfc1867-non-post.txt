====== PHP RFC: RFC1867 for non-POST HTTP verbs ======

  * Date: 2023-10-04
  * Author: Ilija Tovilo, tovilo.ilija@gmail.com
  * Status: Draft
  * Target Version: PHP 8.x
  * Implementation: https://github.com/php/php-src/pull/11472

===== Proposal =====

//This section assumes knowledge about RFC1867. You might want to read the section "RFC1867 background" first for a refresher.//

RFC1867 defines the multipart/form-data content type. This content type is used primarily for submitting HTTP forms that contain files. PHP supports the parsing of this content type natively, but only for POST requests. Specifically, if a request has the method POST and the content type multipart/form-data the request body is immediately consumed before starting the PHP script and populated into the $_POST and $_FILES superglobals. This functionally triggers automatically and is not exposed to userland directly.

With the emergence of REST it has become increasingly popular to use other HTTP verbs such as PUT and PATCH where the usage of multipart/form-data is entirely valid but not processed by PHP. This requires manual parsing of the request body of this non-trivial format. Handling large amounts of data in userland may also be suboptimal in terms of performance.

This RFC suggests adding a new function ''populate_post_data()'' to expose the existing functionality to userland so that it may be used for other HTTP verbs.

<code php>
/**
 * @param resource<stream>|null $input_stream
 */
function populate_post_data($input_stream = null, ?string $content_type = null): array {}

// This is a PUT request
var_dump($_POST);  // []
var_dump($_FILES); // []

[$_POST, $_FILES] = populate_post_data();

var_dump($_POST);  // [...]
var_dump($_FILES); // [...]
</code>

The function returns an array pair with index 0 in the shape of $_POST, index 1 in the shape of $_FILES. If desired, the return values can overwrite the $_POST and $_FILES superglobals. This makes it easy to share existing code that already works for POST endpoints.

The function also accepts an optional stream as input. This is useful for applications like RoadRunner that use the CLI SAPI for running webserver workers. If the input stream is set, it is requires to pass a content type. This has two reasons:

  * The content type needs to figure out what format the content has to know how to parse it (currently multipart/form-data or application/x-www-form-urlencoded).
  * If the content type is multipart/form-data the parser requires a boundary which is embedded in the Content-Type header.

===== Removing files =====

PHP automatically removes uploaded files at the end of the request. For users of ''populate_post_data()'' with an input stream, it is expected that the process may handle multiple requests and thus multiple calls to this function. It may be desired to add another function that can be called at the end of the request to clean up temporary files manually.

TBD

==== RFC1867 background ====

RFC1867 defines the multipart/form-data content type. This content type is used primarily for submitting HTTP forms that contain files. It is similar to application/x-www-form-urlencoded in that it contains a list of key-value pairs for each form input. Each input may contain metadata, as well as the content of the input. Each of the inputs is separated with a boundary which is an arbitrary string sequence not used in any of the input content sections. The boundary is specified in the Content-Type header, so that the client knows how to split the sections. For files, the original name, type, size, etc. are passed as metadata. Here's a simple example of what this might look like.

<code>
POST / HTTP/1.1
Host: localhost:9000
Content-Type: multipart/form-data; boundary=---------------------------84000087610663814162942123332

-----------------------------84000087610663814162942123332
Content-Disposition: form-data; name="name"

test
-----------------------------84000087610663814162942123332
Content-Disposition: form-data; name="file"; filename="test.txt"
Content-Type: text/plain

test
-----------------------------84000087610663814162942123332--
</code>

It's important to understand that sections for files might be very big (i.e. too big to hold in memory at once), as they may contain arbitrarily large files.

RFC1867 requests are automatically parsed when the request has the POST HTTP verb. Each non-file input is populated to the $_POST superglobal. For files, the content is stored in a temporary file and an entry is created in $_FILES to store the metadata, along with a path to the temporary file. At the end of the request, any uploaded files that were not moved by the application get cleaned up. This avoids attacks that attempt to fill the servers disk space.

===== Vote =====

Voting starts 2023-xx-xx and ends 2023-xx-xx.

As this is a language change, a 2/3 majority is required.

<doodle title="Introduce populate_post_data() in PHP 8.x?" auth="ilutov" voteType="single" closed="true">
   * Yes
   * No
</doodle>
