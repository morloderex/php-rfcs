====== PHP RFC: RFC1867 for non-POST HTTP verbs ======

  * Date: 2023-10-04
  * Author: Ilija Tovilo, tovilo.ilija@gmail.com
  * Status: Draft
  * Target Version: PHP 8.x
  * Implementation: https://github.com/php/php-src/pull/11472

===== Proposal =====

RFC1867 defines the multipart/form-data content type. This content type is used primarily for submitting HTTP forms that contain files. PHP supports the parsing of this content type natively, but only for POST requests. Specifically, if a request has the method POST and the content type multipart/form-data the request body is immediately consumed before starting the PHP script and populated into the $_POST and $_FILES superglobals. This functionally triggers automatically and is not exposed to userland directly.

With the emergence of REST services it has become increasingly popular to use other HTTP verbs such as PUT and PATCH where the usage of multipart/form-data is entirely valid but not supported. This requires manual parsing of the request body which is non-trivial. Handling large amounts of data in PHP may also be suboptimal in terms of performance.

This RFC suggests adding a new function ''populate_post_data()'' to expose the existing functionality to userland so that it may be used for other HTTP verbs.

<code php>
// This is a PUT request
var_dump($_POST);  // []
var_dump($_FILES); // []

populate_post_data();

var_dump($_POST);  // [...]
var_dump($_FILES); // [...]
</code>

==== RFC1867 ====

RFC1867 defines the multipart/form-data content type. This content type is used primarily for submitting HTTP forms that contain files. It is similar to application/x-www-form-urlencoded in that it contains a list of key-value pairs for each form input. Each input may contain metadata, as well as the content of the input. Each of the inputs is separated with a boundary which is an arbitrary string sequence not used in any of the input content sections. The boundary is specified in the Content-Type header, so that the client knows how to split the sections. For files, the original name, type, size, etc. are passed as metadata. Here's a simple example of what this might look like.

<code>
POST / HTTP/1.1
Host: localhost:9000
Content-Type: multipart/form-data; boundary=---------------------------84000087610663814162942123332

-----------------------------84000087610663814162942123332
Content-Disposition: form-data; name="name"

test
-----------------------------84000087610663814162942123332
Content-Disposition: form-data; name="file"; filename="test.txt"
Content-Type: text/plain

test
-----------------------------84000087610663814162942123332--
</code>

It's important to understand that sections for files might be very big, as they may contain arbitrarily large files.

==== Implementation in PHP ====

RFC1867 requests are automatically parsed when the request has the POST HTTP verb. Each non-file input is populated to the $_POST superglobal. For files, the content is stored in a temporary file and an entry is created in $_FILES to store the metadata, along with a path to the temporary file. At the end of the request, any uploaded files that were not moved by the application get cleaned up. This avoids attacks that attempt to fill the servers disk space.

===== Rationale =====

==== Why not accept a string? ====

As mentioned, the body of RFC1867 requests can be very large, too large to hold in memory at once. Thus, passing the body to the function is not practically possible. It would be possible to pass an input stream to the function. However, it's unclear whether ''populate_post_data()'' has a practical application outside outside of parsing the singular request body. One might be tools like RoadRunner, TBD.

==== Why reuse $_POST instead of creating $_PUT/$_PATCH/etc.? ====

TBD

===== Vote =====

Voting starts 2023-xx-xx and ends 2023-xx-xx.

As this is a language change, a 2/3 majority is required.

<doodle title="Introduce populate_post_data() in PHP 8.x?" auth="ilutov" voteType="single" closed="true">
   * Yes
   * No
</doodle>
