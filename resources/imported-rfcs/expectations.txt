
====== PHP RFC: Expectations ======

  * Version: 0.1
  * Date: 2013-10-18 
  * Author: Joe Watkins, krakjoe@php.net
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/expectations

===== Introduction =====

This functionality was meant to replace the assert() API that currently exists in PHP, because of problems replacing it in a compatible manner, we have renamed the implementation **expect**.

The **expectation** statement has two forms:

<code>
T_EXPECT expression ';'
</code>

<code>
T_EXPECT expression ':' message ';'
</code>

At execution time, **expression** will be evaluated, if the result is false, an **ExpectationException** will be thrown. Where **message** is provided, **ExpectationException::getMessage** will return **message**, otherwise the **expectation** statement will be used.

In some cases, **expression** will be an expensive evaluation that you do not wish to execute in a production environment, **expectations** can therefore be disabled and enabled via the **PHP_INI_PERDIR** configuration setting **zend.expectations**. Disabling Expectations will almost entirely eliminate the performance penalty making them equivalent to an empty statement.

In any case, **expectations** should never be used to perform tasks **required** for the code to function, nor should they change the internal state of any object //except where that state is used by other expectations//, these are not rules that are enforced by Zend, but are nonetheless the best rules to follow.

//**message** can be any valid expression//
===== Scope of Expectations =====

PHP programmers tend to document how their code is supposed to work in comments, this is a fine approach for generating automated documentation, but leaves us a little bewildered, and tired of digging through documentation at runtime when things go wrong:

<code php>
    if ($i % 3 == 0) {
        ...
    } else if ($i % 3 == 1) {
        ...
    } else { // We know ($i % 3 == 2)
        ...
    }
</code>

Becomes:

<code php>
    if ($i % 3 == 0) {
        ...
    } else if ($i % 3 == 1) {
        ...
    } else {
        expect ($i % 3 == 2);
    }
</code>

In a development environment, this forces the executor to make you aware of your mistake.

Another good example for using **Expectations** might be a switch block with no default case:

<code php>
switch ($suit) {
    case CLUBS:
        /* ... */
    break;
    
    case DIAMONDS:
        /* ... */
    break;
    
    case HEARTS:
        /* ... */
    break;
    
    case SPADES:
        /* ... */
    break;
}
</code>

The above switch assumes that **suit** can only be one of four values, to test this assumption add the default case:

<code php>
switch ($suit) {
    case CLUBS:
        /* ... */
    break;
    
    case DIAMONDS:
        /* ... */
    break;
    
    case HEARTS:
        /* ... */
    break;
    
    case SPADES:
        /* ... */
    break;
    
    default:
        expect false : "Unrecognized suit passed through switch: {$suit}";
}
</code>

The previous example highlights another general area where you should use expectations: **place an expectation at any location you assume will not be reached**. The statement to use is:

<code php>
expect false;
</code>

Suppose you have a method that looks like:

<code php>
public function method() {
    for (/*...*/) {
    
        if (/* ... */)
           return true;
    }
    
}
</code>

The above code assumes that one of the iterations results in a return value being passed back to the caller of **::method()**, to test this assumption:

<code php>
public function method() {
    for (/*...*/) {
    
        if (/* ... */)
           return true;
    }
    expect false;
}
</code>

**Expectations** allow the possibility to perform //precondition// and //postcondition// checks:

<code php>
public function setResponseCode($code) {
    $this->code = $code;
}
</code>

Becomes:

<code php>
public function setResponseCode($code) {
    expect $code < 550 && $code > 100;
    
    $this->code = $code;
}
</code>

The example above performs a //precondition// check on the **code** parameter.

The same kind of logic can be applied to internal object state:

<code php>
public function getResponseCode($code) {
    expect $this->code : "The response code is not yet set";
    
    return $this->code;
}
</code>

//postcondition// checks might also be carried out with expect:

<code php>
public function getHeader() {
    $header = $this->headers[++$this->next];
    
    expect $header : "empty header found in headers array";
    expect $header["key"] && $header["value"] : "invalid header found in headers array";
    
    return $header;
}
</code>

===== Managing Expectations =====

When an **expectation** fails, an **ExpectationException** is thrown, these can be caught in the normal way, and come with a stack trace and a useful message about the **expectation**. An **ExpectationException** extends **ErrorException** and has a **severity** of **E_ERROR**.

Here is an example of managing execution of an object whose methods use the **expectations** API:

<code php>
<?php
$headers = [];

try {
   while (($header = $request->getHeader())) {
       /* ... */
       $headers[] = $header;
   }  
} catch (ExpectationException $ex) {
   printf("Failed getting headers from Request: %s\n", $ex->getMessage());
   /* ... output stack trace in some pretty way perhaps ... */
}

/* we will continue if there are headers, regardless of previous exceptions */
if (count($headers)) {
    /* ... */
}
?>
</code>

Sometimes, even where expectations fail, the program wants to continue executing, even in an unstable state, the ability to catch **ExpectationExceptions** allows the program to do that.
===== Performance =====

Here's a quick comparison script:

<code php>
<?php
/* LEGACY */
$start = microtime(true);
for($i=0; $i<1000000; $i++) {
    assert("true");
}
printf("Legacy: %.3f seconds\n", microtime(true)-$start);

/* EXPECT */
$start = microtime(true);
for($i=0; $i<1000000; $i++) {
    expect true;
}
printf("Expect: %.3f seconds\n", microtime(true)-$start);
?>
</code>

Output:

<code>
[joe@fiji php-src]$ sapi/cli/php test.php
Legacy: 1.305 seconds
Expect: 0.051 seconds
[joe@fiji php-src]$ sapi/cli/php -dzend.expectations=0 -dassert.active=0 test.php
Legacy: 0.078 seconds
Expect: 0.026 seconds
[joe@fiji php-src]$ 
</code>

Needless to say **expectations** out perform **assertions** by a very wide margin, under all circumstances.

For those of us that use PHP to do all our math:

<code>
[joe@fiji php-src]$ php -r "echo ceil(1.305/0.051);"
26
</code>

And the performance of that loop on it's own:

<code php>
<?php
/* NOTHING */
$start = microtime(true);
for($i=0; $i<1000000; $i++) {
    
}
printf("Nothing: %.3f seconds\n", microtime(true)-$start);
?>
</code>

Output:

<code>
[joe@fiji php-src]sapi/cli/php test.php
Nothing: 0.024 seconds
</code>

//Tests run on a debug build of PHP yield similar, more exaggerated, results.//

**Noteworthy**: while opcache is loaded and optimization enabled, you can expect absolutely no impact from disabled **expectations** in production, it optimizes away the impact completely.

Some timings with opcache loaded:

<code php>
[joe@fiji php-src]$ sapi/cli/php -c /opt/php-nts/lib -dextension_dir=/opt/php-nts/lib/php/extensions/no-debug-non-zts-20121212/ -dzend_extension=opcache.so -dopcache.enable_cli=1 test.php
Legacy: 1.334 seconds
Expect: 0.026 seconds
[joe@fiji php-src]$ sapi/cli/php -c /opt/php-nts/lib -dextension_dir=/opt/php-nts/lib/php/extensions/no-debug-non-zts-20121212/ -dzend_extension=opcache.so -dopcache.enable_cli=1 -dassert.active=0 -dzend.expectations=0 test.php
Legacy: 0.077 seconds
Expect: 0.016 seconds
[joe@fiji php-src]$ sapi/cli/php -c /opt/php-nts/lib -dextension_dir=/opt/php-nts/lib/php/extensions/no-debug-non-zts-20121212/ -dzend_extension=opcache.so -dopcache.enable_cli=1 test.php
Nothing: 0.016 seconds
</code>

The important math:

<code>
[joe@fiji php-src]$ php -r "echo ceil(1.334/0.026);"
52
</code>

===== Backward Incompatible Changes =====

Nothing internal is affected.

**expect** is a new keyword, and may cause clashes in code where the same name is used for user methods/functions.

===== Proposed PHP Version(s) =====

Undecided

===== Impact to Existing Extensions =====

None that are obvious, this does introduce a new opcode so anything working with opcodes may need adjustment.

===== php.ini Defaults =====

**System** configuration setting:
  * zend.expectations=1

**zend.expectations** is a compile time //only// setting.

Expectations should be enabled (**zend.expectations=1**) on development machines, and disabled (**zend.expectations=0**) in production.
===== Unaffected PHP Functionality =====

The current assertion API is completely unaffected by this addition.

===== Proposed Voting Choices =====

Simple

===== Patches and Tests =====

https://github.com/krakjoe/php-src/compare/expect

This is a working implementation of Expectations as documented here.

===== References =====

Link to the original internals thread that discussed the proposal to replace assert with new functionality:

http://php.markmail.org/search/?q=net.php.lists.internals+order%3Adate-backward+assertions#query:net.php.lists.internals%20order%3Adate-backward%20assertions+page:1+mid:nxbxke2z5oykztys+state:results

Link to the internals thread discussing this particular RFC:

http://php.markmail.org/search/?q=net.php.lists.internals+expectations+order%3Arelevance#query:net.php.lists.internals%20expectations%20order%3Arelevance+page:1+mid:krr72ib3jwghrc4a+state:results
===== Rejected Features =====

N/A