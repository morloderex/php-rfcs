====== PHP RFC: Enumeration type (alternative proposal) ======
  * Version: 0.9
  * Date: 2020-05-14
  * Author: Max Semenik, maxsem.wiki@gmail.com
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/enum_v2

===== Introduction =====
Traditionally, PHP has used independent constants to represent related magic numbers. I propose to add a concept well known from many other languages, enumeration type.

Consider the following perfectly valid code:
<code php>
preg_split($foo, $bar, LC_ALL * PHP_MAJOR_VERSION);
</code>

What will this call produce? I have no idea, either:)

It would be so much better to have a more foolproof and type-safe version, like:
<code php>
preg_split($foo, $bar, Split::NoEmpty);
</code>

===== Proposal =====

=== Basics ===
A simple enum:
<code php>
enum Letters {
    a,          // Enum constants start with 0 by default
    b,          // 1, always previous value +1 if not specified explicitly
    c = 10,     // Values can be set explicitly
    d,          // 11
    e = 1,      // Constants with duplicate values are allowed
    f = 2 * 2,  // Can use the same expressions as class constants
    g = f,      // Can use other constants too
    h = g + 10, // And in expressions too
    H,          // Valid, constant names are case sensitive
    i,          // Optional comma after the last constant is permitted
}
</code>

A binary enum is used to represent a set of values:
<code php>
binary enum FileMode {
    Read = 1,
    Write = 2,
    Execute = 1 << 2,
    ReadWrite = Read | Write,
}

$foo = FileMode::Read | FileMode::Execute;
</code>

Both enum types can extend other enums:
<code php>
enum A { foo = 1 }

enum B extends A { bar = 2 }

$x = B::foo;
</code>

Overriding constants from base enums is not allowed:
<code php>
enum C extends A {
    foo = 3 // CompileError
}
</code>

Constants must be ''int'' and thus fit into ''zend_long'':
<code php>
enum foo {
    bar = 2 ** 100, // CompileError
    baz = 1.5       // CompileError
}
</code>

=== Type coercion and casts ===
Enums are implicitly coercible to bool and string:
<code php>
function f(FileMode $mode) {
    if ($mode) {
        echo "mode: $mode";
    }
}

f(FileMode::Read); // Outputs "mode: 1"
</code>

=== Enum operations ===
Enums are immutable and don't support arithmetic operations:
<code php>
$foo = FileMode::Read;
$foo = FileMode::Read + 1; // CompileError
$foo += 1;                 // TypeError
$bar = $foo + 1;           // TypeError
</code>

However, binary enums support bitwise operations:
<code php>
$foo = FileMode::Read | FileMode::Execute;
$foo |= FileMode::Write;
$foo &= ~FileMode::Read;
</code>

=== Enum usage ===
Concrete enum types can be used as typehints:
<code php>
function open(string $filename, FileMode $mode)
</code>
However, not the enum keyword itself:
<code php>
function open(string $filename, enum $mode) // CompileError
</code>

When the type is clear from typehints, enum name can be omitted:
<code php>
open('foo.txt', Read | Write)
</code>
is equivalent to:
<code php>
open('foo.txt', FileMode::Read | FileMode::Write)
</code>

Same for ''switch'' statements:
<code php>
function f(Letters $x) {
    switch ($x) {
    case a:
        // ...
    case b:
        // ...
    }
}
</code>

=== Internal representation ===
Internally, enums are classes and enum constants are public class constants. This makes them the fourth OOP-ey type in PHP, along with ''class'', ''interface'' and ''trait''. They can be autoloaded just like the former types. All enums inherit from this base class (here is PHP pseudocode):
<code php>
final // In the sense that userspace can't explicitly extend it
class Enum {
    private int $value;
    private function __construct(); // It shouldn't be possible to create enums like this: $foo = new Enum();
    public function isBinary(): bool;
    public function __toString(): string {
        return (string)(int)$this->value;
    }
    
    // Whether the current value is represented by one of this enum's constants
    // or their combination for binary enums
    public function isKnownValue(): bool;
    
    // Returns a human readable representation of this enum's value
    // e.g. (FileMode::Read | FileMode::Write)->toHumanReadableString() would return 'Read | Write'
    public function toHumanReadableString(): string;
}
</code>


===== Backwards Incompatible Changes =====
''enum'' and ''binary'' will become reserved keywords. Class name 'Enum' (or whatever we decide to call it) will become unavailable.

===== Proposed PHP Version(s) =====
PHP 8.1?

===== Open Issues =====
Make sure there are no open issues when the vote starts!

===== Unaffected PHP Functionality =====
List existing areas/features of PHP that will not be changed by the RFC.

This helps avoid any ambiguity, shows that you have thought deeply about the RFC's impact, and helps reduces mail list noise.

===== Future Scope =====
This section details areas where the feature might be improved in future, but that are not currently proposed in this RFC.

===== Proposed Voting Choices =====
* Accept this RFC (yes / no)?
* What should be Enum fully qualified name (\Enum / \PHP\Enum)?
* What enum constant naming convention should be used (PascalCase / camelCase / UPPER_UNDERSCORED)?

===== Patches and Tests =====
Links to any external patches and tests go here.

If there is no patch, make it clear who will create a patch, or whether a volunteer to help with implementation is needed.

Make it clear if the patch is intended to be the final patch, or is just a prototype.

For changes affecting the core language, you should also provide a patch for the language specification.

===== Implementation =====
After the project is implemented, this section should contain 
  - the version(s) it was merged into
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature
  - a link to the language specification section (if any)

===== References =====
Links to external references, discussions or RFCs
* https://wiki.php.net/rfc/enum

===== Rejected Features =====
Keep this updated with features that were discussed on the mail lists.