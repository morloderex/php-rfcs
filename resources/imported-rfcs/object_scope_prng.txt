====== PHP RFC: Object scoped PRNG Implementations. ======
  * Version: 0.4
  * Date: 2020-12-20
  * Author: Go Kudo <zeriyoshi@gmail.com>
  * Status: Draft
  * Implementation: WIP
  * First Published at: https://wiki.php.net/rfc/object_scope_prng

===== Introduction =====

PHP currently provides the mt_srand() and mt_rand() functions based on the Meresenne Twister as PRNGs.
However, since these functions keep their state in global space, unintended function calls may cause inconsistency even for the same seed value.

<code php>
mt_srand(1234);
foo();
mt_rand() === 411284887; // false

function foo() {
    mt_rand(); // code added
}
</code>

This is inappropriate for applications that require consistency in the generated values (game logic, test code, etc.).
These global states also affect the forked child processes. In fact, the EasySwoole Swoole extension based framework has been alerted to this behavior. [5]

In other languages, RNGs are implemented as objects, so this problem doesn't exists. [3] [4]

The global state of MT is also used by other functions that use random numbers, and this problem is further exacerbated when the consistency of the results is required by seeding with specific values. (Of course, you are right that such usage is a bad example.)

<code php>
mt_srand(1234);
$arr = [1, 2, 3, 4, 5];
shuffle($arr);
echo print_r($arr, true); // This result is always consistent.

/*
Array
(
    [0] => 3
    [1] => 2
    [2] => 5
    [3] => 4
    [4] => 1
)
*/
</code>

Therefore, it may be a good idea to consider deprecating global state-dependent RNG functions in the future.

One currently possible userland solution is to implement the PRNG in pure PHP. There is actually a userland library [1], but it is not fast enough for PHP at the moment, including with JIT (Benchmark results are available at Open Issues.)

This implementation will also allow us to support the PHP paradigm, which will become even more complex in the future.

I have created an extension for PHP to improve these [2]. This could be used to consider what specific goals this RFC is trying to achieve.

===== Proposal =====

Implements an object-scoped PRNG in PHP, providing methods equivalent to functions that use RNG results.

Two methods have been proposed in the discussion.

=== Type A ===

First, it provides the following interface. Namespaces is a stub. These will be shown in the voting options.

Users can implement this interface through extensions or PHP code.

<code php>
namesapce PHP\PRNG;

interface RNGInterface
{
    public function __construct(int $seed);
    public function nextInt(?int $min = null, ?int $max = null): int;
    public function nextDouble(): double; // maybe non-needed.
    public function nextByte(int $length): string;
}
</code>

Next, Create an interface with methods to replace PHP's internal MT state-dependent functions. This will inherit from the previous interface.
Behavior of these functions is not consistent and may need to be revised. but it also has the advantage that simple substitution is possible.

<code php>
namespace PHP\PRNG;

interface RandomInterface extends RNGInterface
{
    public function shuffle(array &array): bool; // replacement of shuffle()
    public function stringShuffle(string $string): string; // replacement of str_shuffle()
    public function arrayRandom(array $array): int|string|array; // replacement of array_rand()
}
</code>

The next step is to implement PRNGs that implement the interface. These may be serializable, Being serializable helps to preserve the state.

<code php>
namespace PHP\PRNG;

class XorShift128Plus implements RandomInterface
{
    public function __construct(int $seed) {}
    public function nextInt(?int $min = null, ?int $max = null): int;
    public function nextDouble(): double; // maybe non-needed.
    public function nextByte(int $length): string;
    public function shuffle(array &$array): bool {}
    public function stringShuffle(string $string): string {}
    public function arrayRandom(array $array, int $num = 1): int|string|array {}
    public function __serialize(): string {}
    public function __unserialize(string $serialized): static {}
}

class MT19937 implements RandomGenerator
{
    public function __construct(int $seed) {}
    public function nextInt(?int $min = null, ?int $max = null): int;
    public function nextDouble(): double; // maybe non-needed.
    public function nextByte(int $length): string;
    public function shuffle(array &$array): bool {}
    public function stringShuffle(string $string): string {}
    public function arrayRandom(array $array, int $num = 1): int|string|array {}
    public function __serialize(): string {}
    public function __unserialize(string $serialized): static {}
}
</code>

=== Type B ===
First, we define a RNG interface that inherits from Iterator.

<code php>
interface RNG extends Iterator {}
</code>

Next, we define the PRNG interfaces that inherit from the RNG. Each PRNG implements this interface.

<code php>
interface PRNG extends RNG
{
    public function __construct(int $seed);
    public function getSeed(): int;
}
</code>

Finally, we will create a class that provides utility methods to use these results.
<code php>
class RNGUtil
{
    public static function shuffleArray(int $randomNumber, array $arr): array;
    public static function randomArrayElement(int $randomNumber, array $arr): mixed;
    public static function between(int $randomNumber, int $min = PHP_INT_MIN, int $max = PHP_INT_MAX): int;
    public static function bytes(RNG $rng, int $length): string;
}
</code>

This method is more complex, but more OOP-like.
However, it is important to note that PHP is also a language that values simplicity.

===== Backward Incompatible Changes =====

With the provides of new classes, some class names (or namespaces) will no longer be available in userland.

===== Proposed PHP Version(s) =====

8.1

===== RFC Impact =====
==== To SAPIs ====
none

==== To Existing Extensions ====
orng [[https://pecl.php.net/package/orng]] : it is a PECL extension that provides almost the same functionality. If the interface is provided by the core in the future, it will need to be supported. And that's me.

==== To Opcache ====
none

==== New Constants ====
none

==== php.ini Defaults ====
none

===== Open Issues =====
=== Why implement a method that is almost identical to a traditional function? ===
It is intended to improve interoperability with conventional code. Users can modify the implementation to be safe against state by simply replacing the existing code.

=== With JIT, won't the userland implementation reach a useful speed? ===
Comparing the speed of the userland implementation of XorShift128+ and the orng extension.

**PHP 8.0**
<code shell>
$ time php -r 'require __DIR__ . "/vendor/savvot/random/src/AbstractRand.php"; require __DIR__ . "/vendor/savvot/random/src/XorShiftRand.php"; $r = new Savvot\Random\XorShiftRand(1234); for ($i = 0; $i < 1000000; $i++) { $r->random(); }'

real	0m0.441s
user	0m0.429s
sys	0m0.010s
</code>

**PHP 8.0 + OPcache JIT**
<code shell>
$ time php -dopcache.jit_buffer_size=100M -dopcache.enable_cli=1 -r 'require __DIR__ . "/vendor/savvot/random/src/AbstractRand.php"; require __DIR__ . "/vendor/savvot/random/src/XorShiftRand.php"; $r = new Savvot\Random\XorShiftRand(1234); for ($i = 0; $i < 1000000; $i++) { $r->random(); }'

real	0m0.155s
user	0m0.139s
sys	0m0.015s
</code>

**PHP 8.0 + orng**
<code shell>
$ time php -r '$r = new \ORNG\XorShift128Plus(1234); for ($i = 0; $i < 1000000; $i++) { $r->next(); }'

real	0m0.056s
user	0m0.048s
sys	0m0.008s
</code>

This provides a significant improvement, but still slow from the C implementation.

=== Why do we need this feature in the core and not in the extension? ===
In order to use the features related to pseudo-random numbers that PHP currently provides, an understanding of the core is required. If this proposal is implemented, users will be able to use pseudo-random numbers under the easy to understand concept of objects. This is a useful improvement to the overall functionality of the language.

===== Unaffected PHP Functionality =====
It does not affect any related existing functions.
  * mt_srand()
  * mt_rand()
  * shuffle()
  * str_shuffle()
  * array_rand()

===== Proposed Voting Choices =====
Yes/No, requiring 2/3 majority

There are a few additional options for implementation.

<doodle title="Which implementation looks good?" auth="user" voteType="single" cloesd="true">
  * Type A
  * Type B
</doodle>

<doodle title="In which module will you implement these?" auth="user" voteType="single" closed="true">
   * ext/standard
   * ext/prng (new module)
</doodle>

<doodle title="To which namespace should these classes and interfaces belong?" auth="user" voteType="single" closed="true">
   * Top Level (\Randomizer)
   * "PRNG" namespace (\PRNG\Randomizer)
   * "PHP\PRNG" namespace (\PHP\PRNG\Randomizer)
</doodle>

<doodle title="Which set of PRNGs should be provided as standard?" auth="user" voteType="single" closed="true">
   * MT19937 (64bit) / XorShift128+
   * MT19937 (64bit)
   * XorShift128+
</doodle>

===== Patches and Tests =====
WIP (A rough overview is given in the orng extension [2])

===== References =====
  * [1] https://github.com/savvot/random
  * [2] https://github.com/zeriyoshi/php-ext-orng
  * [3] https://docs.microsoft.com/en-us/dotnet/api/system.random
  * [4] https://docs.oracle.com/javase/8/docs/api/java/util/Random.html
  * [5] https://www.easyswoole.com/En/Other/random.html