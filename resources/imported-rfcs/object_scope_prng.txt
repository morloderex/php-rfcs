====== PHP RFC: Object scoped RNG Implementations. ======
  * Version: 1.3
  * Date: 2021-01-25
  * Author: Go Kudo <zeriyoshi@gmail.com>
  * Status: Under Discussion
  * Implementation: https://github.com/php/php-src/pull/6568
  * First Published at: https://wiki.php.net/rfc/object_scope_prng

===== Introduction =====

PHP currently provides the mt_srand() and mt_rand() functions based on the Meresenne Twister as PRNGs.
However, since these functions keep their state in global space, unintended function calls may cause inconsistency even for the same seed value.

<code php>
mt_srand(1234);
foo();
mt_rand() === 411284887; // false

function foo() {
    mt_rand(); // code added
}
</code>

This is inappropriate for applications that require consistency in the generated values (game logic, test code, etc.).
These global states also affect the forked child processes. In fact, the EasySwoole Swoole extension based framework has been alerted to this behavior. [5]

In other languages, RNGs are implemented as objects, so this problem doesn't exists. [3] [4]

The global state of MT is also used by other functions that use random numbers, and this problem is further exacerbated when the consistency of the results is required by seeding with specific values. (Of course, you are right that such usage is a bad example.)

<code php>
mt_srand(1234);
$arr = [1, 2, 3, 4, 5];
shuffle($arr);
echo print_r($arr, true); // Result is always consistent.

/*
Array
(
    [0] => 3
    [1] => 2
    [2] => 5
    [3] => 4
    [4] => 1
)
*/
</code>

Therefore, it may be a good idea to consider deprecating global state-dependent RNG functions in the future.

One currently possible userland solution is to implement the PRNG in pure PHP. There is actually a userland library [1], but it is not fast enough for PHP at the moment, including with JIT (Benchmark results are available at Open Issues.)

This implementation will also allow us to support the PHP paradigm, which will become even more complex in the future.

I have created an extension for PHP to improve these [2]. This could be used to consider what specific goals this RFC is trying to achieve.

===== Proposal =====

Implements an object-scoped PRNG in PHP.

When this proposal is introduced, the code can be written as follows:

<code php>
$seed = 1234;
$rng = new \RNG\MT19937($seed);
$array = [1, 2, 3, 4, 5];

mt_srand(4321); mt_rand(); // Does not affect to $rng.

shuffle($array, $rng); // Result is always consistent.

// Allow user-implemented RNG

class FixedNumberGenerator implements RNGInterface
{
    protected int $count = 0;
    
    public function next(): int
    {
        return $this->count++;
    }
}

echo str_shuffle('Hello', new FixedNumberGenerator()); // Result: olleH
</code>

The following are the implementation details.
First, it provides the following interface.

The next64() method is used to generate int values beyond 32 bits in a 64-bit environment. This definition is also required in a 32-bit environment.

<code php>
namespace RNG;

interface RNGInterface
{
    public function next(): int;
    public function next64(): int;
}
</code>

Next, make some changes to the existing functions and add some new ones.

<code php>
function shuffle(array &$array, ?RNG\RNGInterface $rng = null): bool {}
function str_shuffle(string $string, ?RNG\RNGInterface $rng = null): string {}
function array_rand(array $array, int $num = 1, ?RNG\RNGInterface $rng = null): int|string|array {}
/** Generates a sequence of bytes for a specified range using RNG. */
function rng_bytes(RNG\RNGInterface $rng, int $length): string {}
/** Generates a random number in range, likes random_int() */
function rng_int(RNG\RNGInterface $rng, int $min, int $max): int [}
/** Generates 32bit raw random number using RNG */
function rng_next(RNG\RNGInterface $rng, bool $unsigned = true): int{}
/**
  * Generates 64bit raw random number using RNG
  * 
  * @throws \ValueError Throws on 32bit environment.
  */
function rng_next64(RNG\RNGInterface $rng, bool $unsigned = true): int{}
</code>

Existing RNG-specifying functions will now be able to explicitly specify the source of the RNG. This makes it clear that these functions are using the RNG internally.

Finally, we provide an RNG class that implements these interfaces.
At this time, considering support for XorShift128+ , MT19937 and OS.

<code php>
namespace RNG;

class XorShift128Plus implements RNGInterface {} // use XorShift128+ algorithm
class MT19937 implements RNGInterface {} // use MT19937 algorithm
class OSã€€implements RNGInterface {} // use php_random_bytes() internal API (OS provided)
</code>

Basically, these classes are supposed to be used as arguments to one of the functions. In other words, the next() and next64() methods are not intended to be called directly.

This is for proper handling of next64() in a 32-bit environment and to improve interoperability with the mt_rand() function. The mt_rand() function performs a bit shift on the result and always returns an unsigned integer.

<code php>

// If the second argument is true (default), rng_next() performs bit shifting like mt_rand() and always returns an unsigned integer.
mt_srand(1234);
$mt_state = new \RNG\MT19937(1234);
mt_rand() === rng_next($mt_state); // true

// If false, it will return the value as is. This is exactly the same result as $rng->next().
mt_rand() === rng_next($mt_state, false); // false

// This is useful if you want to use the numbers generated by the RNG directly.
rng_next(new \RNG\MT19937(1234), false) === 822569775; // true
</code>

Some RNG implementations (currently XorShift128+ and MT19937) can serialize state using the standard PHP serialization methods (serialize() and unserialize() function). This is useful for the purpose of storing state.

<code php>
$rng = new RNG\XorShift128Plus(1234);

rng_next($rng);

$serialized_string = serialize($rng);

$rng2 = unserialize($serialized_string);

rng_next($rng) === rng_next($rng2); // true
</code>

===== Backward Incompatible Changes =====

With the provides of new classes, some class names (or namespaces) will no longer be available in userland.

Some of the functions that use RNGs will have additional optional $rng arguments.

  * shuffle()
  * str_shuffle()
  * array_rand()

===== Proposed PHP Version(s) =====

8.1

===== RFC Impact =====
==== To SAPIs ====
none

==== To Existing Extensions ====
orng [[https://pecl.php.net/package/orng]] : it is a PECL extension that provides almost the same functionality. If the interface is provided by the core in the future, it will need to be supported. And that's me.

==== To Opcache ====
none

==== New Constants ====
none

==== php.ini Defaults ====
none

===== Open Issues =====

=== With JIT, won't the userland implementation reach a useful speed? ===
Comparing the speed of the userland implementation of XorShift128+ and the orng extension.

**PHP 8.0**
<code shell>
$ time php -r 'require __DIR__ . "/vendor/savvot/random/src/AbstractRand.php"; require __DIR__ . "/vendor/savvot/random/src/XorShiftRand.php"; $r = new Savvot\Random\XorShiftRand(1234); for ($i = 0; $i < 1000000; $i++) { $r->random(); }'

real	0m0.441s
user	0m0.429s
sys	0m0.010s
</code>

**PHP 8.0 + OPcache JIT**
<code shell>
$ time php -dopcache.jit_buffer_size=100M -dopcache.enable_cli=1 -r 'require __DIR__ . "/vendor/savvot/random/src/AbstractRand.php"; require __DIR__ . "/vendor/savvot/random/src/XorShiftRand.php"; $r = new Savvot\Random\XorShiftRand(1234); for ($i = 0; $i < 1000000; $i++) { $r->random(); }'

real	0m0.155s
user	0m0.139s
sys	0m0.015s
</code>

**PHP 8.0 + orng**
<code shell>
$ time php -r '$r = new \ORNG\XorShift128Plus(1234); for ($i = 0; $i < 1000000; $i++) { $r->next(); }'

real	0m0.056s
user	0m0.048s
sys	0m0.008s
</code>

This provides a significant improvement, but still slow from the C implementation.

=== Why do we need this feature in the core and not in the extension? ===
In order to use the features related to pseudo-random numbers that PHP currently provides, an understanding of the core is required. If this proposal is implemented, users will be able to use pseudo-random numbers under the easy to understand concept of objects. This is a useful improvement to the overall functionality of the language.

===== Unaffected PHP Functionality =====
It does not affect any related existing functions. (However, in the case of Type II, non-destructive arguments will be added.)
  * mt_srand()
  * mt_rand()

===== Proposed Voting Choices =====
Yes/No, requiring 2/3 majority

There are a few additional options for implementation.

<doodle title="Add object-scoped RNG" auth="user" voteType="single" closed="true">
   * Yes
   * No
</doodle>

<doodle title="To which namespace should these classes and interfaces belong?" auth="user" voteType="single" closed="true">
   * Top Level (\RNGInterface)
   * "RNG" namespace (\RNG\RNGInterface)
   * "PHP\RNG" namespace (\PHP\RNG\RNGInterface)
</doodle>

===== Patches and Tests =====
  * https://github.com/php/php-src/pull/6568

===== References =====
  * [1] https://github.com/savvot/random
  * [2] https://github.com/zeriyoshi/php-ext-orng
  * [3] https://docs.microsoft.com/en-us/dotnet/api/system.random
  * [4] https://docs.oracle.com/javase/8/docs/api/java/util/Random.html
  * [5] https://www.easyswoole.com/En/Other/random.html