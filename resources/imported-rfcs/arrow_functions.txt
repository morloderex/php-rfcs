====== PHP RFC: Arrow Functions ======
  * Version: 1.1
  * Date: 2016-08-14
  * Author: Levi Morrison <levim@php.net>
  * Author: Bob Weinand <bwoebi@php.net>
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/arrow_functions

===== Introduction =====
Anonymous functions and closures can be verbose even though sometimes they are quite simple and contain only a single expression. The declaration overhead makes it a pain to use them. Other languages have a few different ways to write closures in a more succinct form. This RFC proposes a shorter syntax for anonymous functions and closures in PHP compared to what we already have.

This RFC is an alternative proposal to Bob Weinand's [[rfc:short_closures|Short Closures]] RFC which contains a lot of relevant information. This RFC will reference the short_closures RFC several times so readers should be familiar with it.

===== Proposal =====
Arrow functions have the basic form of:

<PHP>
^(parameter_list) => expr
</PHP>

The ''expr'' is a single expression. The expression will be evaluated and then the result will be returned:

<PHP>
$mul2 = ^($x) => $x * 2;

$mul2(3); // evaluates to 6
</PHP>

If there is only a single parameter for the arrow function then the parenthesis around the parameter list can be omitted:

<PHP>
$mul2 = ^$x => $x * 2;

$mul2(3); // evaluates to 6
</PHP>

When a variable in the expression is defined in the parent scope it will be captured implicitly. Whether these variables are bound by value or by reference will be determined by vote.
For example:

<PHP>
$y = 1;

$versionA = ^$x => $x + $y;

// Equivalent if capture by-value
$versionB = function($x) use($y) {
    return $x + $y;
};

// Equivalent if capture by-reference
$versionC = function($x) use(&$y) {
    return $x + $y;
};
</PHP>

Note that searching for variables to close over will descend into nested arrow functions:
<PHP>
$y = 1;

// I have no idea why you would do this but it works
$f = ^() => ^() => $y;

var_dump($f()()); // int(1)
</PHP>

It also will look at <php>use</php> sections of inline functions:

<PHP>
$y = 1;

// Again I have no idea why you would do this but it works
$f = ^() => function() use($y) {
    return $y;
};

var_dump($f()()); // int(1)
</PHP>


Arrow functions are similar to those found in EcmaScript 2015 (ES6)((https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)) and lambda expressions from C#((https://msdn.microsoft.com/en-us/library/bb397687.aspx)).

==== Type Declarations ====
This RFC allows for type declarations for both parameters and return types. This feature was missing in Bob's [[rfc:short_closures|short closure]] RFC because of implementation complications. This issue was noted multiple times on the mailing list as something that bothered voters. Arrow functions do not have this issue because the caret (''^'') prefix will prevent the parser issues from happening.

Here is an example of type declarations in an arrow function:

<PHP>$mul2 = ^(int $x): int => $x * 2;</PHP>

The parentheses are always required if type information is present.

Note that the ability to provide type information is included only because of the common complaints about Bob's short closures RFC. This RFC addresses this issue by allowing it but the authors of this document discourage its general use.

==== Why keep the prefix? ====
The short closures proposal dropped the ''function'' prefix because of brevity. This is also done in EcmaScript 2015 (ES6) and C#. However, in PHP we can provide type information on parameters and can also pass variables by reference which together cause an ambiguity. In the definition <php>(Type &$x) => expr</php> the part <php>(Type &$var)</php> can parse as "take constant ''Type'' and variable ''$var'' and do a bitwise and ''&'' operation." After that the ''<nowiki>=></nowiki>'' will be an unexpected token. Even though the rule would be invalid the parser doesn't know that far ahead there will be an error and it doesn't know which rule to pick. This can be resolved by inefficient GLR parsing or a painstaking rewrite of our parsing rules. This author is of the opinion that it is better to avoid the issue than to resolve it in this case. The ''^'' prefix will avoid these issues while maintaining brevity.

The <php>^</php> prefix also prevents ambiguities with the existing usages of the ''T_DOUBLE_ARROW'' token (''<nowiki>=></nowiki>''). Note that if we just used [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions|EcmaScript 2015's arrow function]] syntax there would be two ambiguities:

<PHP>
// Does this mean:
//   1. Create an array key with the result of `($x)` and a value with `$x * 2`
//   2. Create an array with one value that is an anonymous function
[($x) => $x * 2]

// Does this mean:
//   1. Yield a key with the result of `($x)` and a value with `$x * 2`
//   2. Yield an anonymous function
yield ($x) => $x * 2;
</PHP>

This RFC avoids the issue because the <php>^</php> token is prefixed:

<PHP>
// an array with an anonymous function
[^($x) => $x * 2];

// yields an anonymous function
yield ^($x) => $x * 2;
</PHP>

==== Why is the prefix a caret? ====
Originally this RFC used a new token ''fn''. However, adding a new keyword was disliked by a few collaborators. So instead we looked at symbols. There aren't many available; only the symbols that do not have unary variants are available. These are: 

  * asterisk (''*'')
  * caret (''^'')
  * pipe (''|'')
  * forward slash (''/'')
  * backslash (''<nowiki>\</nowiki>'')
  * percent (''%'')
  * greater than (''>'')
  * less than (''<'')

It turns out two of those have precedence in other languagues; Objective-C uses caret and Haskell uses the backslash. The caret was selected because it is used less often in PHP than the backslash currently is. Additionally this RFC author estimates that more people will be familiar with Objective-C than Haskell within our community making the caret symbol more relatable.

==== Backward Incompatible Changes ====
There are no backwards incompatible changes.

==== Patches and Tests ====
An implementation with tests can be found here: https://github.com/morrisonlevi/php-src/tree/arrow_functions. This patch is feature-complete. However, the primary implementation was written a long time ago and the master branch has changed significantly in the meantime. Please report any bugs you encounter.

==== PHP Version ====
This RFC targets PHP 7.NEXT, currently version 7.2.

==== Voting ====
The voting is split into two votes. The first is to accept the idea of arrow functions and requires 2/3 vote. The second is to decide whether ''use''d variables are bound by value or by reference and is a simple majority wins.

-----

<doodle title="Accept arrow functions? (2/3 required)" auth="levijm" voteType="single" closed="true">
   * Yes
   * No
</doodle>

-----

<doodle title="Should used variables be bound by value or by reference? (majority wins)" auth="levijm" voteType="single" closed="true">
   * Value
   * Reference
</doodle>

===== Future Scope =====

==== Multi-Statement Bodies ====
Some languages permit multi-statement closures with a syntax like:

<PHP>(parameter_list) => {
    stmt1;
    stmt2;
    //â€¦
}</PHP>

In this case nothing would be automatically returned. It would be necessary to keep the caret prefix if this was added to PHP.