====== PHP RFC: Arrow Functions ======
  * Version: 1.1
  * Date: 2016-08-14
  * Author: Levi Morrison <levim@php.net>
  * Author: Bob Weinand <bwoebi@php.net>
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/arrow_functions

This RFC is an alternative proposal to Bob Weinand's [[rfc:short_closures|Short Closures]] RFC which contains a lot of relevant information. This RFC will reference the short_closures RFC several times so readers should be familiar with it.

===== Introduction =====
Anonymous functions and closures can be verbose even though sometimes they are quite simple and contain only a single expression. Additionally, importing variables into the closure's scope is manual and is painful overhead for single-expression closures. This RFC proposes a shorter syntax for anonymous functions and closures and makes it easier for these new closures to capture values/variables.

As an example of the declaration overhead, consider this function that [[https://github.com/darkskillfr/near2u/blob/5a606fc9082c33c7270d37e4c7d29160586285f8/serveur/lib.php|I found online]]:

<PHP>function array_values_from_keys($arr, $keys) {
    return array_map(function($x) use ($arr) { return $arr[$x]; }, $keys);
}</PHP>

The closure performs a single operation <php>$arr[$x]</php> and is 8 characters but requires 30 other characters of boilerplate (excluding whitespace). This means that roughly 79% of the closure's code is boilerplate overhead (30/38). This RFC proposes arrow functions to reduce the amount of boilerplate by having a shorter syntax and importing used variables from the outer scope implicitly. Using all possible features proposed by this RFC this would reduce to the following:

<PHP>function array_values_from_keys($arr, $keys) {
    return array_map(^$x => $arr[$x], $keys);
}</PHP>

This reduces the amount of boilerplate from 30 characters down to 5.

See more examples in the [[rfc:arrow_functions#examples|Examples]] section.

Many other languages have ways to write closures in a succinct form as well. TODO: decide how much summary of this topic should be given here. At minimum provide links to closure documentation for a few other relevant and major languages?

===== Proposal =====
Arrow functions have the basic form of:

<PHP>
^(parameter_list) => expr
</PHP>

The ''expr'' is a single expression. The expression will be evaluated and then the result will be returned:

<PHP>
$mul2 = ^($x) => $x * 2;

$mul2(3); // evaluates to 6
</PHP>

If there is only a single parameter for the arrow function then the parenthesis around the parameter list can be omitted:

<PHP>
$mul2 = ^$x => $x * 2;

$mul2(3); // evaluates to 6
</PHP>

When a variable in the expression is defined in the parent scope it will be captured implicitly. Whether these variables are bound by value or by reference will be determined by vote.
For example:

<PHP>
$y = 1;

$versionA = ^$x => $x + $y;

// Equivalent if capture by-value
$versionB = function($x) use($y) {
    return $x + $y;
};

// Equivalent if capture by-reference
$versionC = function($x) use(&$y) {
    return $x + $y;
};
</PHP>

Note that searching for variables to close over will descend into nested arrow functions:
<PHP>
$y = 1;

// I have no idea why you would do this but it works
$f = ^() => ^() => $y;

var_dump($f()()); // int(1)
</PHP>

It also will look at <php>use</php> sections of inline functions:

<PHP>
$y = 1;

// Again I have no idea why you would do this but it works
$f = ^() => function() use($y) {
    return $y;
};

var_dump($f()()); // int(1)
</PHP>


Arrow functions are similar to those found in EcmaScript 2015 (ES6)((https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)) and lambda expressions from C#((https://msdn.microsoft.com/en-us/library/bb397687.aspx)).

==== Type Declarations ====
This RFC allows for type declarations for both parameters and return types. This feature was missing in Bob's [[rfc:short_closures|short closure]] RFC because of implementation complications. This issue was noted multiple times on the mailing list as something that bothered voters. Arrow functions do not have this issue because the caret (''^'') prefix will prevent the parser issues from happening.

Here is an example of type declarations in an arrow function:

<PHP>$mul2 = ^(int $x): int => $x * 2;</PHP>

The parentheses are always required if type information is present.

Note that the ability to provide type information is included only because of the common complaints about Bob's short closures RFC. This RFC addresses this issue by allowing it but the authors of this document discourage its general use.

==== Why keep the prefix? ====
The short closures proposal dropped the ''function'' prefix because of brevity. This is also done in EcmaScript 2015 (ES6) and C#. However, in PHP we can provide type information on parameters and can also pass variables by reference which together cause an ambiguity. In the definition <php>(Type &$x) => expr</php> the part <php>(Type &$var)</php> can parse as "take constant ''Type'' and variable ''$var'' and do a bitwise and ''&'' operation." After that the ''<nowiki>=></nowiki>'' will be an unexpected token. Even though the rule would be invalid the parser doesn't know that far ahead there will be an error and it doesn't know which rule to pick. This can be resolved by inefficient GLR parsing or a painstaking rewrite of our parsing rules. This author is of the opinion that it is better to avoid the issue than to resolve it in this case. The ''^'' prefix will avoid these issues while maintaining brevity.

The <php>^</php> prefix also prevents ambiguities with the existing usages of the ''T_DOUBLE_ARROW'' token (''<nowiki>=></nowiki>''). Note that if we just used [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions|EcmaScript 2015's arrow function]] syntax there would be two ambiguities:

<PHP>
// Does this mean:
//   1. Create an array key with the result of `($x)` and a value with `$x * 2`
//   2. Create an array with one value that is an anonymous function
[($x) => $x * 2]

// Does this mean:
//   1. Yield a key with the result of `($x)` and a value with `$x * 2`
//   2. Yield an anonymous function
yield ($x) => $x * 2;
</PHP>

This RFC avoids the issue because the <php>^</php> token is prefixed:

<PHP>
// an array with an anonymous function
[^($x) => $x * 2];

// yields an anonymous function
yield ^($x) => $x * 2;
</PHP>

==== Why is the prefix a caret? ====
Originally this RFC used a new token ''fn''. However, adding a new keyword was disliked by a few collaborators. So instead we looked at symbols. There aren't many available; only the symbols that do not have unary variants are available. These are: 

  * asterisk (''*'')
  * caret (''^'')
  * pipe (''|'')
  * forward slash (''/'')
  * backslash (''<nowiki>\</nowiki>'')
  * percent (''%'')
  * greater than (''>'')
  * less than (''<'')

It turns out two of those have precedence in other languagues; Objective-C uses caret and Haskell uses the backslash. The caret was selected because it is used less often in PHP than the backslash currently is. Additionally this RFC author estimates that more people will be familiar with Objective-C than Haskell within our community making the caret symbol more relatable.

==== Backward Incompatible Changes ====
There are no backwards incompatible changes.

==== Patches and Tests ====
An implementation with tests can be found here: https://github.com/morrisonlevi/php-src/tree/arrow_functions. This patch is feature-complete. However, the primary implementation was written a long time ago and the master branch has changed significantly in the meantime. Please report any bugs you encounter.

==== PHP Version ====
This RFC targets PHP 7.NEXT, currently version 7.2.

==== Voting ====
The voting is split into two votes. The first is to accept the idea of arrow functions and requires 2/3 vote. The second is to decide whether ''use''d variables are bound by value or by reference and is a simple majority wins.

-----

<doodle title="Accept arrow functions? (2/3 required)" auth="levijm" voteType="single" closed="true">
   * Yes
   * No
</doodle>

-----

<doodle title="Should used variables be bound by value or by reference? (majority wins)" auth="levijm" voteType="single" closed="true">
   * Value
   * Reference
</doodle>

-----

==== Examples ====

=== Snippets ===
Taken from [[https://github.com/silexphp/Pimple/blob/62b5d317a83b02eea42b5b785b62a29fba458bcf/src/Pimple/Container.php#L242-L244|silexphp/Pimple]]:

<PHP>$extended = function ($c) use ($callable, $factory) {
    return $callable($factory($c), $c);
};

// with arrow function:
$extended = ^$c => $callable($factory($c), $c);</PHP>

This reduces the amount of boilerplate from 44 characters down to 5.

-----

Taken from [[https://github.com/doctrine/dbal/blob/master/lib/Doctrine/DBAL/Schema/PostgreSqlSchemaManager.php|Doctrine DBAL]]:

<PHP>$this->existingSchemaPaths = array_filter($paths, function ($v) use ($names) {
    return in_array($v, $names);
});

// with arrow function
$this->existingSchemaPaths = array_filter($paths, ^$v => in_array($v, $names));</PHP>

This reduces the amount of boilerplate from 31 characters down to 5.

-----

The complement function as found in many libraries:

<PHP>function complement(callable $f) {
    return function(... $args) use ($f) {
        return !$f(... $args);
    };
}

// with arrow function:
function complement(callable $f) {
    return ^(... $args) => !$f(... $args);
}</PHP>

=== Longer Examples ===

The following examples were given to me by [[https://gist.github.com/tpunt/b4f9bf30f43b9e148b73ce18245ab472|tpunt]]:

<PHP>$result = Collection::from([1, 2])
    ->map(function($v) {
        return $v * 2;
    })
    ->reduce(function($tmp, $v) {
        return $tmp + $v;
    }, 0);

echo $result; //6

// with arrow functions:
$result = Collection::from([1, 2])
    ->map(^$v => $v * 2)
    ->reduce(^($tmp, $v) => $tmp + $v, 0);

echo $result; //6
</PHP>

-----

This one is big enough I've split it into two sections; here is with our current closures:

<PHP>function groupByKey($collection, $key)
{
    $generatorFactory = function () use ($collection, $key) {
        return groupBy(
            filter(
                $collection,
                function ($item) use ($key) {
                    return isCollection($item) && has($item, $key);
                }
            ),
            function($value) use ($key) {
                return get($value, $key);
            }
        );
    };

    return new Collection($generatorFactory);
}</PHP>

And with arrow functions:

<PHP>function groupByKey($collection, $key)
{
    $generatorFactory = ^() =>
        groupBy(
            filter(
                $collection,
                ^$item => isCollection($item) && has($item, $key)
            ),
            ^$value => get($value, $key);
        );

    return new Collection($generatorFactory);
}</PHP>

-----

Taken from Ping's example in their [[https://github.com/TimeToogo/Pinq|README.md]] with only some slight modifications:

<PHP>$youngPeopleDetails = $people
    ->where(function ($row) use($maxAge) { return $row['age'] <= $maxAge; })
    ->orderByAscending(function ($row) { return $row['firstName']; })
    ->thenByAscending(function ($row) { return $row['lastName']; })
    ->take(50)
    ->indexBy(function ($row) { return $row['phoneNumber']; })
    ->select(function ($row) { 
        return [
            'fullName'    => $row['firstName'] . ' ' . $row['lastName'],
            'address'     => $row['address'],
            'dateOfBirth' => $row['dateOfBirth'],
        ]; 
    });
</PHP>

With arrow functions:

<PHP>$youngPeopleDetails = $people
    ->where(^$row => $row['age'] <= $maxAge)
    ->orderByAscending(^$row => $row['firstName'])
    ->thenByAscending(^row => $row['lastName'])
    ->take(50)
    ->indexBy(^$row => $row['phoneNumber'])
    ->select(^$row => [
        'fullName'    => $row['firstName'] . ' ' . $row['lastName'],
        'address'     => $row['address'],
        'dateOfBirth' => $row['dateOfBirth'],
    ]);
</PHP>

===== Future Scope =====

==== Multi-Statement Bodies ====
Some languages permit multi-statement closures with a syntax like:

<PHP>(parameter_list) => {
    stmt1;
    stmt2;
    //…
}</PHP>

In this case nothing would be automatically returned. It would be necessary to keep the caret prefix if this was added to PHP.