====== PHP RFC: Arrow Functions ======
  * Version: 1.0
  * Date: 2015-10-01
  * Author: Levi Morrison <levim@php.net>
  * Author: Bob Weinand <bwoebi@php.net>
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/arrow_functions

===== Introduction =====
Anonymous functions and closures can be verbose even though sometimes they are quite simple and contain only a single expression. Other languages have identified this as a pain point and there are a few different ways to write closures in a more succinct form. This RFC proposes a shorter syntax for anonymous functions and closures in PHP compared to what we already have.

This RFC is an alternative proposal to Bob Weinand's [[rfc:short_closures]] RFC. His RFC contains a lot of relevant information. This RFC will reference the short_closures RFC several times so readers should be familiar with it.

===== Proposal =====
This RFC proposes arrow functions which are similar in syntax to several other languages such as arrow functions from EcmaScript 2015 (ES6)((https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)) and lambda expressions from C#((https://msdn.microsoft.com/en-us/library/bb397687.aspx)). It has the basic form of:

<PHP>
fn (parameter_list) => expr
</PHP>

The ''expr'' is a single expression. The expression will be evaluated and then the result will be returned:

<PHP>
$mul2 = fn($x) => $x * 2;

$mul2(3); // evaluates to 6
</PHP>

It will automatically capture each variable used in the expression that are defined in the parent scope. Whether these variables are bound by value or by reference will be determined by vote.

In the following <php>$versionA</php> and <php>$versionB</php> are equivalent if variables are bound by value:

<PHP>
$y = 1;

$versionA = fn($x) => $x + $y;

$versionB = function($x) use($y) {
    return $x + $y;
};
</PHP>

If the variables are bound by reference then these are equivalent:

<PHP>
$y = 1;

$versionA = fn($x) => $x + $y;

$versionB = function($x) use(&$y) {
    return $x + $y;
};
</PHP>

In either case the arrow function is much shorter. It also avoids the use of ''{}'' which means that writing anonymous functions in-line is less painful. This is helpful when using anonymous functions and closures as parameters:

<PHP>
$elements = [1, 3, 5];

// live
$result = array_map(function($x) {
    return $x * 2;
}, $elements);

// cramped live
$result = array_map(function($x) { return $x * 2; }, $elements);

// proposed
$result = array_map(fn($x) => $x * 2, $elements);
</PHP>

==== Type Declarations ====
This RFC allows for type declarations for both parameters and return types. This feature was missing in Bob's [[rfc:short_closures]] RFC because of implementation complications. This issue was noted multiple times on the mailing list as something that bothered voters. Arrow functions do not have this issue because the <php>fn</php> prefix will prevent the parser issues from happening.

Here is an example of type declarations in an arrow function: <php>fn(int $x): int => $x * 2</php>. 

==== Why keep the prefix? ====
Bob's proposal dropped the ''function'' prefix because of brevity. This is also done in EcmaScript 2015 (ES6) and C#. However, in PHP we can provide type information on parameters and can also pass variables by reference which together cause an ambiguity. In the definition <php>(Type &$x) => expr</php> the part <php>(Type &$var)</php> can parse as "take constant ''Type'' and variable ''$var'' and do a bitwise and ''&'' operation." After that the ''<nowiki>=></nowiki>'' will be an unexpected token. Even though the rule would be invalid the parser doesn't know that far ahead there will be an error and it doesn't know which rule to pick. This can be resolved by inefficient GLR parsing or a painstaking rewrite of our parsing rules. This author is of the opinion that it is better to avoid the issue than to resolve it in this case. The ''fn'' prefix will avoid these issues while maintaining brevity.

The <php>fn</php> prefix also prevents ambiguities with the existing usages of the ''T_DOUBLE_ARROW'' token (''<nowiki>=></nowiki>''). Note that if we just used [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions|EcmaScript 2015's arrow function]] syntax there would be two ambiguities:

<PHP>
// Does this mean:
//   1. Create an array key with the result of `($x)` and a value with `$x * 2`
//   2. Create an array with one value that is an anonymous function
[($x) => $x * 2]

// Does this mean:
//   1. Yield a key with the result of `($x)` and a value with `$x * 2`
//   2. Yield an anonymous function
yield ($x) => $x * 2;
</PHP>

This RFC avoids the issue because the <php>fn</php> keyword is prefixed:

<PHP>
// clearly an array with an anonymous function
[fn($x) => $x * 2];

// clearly yields an anonymous function
yield fn($x) => $x * 2;
</PHP>

This also helps people understand that what is being declared is a function. For example, it's not immediately clear that <php>$x => $x * 2</php> is a function, but adding the prefix helps<php>fn($x) => $x * 2</php>.

==== Backward Incompatible Changes ====
This adds a new keyword ''fn''.

===== Patches and Tests =====
A preliminary implementation with tests can be found here: https://github.com/morrisonlevi/php-src/tree/arrow_functions.

==== PHP Version ====
This RFC targets PHP 7.NEXT, currently version 7.1.

==== Voting Choices ====
The voting is split into two votes. The first is to accept the idea of arrow functions and requires 2/3 vote. The second is to decide whether ''use''d variables are bound by value or by reference and is a simple majority wins.

-----

<doodle title="Accept arrow functions? (2/3 required)" auth="levijm" voteType="single" closed="true">
   * Yes
   * No
</doodle>

-----

<doodle title="Should used variables be bound by value or by reference? (majority wins)" auth="levijm" voteType="single" closed="true">
   * Value
   * Reference
</doodle>

===== Open Issues =====
Make sure there are no open issues when the vote starts!

===== Future Scope =====

==== Multi-Statement Bodies ====
Some languages permit multi-statement closures with a syntax like:

<PHP>(parameter_list) => {
    expr;
    expr2;
    //â€¦
}</PHP>

In this case nothing is automatically returned. In other languages the function prefix would be omitted so this provides a way to write less code when doing multi-statement closures. As noted above the function prefix prevents some parsing pains so it should be kept. This means the usefulness of this construct in PHP is diminished, though that does not mean it would not be useful.

==== Named Arrow Functions ====
It could be possible to allow the arrow function syntax to work on methods and named functions. In this case <php>=> expr</php> would just be short-hand for <php>{ return expr; }</php>. This would be useful for very short definitions:

<PHP>namespace My;

fn sum($a, $b) => $a + $b;

class Some {
    private $thing;
    fn get() => $this->thing;
}
</PHP>

This author expects that named functions are more likely to have multi-statement bodies when compared to closures. However, if this RFC passes the parsing work would be trivial to extend here.