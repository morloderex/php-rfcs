====== PHP RFC: Readonly amendments ======
  * Date: 2022-10-24
  * Author: Nicolas Grekas <nicolasgrekas@php.net>, Máté Kocsis <kocsismate@php.net>
  * Status: Draft
  * Target Version: PHP 8.3
  * Implementation: https://github.com/php/php-src/pull/9827 (proposal #1), https://github.com/php/php-src/pull/9497 (proposal #2)

===== Introduction =====

PHP 8.1 added support for readonly properties via [[rfc:readonly_properties_v2|PHP RFC: Readonly properties 2.0]], and PHP 8.2 added support for readonly classes via [[rfc:readonly_classes|PHP RFC: Readonly classes]]. However, these features still have some shortcomings which should be addressed. Therefore, this RFC proposes the below amendments for the original RFCs:

==== Proposal 1: Non-readonly classes can extend readonly classes ====

Currently, non-readonly classes are disallowed to extend readonly ones:

<PHP>
readonly class A {}
class B extends A {}
// Fatal error: Non-readonly class B cannot extend readonly class A
</PHP>

This exception was added to the readonly classes RFC mainly as a precaution for unforeseeable side-effects and also in order to prevent the occasional violation of invariants of the parent (no dynamic or mutable properties are allowed) by the child. However, as it turned out based on the discussion of https://externals.io/message/118554, this restriction prevents to implement decoration via inheritance proxies for readonly classes; but no one could find a good enough example where the restriction would prevent any real bugs. Therefore, we propose to lift the restriction in question so that the following code becomes valid:

<PHP>
readonly class A {}
class B extends A {}
// No error
</PHP>

Readonly classes are already strictly disallowed to create dynamic properties, however non-readonly child classes do not fall under this rule, only a deprecation is emitted:

<PHP>
readonly class A {}
class B extends A {}

$b = new B();
$b->dynamicProperty = 1;
// Deprecated: Creation of dynamic property B::$dynamicProperty is deprecated
</PHP>

Unlike readonly classes, they can also accept the ''#[AllowDynamicProperties]'' attribute in order to suppress the above deprecation notice.

Furthermore, readonly classes can declare neither static, nor untyped properties, no matter if the declaration is done directly in the class or indirectly via a trait ([[https://github.com/php/php-src/issues/9285|https://github.com/php/php-src/issues/9285]]). On the other hand, their non-readonly children can do the following:

<PHP>
trait BTrait {
    public static $staticProperty2;
    public $untypedProperty2;
}

readonly class A {}

class B extends A {
    use BTrait;

    public static $staticProperty;
    public $untypedProperty;
}

// No error
</PHP>

Here is an example of non-readonly child class that tracks the number of times a method has been called:

<PHP>

readonly class A
{
    // ...

    public function doStuff()
    {
        // ...
    }
}

class B extends A
{
    private int $doStuffCounter = 0;

    // ...

    public function doStuff()
    {
        ++$this->doStuffCounter;

        parent::doStuff();
    }
    
    public function getDoStuffCounter(): int
    {
        return $this->doStuffCounter;
    }
}
</PHP>

Such construct is commonly used in e.g. mock classes in order to assert the number of times a method has been called.

Right now in PHP 8.2, this is not allowed.


===== Proposal 2: Readonly properties can be reinitialized during cloning =====

Currently, readonly properties cannot be "deep-cloned" since an ''Error'' is thrown the second time they are assigned to any value. This is a major inconvenience which prevents any non-basic use-cases. The second proposal eliminates this shortcoming by making it possible to reinitialize readonly properties during cloning according to the following semantics:

Reinitialization can only take place //during// the ''_clone()'' magic method call, no matter if the actual assignment happens in a different method or function invoked inside ''_clone()''. This will ensure that the original object being cloned is left intact so the readonly invariant still holds at the object level, while the new instance can be modified.

Reinitialization of each property is possible once and only once: any subsequent modification attempts trigger an ''Error''. Apart from this, semantics of readonly properties is not changed in any other way, so their modification is still allowed only in the private scope, just like before.

<PHP>
readonly class Foo {
    public function __construct(
        public DateTime $bar
    ) {}
    
    public function __clone()
    {
        $this->bar = clone $this->bar;
    }
}

$foo = new Foo(new DateTime());
$foo2 = clone $foo;

// No error, Foo::$bar is cloned deeply
</PHP>

===== Reflection =====

The above proposals don't have impact for reflection.

===== Backward Incompatible Changes =====

None.

=====Future scope =====

There is still one more known shortcoming of the original RFCs: static properties don't support the readonly modifier, therefore readonly classes cannot contain static properties. These restrictions could be lifted at a later point of time.

TODO: mention clone-with / clone-modifier ideas

===== Vote =====

  * Should non-readonly classes be able to extend readonly-classes?
  * Should it be possible to reinitialize readonly properties during cloning?

Both votes require 2/3 majority.
