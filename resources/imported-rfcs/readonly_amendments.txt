====== PHP RFC: Readonly amendments ======
  * Date: 2022-10-24
  * Author: Nicolas Grekas <nicolasgrekas@php.net>, Máté Kocsis <kocsismate@php.net>
  * Status: Draft
  * Target Version: PHP 8.3
  * Implementation: https://github.com/php/php-src/pull/9827 (proposal #1), https://github.com/php/php-src/pull/9497 (proposal #2)

===== Introduction =====

PHP 8.1 added support for readonly properties via [[rfc:readonly_properties_v2|PHP RFC: Readonly properties 2.0]], and PHP 8.2 added support for readonly classes via [[rfc:readonly_classes|PHP RFC: Readonly classes]]. However, these features still have some shortcomings which should be addressed. Therefore, this RFC proposes the below amendments for the original RFCs:

==== Proposal 1: Non-readonly classes can extend readonly classes ====

Currently, non-readonly classes are disallowed to extend readonly ones:

<PHP>
readonly class A {}
class B extends A {}
// Fatal error: Non-readonly class B cannot extend readonly class A
</PHP>

This exception was added to the readonly classes RFC mainly as a precaution for unforeseeable side-effects and also in order to prevent the occasional violation of invariants of the parent (no dynamic or mutable properties are allowed) by the child. However, as it turned out based on the discussion of https://externals.io/message/118554, this restriction prevents to implement decoration via inheritance proxies for readonly classes; but no one could find a good enough example where the restriction would prevent any real bugs. Therefore, we propose to lift the restriction in question so that the following code becomes valid:

<PHP>
readonly class A {}
class B extends A {}
// No error
</PHP>

Readonly classes are already strictly disallowed to create dynamic properties, however non-readonly child classes do not fall under this rule, only a deprecation is emitted:

<PHP>
readonly class A {}
class B extends A {}

$b = new B();
$b->dynamicProperty = 1;
// Deprecated: Creation of dynamic property B::$dynamicProperty is deprecated
</PHP>

Unlike readonly classes, they can also accept the ''#[AllowDynamicProperties]'' attribute in order to suppress the above deprecation notice.

Furthermore, readonly classes can declare neither static, nor untyped properties, no matter if the declaration is done directly in the class or indirectly via a trait ([[https://github.com/php/php-src/issues/9285|https://github.com/php/php-src/issues/9285]]). On the other hand, their non-readonly children can do the following:

<PHP>
trait BTrait {
    public static $staticProperty2;
    public $untypedProperty2;
}

readonly class A {}

class B extends A {
    use BTrait;

    public static $staticProperty;
    public $untypedProperty;
}

// No error
</PHP>

A typical example of non-readonly child classes are lazy-loading proxies:

<PHP>

readonly class A
{
    // ...

    public function doStuff()
    {
        // ...
    }
}

class LazyA extends A
{
    private bool $isInitialized = false;

    // ...

    public function doStuff()
    {
        if (!$this->isInitialized) {
            $this->isInitialized = true;
            $this->initialize();
        }

        parent::doStuff();
    }
}
</PHP>

Right now in PHP 8.2, this construct is not allowed.


===== Proposal 2: Readonly properties can be reinitialized during cloning =====

Currently, readonly properties cannot be "deep-cloned" since an ''Error'' is thrown the second time they are assigned to any value. This is a major inconvenience which prevents any non-basic use-cases. The second proposal eliminates this shortcoming by making it possible to reinitialize readonly properties during cloning according to the following semantics:

Reinitialization can only take place //during// the ''_clone()'' magic method call, no matter if the actual assignment happens in a different method or function invoked inside ''_clone()''. This will ensure that the original object being cloned is left intact so the readonly invariant still holds at the object level, while the new instance can be modified.

Reinitialization of each property is possible once and only once: any subsequent modification attempts trigger an ''Error''. Apart from this, semantics of readonly properties is not changed in any other way, so modification of readonly properties are still allowed only in the private scope, just like before.

<PHP>
readonly class Foo {
    public function __construct(
        public DateTimeImmutable $bar
    ) {}
    
    public function __clone()
    {
        $this->bar = clone $this->bar;
    }
}

$foo = new Foo(new DateTimeImmutable());
$foo2 = clone $foo;

// No error, Foo::$bar is cloned deeply
</PHP>

===== Reflection =====

The above proposals don't have impact for reflection.

===== Backward Incompatible Changes =====

None.

=====Future scope =====

There is still one more known shortcoming of the original RFCs: static properties don't support the readonly modifier, therefore readonly classes cannot contain static properties. These restrictions could be lifted at a later point of time.

===== Vote =====

  * Should non-readonly classes be able to extend readonly-classes?
  * Should it be possible to reinitialize readonly properties during cloning?

Both votes require 2/3 majority.
