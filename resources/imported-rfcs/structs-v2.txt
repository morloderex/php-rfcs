====== PHP RFC: Structs ======

  * Date: 2024-04-16
  * Author: Ilija Tovilo, tovilo.ilija@gmail.com
  * Status: Draft
  * Target Version: PHP 8.x
  * Implementation: https://github.com/php/php-src/pull/13800

===== Proposal =====

This RFC proposes to add structs to PHP, which are classes with [[https://en.wikipedia.org/wiki/Value_semantics|value semantics]].

<code php>
struct Position {
    public function __construct(
        public $x,
        public $y,
    ) {}
}

$p1 = new Position(1, 2);
$p2 = $p1;
$p2->x++;

var_dump($p1 === $p2); // false

$p2->x--;
var_dump($p1 === $p2); // true
</code>

====== Data transfer objects ======

===== The problem =====

Classes are commonly used to model data in PHP. Such classes have many names (data transfer objects, plain old php objects, records, etc.). This allows the developer to describe the shape of the data, thus documenting it and improving developer experience in IDEs.

Using classes for data comes with one significant downside: Objects are passed by reference, rather than by value. When dealing with mutable data, this makes it very easy to shoot yourself in the foot by exposing mutations to places that don't expect to see them.

Consider the following example:

<code php>
class Position {
    public function __construct(
        public $x,
        public $y,
    ) {}
}

function createShapes() {
    // Use same position for both shapes
    $pos = new Position(10, 20);
    $circle = new Circle(position: $pos, radius: 10);
    $square = new Square(position: $pos, side: 20);
    return [$circle, $square];
}

$shapes = createShapes();

function applyGravity() {
    foreach ($shapes as $shape) {
        /* We're not physicists. :P */
        $shape->position->y--;
    }
}

applyGravity($shape);

foreach ($shapes as $shape) {
    var_dump($shape->position);
}
// Position(10, 18), Position(10, 18)??
</code>

Since both shapes are created with the same position, ''createShapes()'' tries to be resourceful and uses the same ''Position'' instance for both shapes. Unfortunately, ''applyGravity()'' is not aware of this optimization and applies its change to the same object twice.

What's the solution? ''position'' needs to be copied, but where? We can either copy it in ''createShapes()'' so that each shape has its own distinct position, or we can copy it in ''applyGravity()'', assuming that ''position'' may be referenced from somewhere else. For the latter case, we may mark ''Position'' as ''readonly'' to get some guarantees that we get it right. Which of these two approaches is better depends on how many positions can be shared, and how often they change. Unfortunately, either can lead to useless copies.

===== The solution =====

Like arrays, strings and other value types, structs are //conceptually// copied when assigned to a variable, or when passed to a function.

With this description, let's reconsider the ''createShapes()'' from above.

<code php>
struct Position { ...  }

function createShapes() {
    // Use same position for both shapes
    $pos = new Position(10, 20);
    $circle = new Circle(position: $pos, radius: 10);
    $square = new Square(position: $pos, side: 20);
    return [$circle, $square];
}
</code>

//Conceptually//, ''$circle->position'' and ''$square->position'' are distinct objects at the end of this function. ''applyGravity()'' can no longer influence multiple references to ''position''. This completely avoids the "spooky action at a distance" problem.

====== Growable data structures ======

===== The problem =====

The same problem exists, and is in fact greatly exacerbated, for internal, growable data structures such as lists, stacks, queues, etc. that desire to provide APIs immune to action at a distance.

<code php>
// Pseudo-code for an internal class
class List {
    public $storage = <malloced>;

    public function append($element) {
        $clone = clone $this; // including storage
        $clone->storage->append($element);
        return $clone;
    }
}

// Userland
$list = new List();
for ($i = 0; $i < 1000; $i++) {
    $list = $list->append($i);
}
</code>

Not only will this loop create a copy for each list object on each iteration, but it will also copy its entire storage. With this approach, time complexity of a single insert becomes O(n). For m inserts, it becomes O(m*n), which is catastrophic. Looking at the code above, it becomes evident that ''$list'' is not referenced from anywhere else. It is thus completely unnecessary to copy it.

And when it is shared, we only need a single copy, rather than a copy for each insertion.

<code php>
function appendAndPrint($list) {
    $list = $list->append(2); // This copy may be necessary, because $list may still be referenced in the caller.
    $list = $list->append(3); // This copy is always unnecessary.
    var_dump($list); // [1, 2, 3]
}

$list = new List();
$list = $list->append(1); // This copy is also unnecessary.
appendAndPrint($list);
var_dump($list); // [1]
</code>

===== The solution =====

As a reminder, structs are //conceptually// copied when assigned to a variable, or when passed to a function. When ''appendAndPrint()'' is called, ''$list'' is effectively already copied. Just like with arrays, the user doesn't need to think about creating explicit copies. The engine does it for you.

<code php>
function appendAndPrint($list) {
    $list->append!(2);
    $list->append!(3);
    var_dump($list); // [1, 2, 3]
}

$list = new List();
$list->append!(1);
appendAndPrint($list);
var_dump($list); // [1]
</code>

Mind the ''!'' in ''append!()''. It denotes that the method call will mutate the struct, which makes every modification very explicit. It also has some technical benefits, which will be explained later.

One of the primary motivators of this RFC is to enable the possibility of introducing internal data structures, such as lists (e.g. Vector from php-ds) as a faster and stricter alternative to arrays, without introducing many of the pitfalls some other languages suffer from by making them reference types.

===== CoW üêÑ =====

But wait, this sounds familiar.

<blockquote>
What's the solution? ''position'' needs to be copied, but where? We can either copy it in ''createShapes()'' so that each shape has its own distinct position ... Unfortunately, either can lead to useless copies.

<cite>This RFC, minutes ago</cite>
</blockquote>

You may assume that structs come with the same slowdown as creating a copy for each assignment of an object. However, structs have a cool trick up their sleeves: Copy-on-write, or CoW for short. CoW is already used for both arrays and strings, so this is not a new concept to the PHP engine. PHP tracks the reference count for each allocation such as objects, arrays and strings. When value types are modified, PHP checks if the reference count is >1, and if so, it copies the element before performing a modification.

<code php>
function print($value) {
    var_dump($value);
}

function appendAndPrint($value) {
    $value[] = 'baz';
    var_dump($value);
}

print(['foo', 'bar']);
appendAndPrint(['foo', 'bar']);

$array = ['foo', 'bar'];
print($array);
appendAndPrint($array);
</code>

//Note:// This code ignores the fact that array literals are constant, for simplicity.

With the rules described above, the only line performing potential copies is ''$value[] = 'baz';'', since it performs a modification of the array. The copy is also avoided unless ''$value'' is referenced from somewhere else, which is only the case when passing the local variable ''$array'' to ''appendAndPrint()''.

This is already how arrays work today. Structs follow the exact same principle.

<code php>
function print($value) {
    var_dump($value);
}

function modifyAndPrint($value) {
    $value->x++;
    var_dump($value);
}

print(new Position(1, 2));
appendAndPrint(new Position(1, 2));

$pos = new Position(1, 2);
print($pos);
appendAndPrint($pos);
</code>

Only one implicit copy happens, namely in ''modifyAndPrint()'' when ''$value'' is still referenced as ''$pos'' from the caller.

===== Equality/Identity =====

The structs identity is dictated not by their "pointer" or object ID, as with normal objects. Instead, value types are considered identical if they contain the same data. As such, the identity operator ''==='' is adjusted for structs so that two structs are identical if:

  * The objects are instances of the same struct.
  * All of their properties are identical (''==='').
  * If the objects contain dynamic properties, the dynamic properties must have the same order.

This adjustment pertains not only to the ''==='' operator itself, but also to language features that use it. For example, ''match'' will compare the expression and match arms using ''==='' semantics.

The semantics for equality (''=='') for structs remain the same as for normal classes. That is, the objects must be of the same struct, and all properties must be equal (''==''), including dynamic properties. However, the order of dynamic properties is irrelevant.

===== Method calls =====

Self-mutating methods of structs pose an interesting problem. The promise of value types is that a value doesn't change, unless an explicit modification is made to this same variable. For example, consider a ''BigNum'' implementation:

<code php>
struct BigNum {
    public function __construct(
        // Int is not very useful, it's just for demonstration purposes. :)
        public int $value,
    ) {}

    public function double() {
        $this->value *= 2;
    }
}

$n1 = new Number(1);
$n2 = $n1;
$n2->double();

var_dump($n1); // 1
var_dump($n2); // 2
</code>

To properly support this, we need both an indication on the caller and the callee, that the method will mutate the variable.

<code php>
struct BigNum {
    // ...

    public mutating function double() {
        $this->value *= 2;
    }
}

// ...
$n2->double!();
</code>

The call-site notation is technically necessary, for reasons we'll not get into here. But it also has the nice side-effect of making it immediately clear that the method mutates the variable.

<code php>
// $list is modified, indicated by !.
$list->sort!();
// $list is not modified, indicated by the lack of !.
$sortedList = $list->sorted();
</code>

Only mutating methods can and must be called using the ''!()'' syntax. Calling mutating methods with ''()'', or non-mutating methods with ''!()'' results in a runtime error.

TOOD: Check if we can enforce ''mutating'' at compile-time, anytime ''$this'' is fetched with RW (assignments, calling of mutating methods, fetching references).

===== Inheritance =====

TODO

===== References =====

TODO

===== Reflection =====

TODO

===== Readonly / interior mutability =====

TODO

===== Performance =====

TODO

===== Backwards incompatible changes =====

TODO

===== Future scope =====

  - Hashing for ''SplObjectStorage''.

===== Vote =====

Voting starts xxxx-xx-xx and ends xxxx-xx-xx.

As this is a language change, a 2/3 majority is required.

<doodle title="Introduce structs in PHP 8.x?" auth="ilutov" voteType="single" closed="true">
   * Yes
   * No
</doodle>
