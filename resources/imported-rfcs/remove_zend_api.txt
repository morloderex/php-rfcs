====== Remove reliance on Zend API ======
  * Version: 1.0
  * Date: 2009-03-27
  * Author: Paul Biggar <paul.biggar@gmail.com>
  * Status: Early draft


A better way to provide a C API, with particular emphasis on decoupling extensions from the interpreter.

===== Introduction =====

** Naturally, this seems insane. Please bear with me. **


===== What's the problem? =====

=== Zend API ===

The Zend API is a large set of functions, macros and data-structures which are used to interact with the Zend Engine. It serves 3 major purposes, roughly in order of importance:

  * Used to write PHP's standard libraries, 3rd party extensions, and much of PECL
  * Allows hot (performance-sensitive) code to be rewritten in C for speed
  * Used to embed PHP into within C/C++ applications using the embed SAPI

=== Problems ===

The main problem with it is that it constrains the implementation of the Zend Engine. The Zend API creates a tight coupling between the ZendEngine and its users, restricting greatly our ability to change the Zend Engine. By requiring backwards compatability with the Zend Engine, we are ensuring that the ZendEngine can only be modified in minor ways (although ABI changes are allowed for major versions). This holds the Zend Engine to design decisions made nearly 10 years ago, and prevent PHP from getting much faster in the long term.

The Zend API also makes it difficult to write PHP extensions. Although most of the API is not terribly difficult to work with, concepts like copy-on-write, change-on-write sets and separation appear to be tricky concepts for many people. The only documentation is Sara Golemon's book, and the actual code is not well commented. Although zend_parse_parameters has simplified the parameter parsing somewhat, I believe that a simpler way of writing extensions would be welcome.

A number of other PHP implementations exist, such as IBM's Project Zero, Phalanger, Roadsend, Quercus and phc. Many of these projects find it very difficult to re-use PHP's standard libraries. Quercus and Roadsend have reimplemented popular standard libraries. Phalanger and Project Zero attempt to re-use the existing libraries by marshalling their data into the Zend API. This appears to be slow and error-prone. phc is designed around reusing the Zend API for compatibility with the PHP. This constrains many of the optimizations phc would wish to perform, since it uses the Zend API nearly everywhere.


===== What's the solution? =====

=== Design Criteria ===

  * Greatly reduce the coupling between the Zend Engine and its users
  * Support all major use cases of the Zend API
    * preferably simplifying each use case


=== Solution ===

Take the use case of wrapping a C library to expose its functionality in user space. The major idea is to "automatically" import C functions into a special namespace. The PHP library functions would then be comprised of PHP user space code which calls those C functions directly. That way it is possible to craft an API that is separate from the C implementation.

Lets take a simple example. Assume we have a C library XXX, with 3 functions, x, y and z. We'd like to expose this in user space as a class called MyXXX, with methods a and b. We create a file with the signatures of x, y and z:

extensions/xxx/sigs.h
<file>
int x (int, int);
void y (char*, int);
void z (char*, int);
</file>

We then write our user space code:

extensions/xxx/MyXXX.php
<file>
class MyXXX
{
   function __construct ($username)
   {
       $this->username = $username;
   }

   function a ($w1, $w2)
   {
      $foo = \internals\XXX\x ($w1, $w2);
      \internals\XXX\y ($this->username, $foo);
   }

   function b ($m1, $m2)
   {
      $foo = \internals\XXX\x ($m1, $m2);
      \internals\XXX\z ($this->username, $foo);
      return $foo;
   }
}
</file>

=== Zend engine ===

TODO: How does this break the tight coupling?

=== Extensions/PECL ===

TODO: How does make writing extensions easier?

=== Embed SAPI ===

TODO: How would this work for the embed SAPI?


=== Other PHP implementations ===

TODO


===== Project Plan =====

This is a simple design. In reality, it would need to be prototyped to determine whether this makes sense for every use case, and that there would be little sacrificed to make it work.


==== Links ====



===== Changelog =====


