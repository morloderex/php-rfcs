====== PHP RFC: Enumerations ======

  * Date: 2020-12-04
  * Author: Larry Garfield (larry@garfieldtech.com), Ilija Tovilo (tovilo.ilija@gmail.com)
  * Status: In Discussion
  * Target Version: PHP 8.1
  * Implementation: https://github.com/php/php-src/pull/6489

===== Introduction =====

This RFC introduces Enumerations to PHP.  The scope of this RFC is limited to "unit enumerations," that is, enumerations that are themselves a value, rather than simply a fancy syntax for a primitive constant, and do not include additional associated information.  This capability offers greatly expanded support for data modeling, custom type definitions, and monad-style behavior. Enums enable the modeling technique of “make invalid states unrepresentable,” which leads to more robust code with less need for exhaustive testing.

Many languages have support for enumerations of some variety. A [[https://github.com/Crell/enum-comparison|survey we conducted of various languages]] found that they could be categorized into three general groups: Fancy Constants, Fancy Objects, and full Algebraic Data Types (ADTs). 

This RFC is part of a larger effort to introduce full Algebraic Data Types.  It implements the "Fancy Objects" variant of enumerations in such a way that it may be extended to full ADTs by future RFCs.  It draws both conceptually and semantically from Swift, Rust, and Kotlin, although it is not directly modeled on either.

The most popular case of enumerations is ''%%boolean%%'', which is an enumerated type with legal values ''%%true%%'' and ''%%false%%''. This RFC allows developers to define their own arbitrarily robust enumerations.

===== Proposal =====

Enumerations are built on top of classes and objects.  That means, except where otherwise noted, "how would Enums behave in situation X" can be answered "the same as any other object instance."  They would, for example, pass an ''object'' type check.  Similarly, enum names and case names are both case insensitive.  (With the same caveat about autoloading on case sensitive file systems that already applies to classes generally.)

==== Unit enumerations ====

This RFC introduces a new language construct, ''%%enum%%''. Enums are similar to classes, and share the same namespaces as classes, interfaces, and traits. They are also autoloadable the same way. An Enum defines a new type, which has a fixed, limited number of possible legal values.

<code php>
enum Suit {
  case Hearts;
  case Diamonds;
  case Clubs;
  case Spades;
}
</code>

This declaration creates a new enumerated type named ''%%Suit%%'', which has four and only four legal values: ''%%Suit::Hearts%%'', ''%%Suit::Diamonds%%'', ''%%Suit::Clubs%%'', and ''%%Suit::Spades%%''. Variables may be assigned to one of those legal values. A function may be type checked against an enumerated type, in which case only values of that type may be passed.

<code php>
function pick_a_card(Suit $suit) { ... }

$val = Suit::Diamonds;

pick_a_card($val);        // OK
pick_a_card(Suit::Clubs); // OK
pick_a_card('Spades');    // throws TypeError
</code>

An Enumeration may have zero or more ''%%case%%'' definitions, with no maximum.  A zero-case enum is syntactically valid, if rather useless.

Cases are not intrinsically backed by a scalar value. That is, ''%%Suit::Hearts%%'' is not equal to 0. Instead, each case is backed by a singleton object of that name. That means that:

<code php>
$a = Suit::Spades;
$b = Suit::Spades;

$a === $b; // true

$a instanceof Suit;         // true
</code>

This type of enum (with just enum cases and no related data) is known as a "Unit Enum".

All Unit Enums as implemented as instances of their enum type.  The enum type is represented internally as a class that implements an internal ''UnitEnum'' interface that may be typed against.  That is one way to determine an Enum from any other object:

<code php>
Suit::Hearts instanceof UnitEnum; // true
</code>

(See below for more on the enum interfaces.)

==== Enumerated Methods ====

Enums may contain methods, and may implement interfaces.  If an Enum implements an interface, then any type check for that interface will also accept all cases of that Enum.

<code php>
interface Colorful {
  public function color(): string;
}

enum Suit {
  case Hearts;
  case Diamonds;
  case Clubs;
  case Spades;
  
  // Fulfills the interface contract.
  public function color(): string {
    return match($this) {
      Suit::Hearts, Suit::Diamonds => 'Red',
      Suit::Clubs, Suit::Spaces => 'Black',
    };
  }
  
  // Not part of an interface; that's fine.
  public function shape(): string {
    return "Rectangle";
  }
}

function paint(Colorful $c) { ... }

paint(Suit::Clubs);  // Works

print Suit::Diamonds->shape(); // prints "rectangle"
</code>

In this example, all four instances of ''Suit'' have two methods, ''%%color()%%'' and ''%%shape()%%''.  As far as calling code and type checks are concerned, they behave exactly the same as any other object instance.

Inside a method on a Case, The ''%%$this%%'' variable is defined and refers to the Case instance.

Methods may be arbitrarily complex, but in practice will usually return a static value or ''match'' on ''%%$this%%'' to provide different results for different cases.

Note that in this case it would be a better data modeling practice to also define a ''%%SuitColor%%'' Enum Type with values Red and Black and return that instead. However, that would complicate this example.

The above hierarchy is logically similar to the following class structure:

<code php>
interface Colorful {
  public function color(): string;
}

class Suit implements UnitEnum, Colorful {

  public const Hearts = new static('magic-Hearts');
  public const Diamonds = new static('magic-Diamonds');
  public const Clubs = new static('magic-Clubs');
  public const Spades = new static('magic-Spades');

  private function __construct() {}

  return match($this) {
      Suit::Hearts, Suit::Diamonds => 'Red',
      Suit::Clubs, Suit::Spaces => 'Black',
    };
  }

  public function shape(): string {
    return "Rectangle";
  }
  
  public function cases(): array {
    // See below.
  }
}
</code>

The case instance objects may be assigned to constants because they are created internally in the engine rather than in user-space.  Additionally, the differentiating flag for each case is not actually a constructor parameter.

Methods may be public, private, or protected, although in practice private and protected are equivalent as inheritance is not allowed.

==== Enumeration static methods ====

Enumerations may also have static methods.  The use for static methods on the enumeration itself is primarily for alternative constructors.  Eg:

<code php>
enum Size {
  case Small;
  case Medium;
  case Large;

  public static function fromLength(int $cm) {
    return match(true) {
      $cm < 50 => static::Small,
      $cm < 100 => static::Medium,
      default => static::Large,
    };
  }
}
</code>

Static methods may be public, private, or protected, although in practice private and protected are equivalent as inheritance is not allowed.

==== Enumeration constants ====

Eumerations may include constants, which may be public, private, or protected, although in practice private and protected are equivalent as inheritance is not allowed.

An enum constant may refer to an enum case:

<code php>
enum Size {
  case Small;
  case Medium;
  case Large;

  public const Huge = self::Large;
}
</code>

Additionally, because cases are represented as constants on the enum itself, they may be used as static values in constant definition or function parameter default values.

==== Traits ====

Enumerations may leverage traits, which will behave the same as on classes.  The caveat is that traits ''use''d in an enum must not contain properties.  They may only include methods, static methods, and constants.  A trait with properties will result in a fatal error.

<code php>
interface Colorful {
  public function color(): string;
}

trait Rectangle {
  public function shape(): string {
    return "Rectangle";
  }
}

enum Suit implements Colorful {
  use Rectangle;
  
  case Hearts;
  case Diamonds;
  case Clubs;
  case Spades;

  public function color(): string {
    return match($this) {
      Suit::Hearts, Suit::Diamonds => 'Red',
      Suit::Clubs, Suit::Spaces => 'Black',
    };
  }
}
</code>

==== Comparison to objects ====

Although Enums are implemented using classes under the hood and share much of their semantics, some object-style functionality is forbidden.  These either do not make sense in the scope of enums, their value is debatable (but could be re-added in the future), or their semantics are unclear.

Specifically, the following features of objects are not allowed on enumerations:

  * Constructors - Not relevant without data/state.
  * Destructors - Not relevant without data/state.
  * Class/Enum inheritance. - Enums are by design a closed list, which inheritance would violate. (Interfaces are allowed, but not parent classes.)
  * Enum/Case properties - Properties are a form of state, and enum cases are stateless singletons.  Metadata about an enum or case can always be exposed via methods.
  * Dynamic properties - Avoid state.  Plus, they're a bad idea on classes anyway.
  * Magic methods except for those specifically listed below - Most of the excluded ones involve state.

If you need any of that functionality, classes as they already exist are the superior option.

The following object functionality is available, and behaves just as it does on any other object:

  * Public, private, and protected methods.
  * Public, private, and protected static methods.
  * Public, private, and protected constants.
  * ''%%__get%%'', ''%%__call%%'', and ''%%__invoke%%''  magic methods
  * __CLASS__ and __FUNCTION__ constants behave as normal

The ''%%::class%%'' magic constant on an Enum type evaluates to the type name including any namespace, exactly the same as an object.  The ''%%::class%%'' magic constant on a Case instance also evaluates to the Enum type, as it is an instance of that type.

Additionally, enum cases may not be instantiated directly with ''new'', nor with ''newInstanceWithoutConstructor'' in reflection.  Both will result in an error.

<code php>
$clovers = new Suit(); // error
$mace = new Suit::Club; // errror
</code>

==== Scalar Enums ====

By default, Enumerated Cases have no scalar equivalent. They are simply singleton objects. However, there are ample cases where an Enumerated Case needs to be able to round-trip to a database or similar datastore, so having a built-in scalar (and thus trivially serializable) equivalent defined intrinsically is useful.

To define a scalar equivalent for an Enumeration, the syntax is as follows:

<code php>
enum Suit: string {
  case Hearts = 'H';
  case Diamonds = 'D';
  case Clubs = 'C';
  case Spades = 'S';
}
</code>

Scalar backing types of ''%%int%%'' or ''%%string%%'' are supported, and a given enumeration supports only a single type at a time. (That is, no union of ''%%int|string%%''.) If an enumeration is marked as having a scalar equivalent, then all cases must have a unique scalar equivalent defined explicitly.  There are no auto-generated scalar equivalents (e.g., sequential integers).  Scalar cases must be unique; two enum cases may not have the same scalar equivalent.  (However, a constant may refer to a case, effectively creating an alias.)

Scalar equivalent values must be literals. Constants and constant expressions are not supported.

A Scalar Case will automatically down-cast to its scalar when used in a scalar context. For example, when used with ''%%print%%''.

<code php>
print Suit::Clubs;
// prints "C"
print "I hope I draw a " . Suit::Spades;
// prints "I hope I draw a S".
</code>

Passing a Scalar Case to a scalar-typed parameter or return will produce the scalar value in weak-typing mode, and produce a ''%%TypeError%%'' in strict-typing mode.

Scalar enums implement both the internal ''UnitEnum'' interface and an additional ''ScalarEnum'' interface.  ''ScalarEnum'' exposes an additional static method ''%%from()%%'' that is automatically generated. The ''%%from()%%'' method will up-cast from a scalar to its corresponding Enumerated Case. Invalid scalars with no matching Case will throw a ''%%ValueError%%''.

<code php>
$record = get_stuff_from_database($id);
print $record['suit'];
// Prints "H"
$suit = Suit::from($record['suit']);
$suit === Suit::Hearts; // True
</code>

Manually defining a static ''%%from()%%'' method on a Scalar Enum will result in a fatal error.

Scalar Enums may implement interfaces just like Unit Enums:

<code php>
enum Suit: string implements Colorful {
  case Hearts = 'H';
  case Diamonds = 'D';
  case Clubs = 'C';
  case Spades = 'S';
  
  public function color(): string {
    return match($this) {
      Suit::Hearts, Suit::Diamonds => 'Red',
      Suit::Clubs, Suit::Spaces => 'Black',
    };
  }
}

</code>

==== Value listing ====

The ''UnitEnum'' interface includes a static method ''%%cases()%%''. ''%%cases()%%'' returns an array of all defined Cases in lexical order.

<code php>
Suit::cases();
// Produces: [Suit::Hearts, Suit::Diamonds, Suit::Clubs, Suit:Spades]
</code>

If the enumeration is not a Scalar Enum, the array will be packed (indexed sequentially starting from 0).  If the enumeration is a Scalar Enum, the keys will be the corresponding scalar for each enumeration.

The ''ScalarEnum'' interface additionally has a property ''%%value%%'' that returns the scalar value for a given case.

<code php>
'D' == Suit::Diamonds->value; // true
</code>

==== Serialization ====

Enumerations are serialized differently from objects.  Specifically, they have a new serialization code, "E", that specifies the name of the enum case.  The deserialization routine is then able to use that to set a variable to the existing singleton value.  That ensures that:

<code php>
Suit::Hearts === unserialize(serialize(Suit::Hearts));

print serialize(Suit::Hearts);
// E:12:"Suit::Hearts";
</code>

==== Attributes ====

Enums and cases may have attributes attached to them, like any other language construct.  The ''Attribute'' class has two additional target constants defined: ''TARGET_ENUM'' to target only the Enum itself, and ''TARGET_CASE'' to target an Enum Case, specifically.

No engine-defined attributes are included.  User-defined attributes can do whatever.

(Subject to change; See open questions below.)

==== Match expressions ====

''%%match%%'' expressions offer a natural and convenient way to branch logic depending on the enum value. Since every instance of a Unit Case is a singleton, it will always pass an identity check. Therefore:

<code php>
$val = Suit::Diamonds;

$str = match ($val) {
    Suit::Spades => "The swords of a soldier",
    Suit::Clubs => "Weapons of war",
    Suit::Diamonds => "Money for this art",
    default => "The shape of my heart",
}
</code>

This usage requires no modification of ''%%match%%''.  It is a natural implication of the current functionality.

==== SplObjectStorage and WeakMaps ====

As objects, Enum cases cannot be used as keys in an array.  However, they can be used as keys in a ''SplObjectStorage'' or ''WeakMap''.  Because they are singletons they never get garbage collected, and thus will never be removed from a ''WeakMap'', making these two storage mechanisms effectively equivalent.

This usage requires no modification to ''SplObjectStorage'' or ''WeakMap''.  It is a natural implication of the current functionality.

==== Reflection ====

Enums are reflectable using a ''ReflectionEnum'' class, which extends ''ReflectionClass''.  Methods that are not relevant (such as listing properties) are stubbed out to return empty values.  It also contains the following additional methods:

  * ''hasCase(string $name): bool'' - Returns true if there is a Case defined with that name.  For instance, ''$r->hasCase('Hearts')'' returns true.
  * ''getCases(): array'' - Returns an array of ''ReflectionCase'' objects.
  * ''getCase(string $name): ReflectionCase'' - Returns a single ''ReflectionCase'' object for the corresponding case.  If not found, it throws a ''ReflectionException''.
  * ''hasScalarType(): bool'' - Returns true if the Enum has a scalar equivalent type.  False if not.
  * ''getScalarType(): ReflectionType'' - Returns the scalar equivalent type of the Enum, if any.  If it doesn't have one, it returns a ''ReflectionType'' on ''null''.

''ReflectionCase'' represents an individual Case in an enumeration.  It extends ''ReflectionConstant'' and stubs out irrelevant methods.  It also has the following methods:

  * ''getEnum(): ReflectionEnum'' - Returns a reflection of the Enum that contains the Case.
  * ''getScalar(): ?int|string'' - Returns the scalar equivalent value defined for the case, if defined.  If one is not defined, it returns ''null''.
  * ''getInstance(): Enum'' - Returns the singleton instance of the Case, as though it were read off of the Enum.

Additionally, a new function ''is_enum(mixed): bool'' returns true if the value passed is an enum or case object.

==== Examples ====

Below are a few examples of Enums in action.

=== Basic limited values ===

<code php>
enum SortOrder {
  case ASC;
  case DESC;
}

function query($fields, $filter, SortOrder $order = SortOrder::ASC) { ... }
</code>

The ''query'' function can now proceed safe in the knowledge that ''$order'' is guaranteed to be either ''SortOrder::ASC'' or ''SortOrder::DESC''.  Any other value would have resulted in a TypeError, so no further error checking or testing is needed.

=== Advanced Exclusive values ===

<code php>
enum UserStatus: string {
  case Pending = 'pending';
  case Active = 'active';
  case Suspended = 'suspended';
  case CanceledByUser = 'canceled';
  
  public function label(): string {
    return match($this) {
      static::Pending => 'Pending',
      static::Active => 'Active',
      static::Suspended => 'Suspended',
      static::CanceledByUser => 'Canceled by user',
    };
  }
}
</code>

In this example, a user's status may be one of, and exclusively, ''UserStatus::Pending'', ''UserStatus::Active'', ''UserStatus::Suspended'', or ''UserStatus::CanceledByUser''.  A function can type a parameter against ''UserStatus'' and then only accept those four values, period.

All four values have a ''label()'' method, which returns a human-readable string.  That string is independent of the "machine name" primitive equivalent string, which can be used in, for example, a database field or an HTML select box.

<code php>
foreach (UserStatus::cases() as $key => $val) {
  printf('<option value="%s">%s</option>\n', $key, $val->label());
}
</code>

==== New interfaces ====

As noted above, this RFC defines three additional internal interfaces.  These interfaces are available to make it possible for user code to determine if a given object is an enumeration, and if so what type.  User-defined classes may not implement or extend these interfaces directly.

<code php>

interface UnitEnum {
  public function cases(): array;
}

interface ScalarEnum {
  public static function from(int|string $scalar): static;
}
</code>

===== Backward Incompatible Changes =====

“enum” becomes a language keyword, with the usual potential for naming conflicts with existing global constants.

The global scoped internal interfaces ''Enum'', ''UnitEnum'', and ''ScalarEnum'' are defined.

===== Open questions =====

==== Attribute targets ====

Should Enums get their own ''TARGET_ENUM'' for attributes, or just be the same as ''TARGET_CLASS''?  Is that leaking an implementation detail?  Is that cutting off useful functionality (in either direction)?

Should Cases get their own ''TARGET_CASE'' for attributes, or just be the same as ''TARGET_CONSTANT''?  Is that leaking an implementation detail?  Is that cutting off useful functionality (in either direction)?

==== Reflection ====

Should ''ReflectionEnum'' extend ''ReflectionClass'' or be its own thing?

Should ''ReflectionCase'' extend ''ReflectionConstant'' or be its own thing?

===== Future Scope =====

See the [[rfc:adts|Algebraic data types (Meta RFC)]] document.

==== Grouped syntax ====

It would be possible, in the simple case, to allow multiple cases to be defined together, like so:

<code php>
enum Suit {
  case Hearts, Diamonds, Clubs, Spades;
}
</code>

That would only work on the simple, non-primitive-backed case with no methods defined.  Given that it is unclear how common that will be in practice, grouped syntaxes have a controversial history, and it's easy enough to add later if needed, we have omitted that shorthand at this time.

==== Enums as array keys ====

Because they are objects, enum cases may not be used as keys in an associative array.  It may be possible to support that in the future, but that is not covered at this time.  For now, SplObjectStorage and WeakMaps are good enough.

==== Enum Sets ====

An enum set is the logical OR of two other cases.  For instance, ''$red = Suit::Hearts | Suit::Diamonds''.  Those are not supported at this time.

Adding support for enum sets is a possibility for a future RFC, should an appropriate implementation be determined.

===== Voting =====

This is a simple yes/no vote to include Enumerations. 2/3 required to pass.

===== References =====

[[https://github.com/Crell/enum-comparison|Survey of enumerations supported by various languages, conducted by Larry]]