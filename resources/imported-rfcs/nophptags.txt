====== Disabling PHP tags by php.ini and CLI options ======
  * Version: 1.2
  * Date: 2012-04-09
  * Author: Moriyoshi Koizumi <moriyoshi@php.net> Yasuo Ohgaki <yohgaki@ohgaki.net>
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/nophptags
  * Other formats ..


This RFC proposes removal of PHP tags (''<?php'' and so forth) from the PHP script by php.ini or CLI option flags.

===== Background =====

PHP is an embedded language since it was born. To execute a PHP code, PHP tag is required and PHP tag is mandatory. Mandatory Embed mode was reasonable 10 years ago, but it became less reasonable with recent framework adoption. Mandatory embed mode has security issue known as LFI(Local File Include)/RFI(Remote File Include). The risk of LFI/RFI was reduced by null byte check in fopen wrapper and allow_url_include php.ini option.

LFI/RFI is fatal security error. Currently, LFI prevention is upto programmers and framework authors/system admins do not have feasible way to prevent LFI. It is preferred to have systematic approach for LFI. This RFC provides a protection for LFI risk. 

=== Mandatory Embed mode ＝ Less Security ===

Current PHP is weak to script injections compare to other languages such as Ruby/Perl/Phthon/Lua/etc. There are countermeasures allow_url_include=off and Null byte check in fopen wrapper, but injecting PHP scripts in a file is easy. Simple vulnerability in include()/require() could result in a fatal security incident.

PHP script inclusion detection may be done for data files. However, it's not a simple task.

  * <?, <% should be checked even if it's a binary. It's possible to have "<?" or "<%" in a binary. One should check if it contains a valid(executable) PHP script in it or not.
  * <script language="php"> should be checked. "<script language=" is common in HTML files. Checking "<script language=" is not a simple task.
  * Almost all applications are not checking these and it would be impossible to make developers do a proper validation.

Disabling embed(template) mode is simple solution for this issue.

Note: fopen wrapper invalidates null byte in path parameter. It reduced the LFI(Local File Include) risk greatly. This proposal aims to reduce the LFI risk to other scripting language level.

=== PHP script injection examples ===

== Novice Mistakes ==
Common novice PHP programmer mistake is writing code like

  include $_GET['name'];

Because PHP is embedded language and the nature of embedded language cannot be changed, this kind of code raises fatal security issues. Attacker may use any uploaded files without proper validations may be used to execute PHP code. Attacker may also be read any files with permissions.

Note: Please keep in mind that this RFC aims to reduce LFI risk without full knowledge of LFI. Not many people realizes that LFI may be used with SQL Injection and the Null Byte protection does not help at all for this case.

== Session Data ==
Many applications store user inputs in $_SESSION array and use files are session storage. If attacker can inject PHP script in $_SESSION array, all they have to do is find a vulnerable include()/require(). Session save_path could be guessed easily. 

Attacker may

  - Find LFI
  - Find a way to inject PHP script in $_SESSION
  - Guess session save_path
  - Take over target server

== Cached Data ==
Modern applications cache data into files for better performance. Since cache is only used by application, programmers do not care if it contains PHP code or not. Attacker may follow similar steps to execute attack script.

== Email ==
Some applications save email messages.

== Log Files ==
Errors are logged usually. 

== SQL injection ==
SQL injection is known to be able executing arbitrarily code by itself with certain configuration. With PHP's LFI, SQL injection may be used for arbitrarily code execution since many SQL database servers support writing data to a file.

  - Find SQL injection
  - Find means to inject PHP script into SQL data
  - Save SQL data into file
  - Use LFI to execute the code

Since attacker has **control of full file name**, Null Byte protection does not work at all.

When LFI and SQL Injection can be abused, attacker may steal data without blind SQL injection. Attacker may simply dump data into file and use LFI steal it. 

  - Find SQL injection
  - Save SQL data into file
  - Use LFI to steal data

It's much simpler than blind SQL injection. It may also be possible bypass certain IPS/IDS.

=== LFI is NOT only for execution ===

FLI does not have to be script execution due to current mandatory embedded language nature. 

  include $_REQUEST['var'];

Above code may be used to read sensitive data such as /etc/passwd, .htaccess, .htpasswd or any other file attacker may interested. 

=== Recent PHP usage ===

Since PHP was given birth by Rasmus Lerdorf as a tiny form interpreter for personal use, it has much evolved into a general-purpose scripting language, and is considered to be part of core technologies that are the basis of busiest websites to date.

The design of the language is comparable with its notable successors such as ASP (Active Server Pages) and JSP (Java Server Pages), in which one can easily build a dynamic web page by interleaving presentation elements with application logics, and it was well received by many developers who had to tackle with CGI at the time it got an attention.

However, as web application development got its way in the industry, it was discovered that MVC (model-view-controller) architecture, which effectively promotes the separation of concerns between the domain logic (models) and the presentation logic (views), could be the key concept of many kinds of web applications as well as GUI applications to build maintainable pieces of software.

At the same time, various web security issues became subject to public concern and the 'interleaving' method was pointed out to be too error-prone to create a secure website as it completely dismisses the context of the presentation elements where the application logic is inserted and so forces one to choose the correct escaping method suitable for putting the result of the logic in that place.

And today, many PHP programmers usually choose to use a web application framework that is based on MVC architecture and also takes advantage of modern template engines that feature handy syntax specific to describe common presentation logics. Not a few programmers may once have been bothered to put a PHP tag at the top of every PHP script that only contains classes and functions. This gives a choice to these users also.
===== Proposal =====

  * Add flag that controls embed(template) feature of PHP.

Flag to control embed (template) mode

php.ini

  template_mode = on   ; On by default. INI_ALL
                       ; On: "<?php" or like is requried.
                       ; Off: No open tag is required.

CLI

  php -t foo.php  # template mode. "<?php" is required. Default.
  php -T foo.php  # non-template mode. "<?php" is NOT required.

  * Allow users to start PHP statements from the top of the script without putting open tags such as ''<?php''.
  * Complete removal of esoretic ''<script lanuage="PHP">'' open tag.
  * Allow open tags (''<?php'', ''<?'', ''<%'') only at the top of the script for compatibility, and issue a parse error when used in other places.
  * Ignore close tags (''?>'' and ''%>'') completely.

===== Example Usage =====

==== Mode control ====

Modern frameworks have single bootstrap script and template rendering function.

In bootstrap script
  ini_set('template_mode', 'off'); // Older PHP ignores

In template rendering function
  function render_template($template, $template_vars) {
    ini_set('template_mode', 'on);  // Older PHP ignores
    // Do what ever required as template
    ini_set('template_mode', 'off');  // Older PHP ignores
  }

This piece of code work with/without this RFC. It would not be affected by php.ini, since it works for both template_mode=on/off.

==== Data File Validation ====

If file has certain header, header must be validated. If file is free format data, it's better to add header that causes syntax error with LFI.

To find out if a file contains PHP code, tokenizer may be used.

  $token = token_get_all($file);
  if (has_php_token($token)) {
     echo 'File has PHP token';
  }

Note that this method can be false positive. Complete solution is apply this RFC and make sure that all files has headers which cause syntax error with LFI.
===== Discussions =====

==== Why this is better than now? ====
  * With current behavior, programmers and auditors must be careful unexpected file inclusion because PHP can include anything for information disclosure and script execution. With this RFC and template_mode=off, programmers may limit place that could include file with embed mode. Therefore, it makes audit much easier hence script became more secure than without it.
  * Programmers can easily determine which file will be executed as PHP script. When template_mode=off, all PHP files treated as pure script files. 
    * For instance, embedding attack scripts in GIF "gif89a(some data)<?php exec('rm -rf /');?>" cannot be done. Since PHP does not have direct constant definition(i.e. const MYCONST;  const keyword is required) and variable is required start with $, no end tags, begin tag is allowed with RFC, it became very hard to make valid syntax for data files.
  * When attackers try to exploit LFI with template_mode=off, 
    * it must be a valid PHP script.
    * by making sure that files have valid data file heading, attackers are not able to exploit LFI. 
    * Including data files result in syntax errors almost all cases and will not result in information disclosure.

==== What is compatibility issues? ====
  * None when template_mode=on.
  * None for script begins with open tags regardless of template_mode. <?php, <?, <%
  * When template_mode=off, scripts do not begin with open tags are not be executed and exposed. Users are supposed to control template_mode in this case.
  * For MVC framework users, it should be simple task to adopt template_mode. template_mode=Off in bootstrap, template_mode=on and off is render method. It would be as few as 3 lines of changes.

==== What protection should be done for LFI with this? ====
  * When template_mode=on for all script, it's the same as now.
  * When template_mode=off in php.ini or bootstrap script,
    * enable template_mode only when it is absolutely required. 
    * validate data files if they contain valid header. (e.g. gif89a for GIF, etc)
    * if there are free format data files, programmer may add some header so that LFI causes syntax error.
  * Common protections
    * always add extension manually for include()/requires(). (i.e. Use null byte protection! Null byte protection requires 5.3.3> IIRC)
    * validate parameters contains only valid chars. (i.e. no "../")
    * validate parameters are not too long. (i.e. file names would not be too long such as "valid/path/../../../../../../../etc/passwd")
    * validate data file. (It would not help much without this RFC, but it should be done anyway.)
    * if you are using Unicode Normalization, you must know what you are doing.

==== A lot of effort will be needed to adopt template_mode?! ====
  * No. Users may stick to current behavior.
  * Even if users decided to adopt templat_mode=off, the changes that are required is a few as 3 lines. For modern frameworks, it would be simple task.


==== template_mode is similar to allow_url_include ====

  * allow_url_include: 
    * enable only when url include is needed.
    * prevents RFI which results in critical security incident.
  * template_mode:    
    * enable only when template mode is needed.
    * prevents LFI which results in critical security incident.

==== temlate_mode=off is safe guard ====

  * This is not an direct security mesure, but a safe guard for mitigation. 
  * Mitigation factor is large if programmer follow guideline.
  * Think it as canary protection for stack smashing or DEP for heap overflow.
  * Since LFI is critical, additional protections are preferred whenever possible. 

==== template_mode=off could be security issue ====

  * When template_mode=off, PHP script may be exposed.
    * Files contains open tag "<?php" or like at beginning, is treated as PHP script regardless of template_mode
    * Template files/legacy codes that do not have "<?php" or like on top, it will be exposed without proper code. This might be a issue.
      * PHP scripts that aren't be accessed by users should be located other than docroot. This is good practice without this RFC also.
      * PHP users are used to such case? since short tags were optional for a long time.


==== Motivation of this RFC ====
Motivation to have this RFC is

1. "File Includes" is fatal security breach.
2. The reason why PHP is unsecure to "File Include" than other
language is "Mandatory embed mode"
3. Non mandatory embed mode gives option users to better security.

With this RFC, PHP could be as safe as other scripting languages
with respect to file includes. This RFC is fully compatible with current
code. Writing backward compatible code is as few as 3 lines.

Most of security measures are not perfect solutions, but
mitigation, just like canary and DEP. I suppose people who are
concerned with security understand the value of these protections.

Is there any good reasons not to have non mandatory embed
mode as a additional security measure? Why not to make it harder
for attackers to exploit?

In short, I'm really annoyed to hear "PHP is insecure than
Ruby/Perl/Python/etc"

===== Issues yet to be resolved =====

  * php.ini flag and CLI options

===== Patch =====

https://gist.github.com/2266652

===== Changelog =====

   - 2012-04-01 Moriyoshi Koizumi: Initial.
   - 2012-04-09 Yasuo Ohgaki: Version 1.1. Made RFC a serious RFC. Added security issue discussion for embedded mode. Proposal for php.ini and CLI options.
   - 2012-04-10 Yasuo Ohgaki: Version 1.2. More examples.