====== Disabling PHP tags by php.ini and CLI options ======
  * Version: 1.2
  * Date: 2012-04-09
  * Author: Moriyoshi Koizumi <moriyoshi@php.net> Yasuo Ohgaki <yohgaki@ohgaki.net>
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/nophptags
  * Other formats ..


This RFC proposes removal of PHP tags (''<?php'' and so forth) from the PHP script by php.ini or CLI option flags.

===== Introduction =====

Compare to other languages such as Ruby/Perl/Phthon/Lua/etc, current PHP is known to be weak for script injections/information disclosure. This proposal aims to reduce the LFI risk to other scripting language level by optional embedded scripting mode.

PHP is an embedded language since it was born. To execute a PHP code, PHP tag is required and PHP tag is mandatory. Mandatory Embed mode was reasonable 10 years ago, but it became less reasonable with recent framework adoption. Mandatory embed mode has security issue known as LFI(Local File Include)/RFI(Remote File Include). The risk of LFI/RFI was reduced by null byte check in fopen wrapper and allow_url_include php.ini option.

LFI/RFI is fatal security error. Currently, LFI prevention is upto programmers and fatal FLI may happen anywhere in PHP script. It is preferred to have systematic approach to reduce LFI risk. This RFC provides a additional protection for LFI by making mandatory embedded mode optional. 

=== Mandatory Embed mode ＝ Less Security ===

There are countermeasures allow_url_include=off for RFI, Null byte check in fopen wrapper and open_basedir for LFI. However, injecting PHP code in a file is easy. Simple vulnerability in include()/require() could result in a fatal code execution and/or fatal information disclosure security incident.

PHP script inclusion detection may be done for data files. However, it's not a simple task.

  * <?, <% should be checked even if it's a binary. It's possible to have "<?" or "<%" in a binary. One should check if it contains a valid(executable) PHP script in it or not.
  * <script language="php"> should be checked. "<script language=" is common in HTML files. Checking "<script language=" is not a simple task.
  * Almost all applications are not checking these and it would be impossible to make developers do a proper validation.
  * File that are not controlled by PHP application cannot do anything.

Data files may be protected by injecting "<?php die()?>" into data files.
  * Data before <?php die() ?> may be disclosed.
  * It is possible to inject <?php die() ?> some data files like /etc/passwd, but it is not feasible.
  * Injecting <?php die() ?> to all data file is impossible. 

Disabling embedded(template) mode is simple protection against LFI.

Note: fopen wrapper invalidates null byte in path parameter. It reduced the LFI(Local File Include) risk greatly.

=== PHP script injection examples WITHOUT file uploads ===

Common novice PHP programmer mistake is writing code like

  include $_GET['name'];

Because PHP is embedded language and the nature of embedded language cannot be changed, this kind of code raises fatal security issues. Attacker may use any uploaded files without proper validations may be used to execute PHP code. Attacker may also be read any files with permissions.

Note: Please keep in mind that this RFC aims to reduce LFI risk without full knowledge of LFI. For example, not many people realizes that LFI may be used with SQL Injection and the Null Byte protection does not help at all for this case.

== Session Data ==
Many applications store user inputs in $_SESSION array and use files are session storage. If attacker can inject PHP script in $_SESSION array, all they have to do is find a vulnerable include()/require(). Session save_path could be guessed easily. 

Attacker may

  - Find LFI
  - Find a way to inject PHP script in $_SESSION
  - Guess session save_path
  - Take over target server

== Cached Data ==
Modern applications cache data into files for better performance. Since cache is only used by application, programmers do not care if it contains PHP code or not. Attacker may follow similar steps for session data exploitation to execute attack script.

== Email ==
Some applications save email messages. These message may be used for LFI.

== Log Files ==
Errors are logged usually. These logs may be used for LFI.

== SQL injection ==
SQL injection is known to be able executing arbitrarily code by itself with certain configuration. With PHP's LFI, SQL injection may be used for arbitrarily code execution since many SQL database servers support writing data to a file.

  - Find SQL injection
  - Find means to inject PHP script into SQL data
  - Save SQL data into file
  - Use LFI to execute the code

Since attacker has **control of full file name**, Null Byte protection does not work at all.

When LFI and SQL Injection can be abused, attacker may steal data without blind SQL injection. Attacker may simply dump data into file and use LFI steal it. 

  - Find SQL injection
  - Save SQL data into file
  - Use LFI to steal data

It's much simpler than blind SQL injection. It may also be possible bypass certain IPS/IDS.




==== Information disclosure example ====

All developers know how include('/etc/passwd) or include('.htaccess') works.

  include $_REQUEST['var'];

Above code may be used to read sensitive data such as /etc/passwd, .htaccess, .htpasswd or any other files attackers may interested. 

Note: open_basedir will not be set by default.
==== Related RFC ====

https://wiki.php.net/rfc/source_files_without_opening_tag
===== Proposal =====

  * Add flag that controls embed(template) feature of PHP.

Flag to control embed (template) mode

php.ini

  template_mode = on   ; On by default. INI_ALL
                       ; On: "<?php" or like is requried.
                       ; Off: No open tag is required.

CLI

  php -t foo.php  # template mode. "<?php" is required. Default.
  php -T foo.php  # non-template mode. "<?php" is NOT required.

  * When template_mode=off
    * Allow users to start PHP statements from the top of the script without putting open tags such as ''<?php''.
    * Complete removal of esoretic ''<script lanuage="PHP">'' open tag.
    * Allow open tags (''<?php'', ''<?'', ''<%'') only at the top of the script for compatibility, and issue a parse error when used in other places.
    * Ignore close tags (''?>'' and ''%>'') completely.

===== Example Usage =====

==== Mode control ====

Modern frameworks have single bootstrap script and template rendering function.

In bootstrap script
  ini_set('template_mode', 'off'); // Older PHP ignores

In template rendering function
  function render_template($template, $template_vars) {
    ini_set('template_mode', 'on);  // Older PHP ignores
    // Do what ever required as template
    ini_set('template_mode', 'off');  // Older PHP ignores
  }

This piece of code work with/without this RFC. It would not be affected by php.ini, since it works for both template_mode=on/off.

==== Data File Validation ====

If file has certain header, header must be validated. If file is free format data, it's better to add header that causes syntax error with LFI.

To find out if a file contains PHP code, tokenizer may be used.

  $token = token_get_all($file);
  if (has_php_token($token)) {
     echo 'File has PHP token';
  }

Note that this method can be false positive. Complete solution is apply this RFC and make sure that all files have headers which cause syntax error with LFI.
===== Discussions =====

==== Motivation of this RFC ====
Motivation to have this RFC is

  - "File Includes" is fatal security breach.
  - The reason why PHP is unsecure to "File Include" than other language is "Mandatory embed mode"
  - Non mandatory embed mode gives option users to better security.

With this RFC, PHP could be as safe as other scripting languages
with respect to file includes. This RFC is fully compatible with current
code. Writing backward compatible code is as few as 3 lines.

Most of security measures are not perfect solutions, but
mitigation, just like canary and DEP. I suppose people who are
concerned with security understand the value of these protections.

Is there any good reasons not to have non mandatory embed
mode as a additional security measure? Why not to make it harder
for attackers to exploit?

In short, I'm really annoyed to hear "PHP is insecure than
Ruby/Perl/Python/etc"

==== Why this is better than now? ====
  * **Framework authors**
    * Framework developers will have effective protection against suicide code like "include $_REQUEST['var'];" in user scripts.
    * If framework adopts template_mode=off, the suicide code above will raise syntax errors for LFI code execution and information disclosure attack patterns.
      * Note: If the file is valid PHP code, it's possible executing code. However, the risk is the same or less compare to Ruby/Perl/Python/etc. 
    * It could be as few as 3 lines to adopt template_mode=off.
    * Framework developers are not required to rewrite include/require statements.
    * Framework can be compatible with older PHP.
    * Fully compatible with current code. (template_mode=on)
    * Mostly compatible with current code. (template_mode=off)
      * <?php,<?,<% is allowed regardless of tempalte_mode for maximum compatibility.

  * **Programmers**
    * Programmers don't have to do nor know anything, if their framework adopt template_mode=off. 
    * No new syntax nor parameter. 
    * All files treated as PHP script only files. (template_mode=off) 
      * Programmers can easily determine which file will be executed as PHP script. 
      * Embedding script attack scripts became impossible.
        * Open tag is only allowed at the beginning of file.
        * No close tag is allowed with template_mode=off.
      * Including non PHP scripts will result in syntax errors almost always. 
        * inlcude('/etc/passwd'), include('config/secrete.yml'), include('uploadded_image/attack.jpg') and so on.
      * Programmers can have confidence locating uploaded data files(image/documents/etc) under docroot for better performance. 
        * FLI can be done w/o uploaded file, but abuse of uploaded file is common attack pattern.
 
  * **Attackers**
    * When attackers try to exploit LFI with template_mode=off, 
      * attack file must be a valid PHP script.
      * making a valid attack file is vary difficult
        * attacker cannot execute script.
        * attacker cannot steal data/information.

  * **Auditors, Managers and Decision makers**
    * Codes that have to be audited with extreme care will be reduced.
    * Even if there are vulnerable piece of code, it became very difficult to exploit it.
    * Decision maker that worries about infamous PHP LFI will not against adopting PHP anymore.

The only looser is attacker here. If you think of drawback that exceeds these benefits, please let me know. yoghaki@ohgaki.net
==== What is compatibility issues? ====
  * No new syntax or parameters. Only template_mode ini entry.
  * None when template_mode=on. (The default)
  * None for script begins with open tags regardless of template_mode. <?php, <?, <%
  * When template_mode=off, include()/requrie() execute file as scripts. For embedded pages, users are supposed to control template_mode.
  * For framework developers, it should be simple task to adopt template_mode. template_mode=Off in bootstrap, template_mode=on and off is render method. It would be as few as 3 lines of changes.
  * For framework users, they don't even have to know the change and still get benefits if framework supports this.

==== What protection should be done for LFI with this? ====
  * When template_mode=on for all script, it's the same as now.
    * For all data files, insert <?php die() ?> where it is possible. It should be inserted at beginning of file as much as possible.
    * Previous requirement is almost impossible since PHP may read any file with permission. (e.g. inserting <?php die() ?> in /etc/passwd is possible, but it is not feasible obviously. )
  * When template_mode=off in php.ini or bootstrap script,
    * enable template_mode only when it is absolutely required. 
    * validate data files if they contain valid header. (e.g. gif89a for GIF, etc)
    * if there are free format data files, programmer may add some header so that LFI causes syntax error.
  * Common protections
    * always add file extension manually for include()/require(). (i.e. Use null byte protection! Null byte protection requires 5.3.3> IIRC)
    * validate parameters contains only valid chars. (i.e. no "../")
    * validate parameters are not too long. (i.e. file names would not be too long such as "valid/path/../../../../../../../etc/passwd")
    * validate data file. (It would not help much without this RFC, but it should be done anyway.)
    * if you are using Unicode Normalization, you must know what you are doing.

==== A lot of effort will be needed to adopt template_mode?! ====
  * No. Users may stick to current behavior. Current behavior(template_mode=on) is the default.
  * Even if users decided to adopt templat_mode=off, the changes that are required is a few as 3 lines. For modern frameworks, it would be simple task.


==== template_mode is similar to allow_url_include ====

  * allow_url_include: 
    * enable only when url include is needed.
    * prevents RFI which results in critical security incident.
  * template_mode:    
    * enable only when template mode is needed.
    * prevents LFI which results in critical security incident.

==== template_mode=off is safe guard ====

  * This is not an direct security mesure, but a safe guard for mitigation. 
  * Mitigation factor is large if programmer follow guideline.
  * Think it as canary protection for stack smashing or DEP for heap overflow.
  * Since LFI is critical, additional protections are preferred whenever possible. 

==== template_mode=off could be security issue ====

  * When template_mode=off, PHP script may be exposed.
    * Files contains open tag "<?php" or like at beginning, is treated as PHP script regardless of template_mode
    * Template files/legacy codes that do not have "<?php" or like on top, it may be exposed without proper code.  It will result in syntax errors mostly since it does not allow close tags "?>". However, this might be a issue still.
      * PHP scripts that aren't be accessed by users should be located other than docroot. This is good practice without this RFC also.
      * PHP users are used to such case(?) since short tags were optional for a long time.




===== Issues yet to be resolved =====

  * php.ini flag and CLI options

===== Patch =====

https://gist.github.com/2266652

===== Changelog =====

   - 2012-04-01 Moriyoshi Koizumi: Initial.
   - 2012-04-09 Yasuo Ohgaki: Version 1.1. Made RFC a serious RFC. Added security issue discussion for embedded mode. Proposal for php.ini and CLI options.
   - 2012-04-10 Yasuo Ohgaki: Version 1.2. More examples.