====== PHP RFC: Short Closures 2.0 ======
  * Version: 2.0
  * Date: 2022-05-25
  * Author: Nuno Maduro (enunomaduro@gmail.com)
  * Author: Larry Garfield (larry@garfieldtech.com)
  * Author: Arnaud Le Blanc (arnaud.lb@gmail.com)
  * Status: In Discussion
  * First Published at: http://wiki.php.net/rfc/auto-capture-closure

===== Introduction =====

Anonymous functions in PHP can be verbose, in part due to the need to manually import used variables. This makes code using simple closures hard to read and understand.

[[rfc:arrow_functions_v2|Arrow Functions]] were introduced in PHP 7.4 as an alternative. However, the single-expression limitation can lead to complex one-liners, or makes Arrow Functions unfit in many use-cases that would benefit from a more concise syntax.

This RFC proposes an extension of the Arrow Function syntax supporting multiple statements:

<code php>
$guests = array_filter($users, fn ($user) {
    $guest = $repository->findByUserId($user->id);
    return $guest !== null && in_array($guest->id, $guestsIds);
});
</code>

===== Proposal =====

Short Closures follow the basic form of Arrow Functions, with multiple statements enclosed in ''{'' and ''}'' instead of a single expression:

<code php>
fn(parameter_list) {
    statement_list
}
</code>

The ''statement_list'' is a sequence of statements separated by semicolons. A ''return'' statement must be used to return a value.

The syntax and behavior otherwise match those of Arrow Functions.

==== Auto capture by-value ====

Like Arrow Functions, Short Closures use auto capture by-value. When a variable used in the Short Closure is defined in the parent scope it will be automatically captured by-value. In the following example the functions $fn1, $fn2, and $fn3 behave the same:

<code php>
$y = 1;

$fn1 = fn($x) => $x + $y;

$fn2 = fn($x) {
    return $x + $y;
};

$fn3 = function ($x) use ($y) {
    return $x + $y;
};
</code>

==== Explicit capture ====

Short Closures support optional explicit capture with the ''use'' keyword. Auto capture and explicit capture can coexist in the same function declaration.

<code php>
$c = 1;
fn() use ($a, &$b) {
    return $a + $b + $c; // $a is explicitly captured by value
                         // $b is explicitly captured by reference
                         // $c is auto-captured by value
}
</code>

This allows Short Closures to match Anonymous Functions in functionality. Without this, it would be necessary to switch back and forth between the syntaxes when capturing by-reference is needed. We expect that explicitly capturing by value will be rare in practice.

==== Syntax ====

The signature accepts the same syntax as that of Arrow Functions:

<code php>
fn()
fn($a, $b)
fn(...$args)
fn(int $a): string
fn&($a)
fn(&$a)
</code>

Additionally, the explicit capture syntax of Anonymous Function can be used in Short Closures:

<code php>
fn() use ($a)
fn() use (&$a)
</code>

The signature must be followed by ''{'', a statement list, and ''}'':

<code php>
fn() { return 1; }
fn() { print 1; }
fn() {
    $tmp = $a + $b;
    return $tmp;
}
</code>

Note that Short Closures do not have an implicit return value. A ''return'' statement must be used to return a value.

The syntax choice here are consistent with other language constructs:

  * ''{ ... }'' denotes a statement list, without implicit return value.
  * Conversely, the ''=>'' token (not used in Short Closures) is followed by an expression in all circumstances.  (Arrow Functions, arrays, and ''match()''.)
  * The ''fn'' keyword indicates a function that will auto-capture variables, by-value.
  * The ''function'' keyword indicates a function that has no auto-capture.

These rules are easily recognizable and learnable by developers.

===== Why extend Arrow Functions? =====

Arrow Functions were added as an alternative to Anonymous Functions. The later can be quite verbose, even when they only perform a simple operation. This is due to a large amount of syntactic boilerplate that is needed to manually import used variables with the ''use'' keyword.

While Arrow Functions solve this problem to some extent, the one-expression limit can lead to one-liners with non ideal readability, or can make them unfit for some use-cases. There are ample cases where breaking an expression to 2-3 statements is required or would improve the legibility of the code.

As an example, writing the following code snipet with a single-expression Arrow Function would degrade legibility, but writing it as an Anonymous Function would be cumbersome:

<code php>
$guests = array_filter($users, fn ($user) {
    $guest = $repository->findByUserId($user->id);
    return $guest !== null && in_array($guest->id, $guestsIds);
});
</code>

==== Homogeneous syntax ====

Short Closures combine the features of Anonymous Functions and Arrow Functions in a single syntax.

Projects willing to reduce the number of language constructs used in their codebase to improve homogeneity or reduce cognitive overhead could opt for Short Closures as a single syntax over Anonymous Functions and Arrow Functions.

===== Discussion on auto-capture =====

Auto capture was first introduced by Arrow Functions.

In the past, there had been reticence about auto-capture that has kept it out of evolutions in closures.  Mostly that has boiled down to a few concerns: Implementation difficulties, performance, and debugability.

Implementation difficulties arise from by-reference or by-variable semantics, especially when supporting dynamic means of accessing variables like variable-variables, compact(), or eval(). In this proposal and in Arrow Functions, the implementation difficulties are eliminated by using by-value semantics and requiring dynamically accessed variables to be captured explicitly.

As noted in the benchmarks section, the implementation offered here has effectively no performance impact either way.

In the majority of cases where closures are used in practice, the code involved is short enough that debugging is not hampered by automatic capture.  They are usually only a few lines long, easily small enough to fit into a developer's short term memory while reading it.  What variables are captured is visually self-evident. 

Potential confusing behavior is further mitigated by PHP's (correct) use of by-value capture, which minimizes the potential for inadvertent confusing changes to values from closures.

Furthermore, as noted PHP is unusual in requiring explicit capture.  The only other language that does so is C++.  Most languages get along fine without that extra step.

For those few cases in which, for whatever reason, the developer is concerned about auto-capture reducing debugability or about accidental capture, the existing explicit-only syntax remains valid and unchanged.

==== Using variables from the parent block ====

Using variables from the parent block is not unusual in PHP. We do it all the time in loops.

In the following example, the loop uses three variables from the parent block. We have learned to recognize that what follows a ''foreach'', ''for'', or ''while'' keyword can do that.

<code php>
$guests = [];
foreach ($users as $user) {
    $guest = $repository->findByUserId($user->id);
    if ($guest !== null && in_array($guest->id, $guestsIds)) {
        $guests[] = $guest;
    }
}
</code>

In the following example, the function uses two variables from the parent block, which should not be more surprising than with a loop once we have learned that what follows a ''fn'' keyword can do that, like we did with ''foreach''.

<code php>
$guests = array_filter($users, fn ($user) {
    $guest = $repository->findByUserId($user->id);
    return $guest !== null && in_array($guest->id, $guestsIds);
});
</code>

However the comparison stops here. These two examples do not behave equally with regard to side effects: Variable assignments to the ''$guest'' and ''$user'' variables in the loop can be observed after the loop, but the same is not true with the Short Closure.

==== Capture is by-value ====

It is important to note that the default capture mode in Anonymous Functions, Arrow Functions, and Short Closures is by-value. This purposefully differs from the semantics commonly found in programming languages.

A by-value capture means that it is not possible to modify any variables from the outer scope:

<code php>
$a = 1;
$f = fn () {
    $a++; // Has no effect outside of the function
};

print $a; // prints "1"
$f();
print $a; // prints "1" (again)
</code>

Conversely, the outer scope can not modify variables in the function:

<code php>
$a = 1;
$f = fn () {
    print $a;
};

$f();     // prints "1"
$a = 2;
$f();     // prints "1" (again)
</code>

Because variables are bound by-value, the confusing behaviors often associated with closures do not exist. As an example, the following code snippet demonstrates such a behavior in Javascript:

<code javascript>
// Javascript
var fns = [];
for (var i = 0; i < 3; i++) {
    fns.push(function() {
        console.log(i);
    });
}
for (var k in fns) {
    var fn = fns[k];
    fn(); // Prints "3", "3", "3"
}
</code>

In PHP the behavior is intuitive and less confusing:

<code php>
// PHP
$fns = [];
for ($i = 0; $i < 3; $i++) {
    $fns[] = fn() {
        print $i;
    };
}
foreach ($fns as $fn) {
    $fn(); // Prints "0", "1", "2"
}
</code>

In Javascript the same output can be obtained by declaring ''i'' with the ''let'' keyword. Using the ''var'' keyword, and loops, is largely discouraged. However ''i'' is still captured by-variable (not to be confused with by-value), so the anonymous functions can still modify the value of ''i''. A different behavior can be obtained by with the ''const'' keyword.

In PHP, the variable is captured by-value, thus entirely avoiding the confusion.

==== No unintended side-effects ====

Because variables are captured by-value, Short Closures can not have unintended side effects. Specifically, assigning to variables does not have an effect outside of the function.

Like Anonymous Functions, Short Closures can have a side effect when desired by explicitly capturing a variable by-reference, or by accessing objects.

In the following example, the functions ''$fn1'' and ''$fn2'' have the same behavior:

<code php>
$a = 1;
$b = 2;

$fn1 = fn () {
    $a++;           // No effect outside of the function
    $tmp = $a + $b; // No effect outside of the function
    return $tmp;
}

$fn2 = function () use ($a, $b) {
    $a++;           // No effect outside of the function
    $tmp = $a + $b; // No effect outside of the function
    return $tmp;
}
</code>

The following example demonstrates how functions can have side effects:
<code php>
$a = 1;
$b = new DateTime();

$fn1 = fn () use (&$a) {
    $a++;                  // Modifies $a in parent block because $a is explicitly captured by-reference
    $b->modify('+ 1 day'); // Has an effect on the object bound to $b
}

$fn2 = function () use (&$a) {
    $a++;                  // Modifies $a in parent block because $a is explicitly captured by-reference
    $b->modify('+ 1 day'); // Has an effect on the object bound to $b
}
</code>

===== Auto-capture semantics =====

Short Closures follow the semantics of Arrow Functions: Only the variables that are accessed literally in the closure are auto-captured. This excludes dynamic means of accessing variables, such as the variable-variable syntax.

As an optimization, variables that are always assigned by the function before being read are not captured, since this is not needed. This differs from Arrow Functions (which rarely assign to a value, so that situation does not come up).

This optimization has marginal effects aside from performance. Specifically, it can affect the lifetime of objects, and consequently the time at which an object destructor is called. This is because some objects may not be captured if they are never used by the function, thus their lifetime will not be extended.

We can express these semantics more succinctly like this: Short Closures capture the variables that are used literally by the closure.

==== Implementation details ====

Auto-capturing all variables used literally in the function body will commonly capture too many variables. In the following example, the variable ''$tmp'' would be captured although this is not necessary because it is always assigned before being read (remember that variable assignments do not have an effect outside of the closure).

<code php>
$tmp = 5;
fn() {
    $tmp = foo();
    bar($tmp);
    return $tmp;
}
</code>

A naive capture analysis would unnecessarily capture ''$tmp'', resulting in wasted memory usage.

The capture analysis used in this RFC will only capture the variables that may be read before being assigned by the function. This uses the Optimizer's implementation of [[https://en.wikipedia.org/wiki/Live-variable_analysis|live-variable analysis]].

In practice, Short Closures end up capturing the same set of variables an Anonymous Functions with manually curated capture list would have captured. This was observed on the PHPStan code base by converting all Anonymous Functions to Short Closures, and looking at which variables was automatically captured after that.

This retains the semantics described earlier, so an understanding of these semantics is enough to reason about Short Closures.

===== Benchmarks =====

In benchmarks, the implementation in the 1.0 version of this RFC showed a notable CPU and memory increase when using auto-capturing multi-statement closure in some cases.

The 2.0 version, proposed here, has only marginal impact compared to PHP 8.1, well within the margin of error for profiling tools. In some cases the profiling run shows the Short Closure version being slightly more performant, which is likely just random test jitter between runs.  We therefore conclude that the performance impact of this approach is effectively zero.

The capture analysis approach described above makes Short Closures as efficient as Anonymous Functions.

For more benchmark details, see: https://gist.github.com/arnaud-lb/d9adfbf786ce9e37c7157b0f9c8d8e13

===== What about Anonymous Functions? =====

The existing Anonymous Function syntax remains valid, and there is no intent to deprecate it.

===== Multi-line expressions =====

There has been related discussion of multi-line expressions, specifically in the context of ''match()'' arms.  We considered whether multi-line expressions made sense as an alternative approach, but decided against it as that introduces considerably more edge cases both syntactically and in the engine.

As a side benefit, the syntax proposed here does offer a somewhat round-about way to have a multi-line ''match()'' arm.  This is not a deliberate feature of the RFC, but more of a convenient side-effect noted here for completeness.

<code php>
$b = ...;
$c = ...;
$ret = match ($a) {
  1, 3, 5 => (fn() {
    $val = $a * $b;
    return $val * $c;
  })(),
  2, 4, 6 => (fn() {
    $val = $a + $b;
    return $val + $c;
  })(),
};
</code>

While sub-optimal, it may be sufficient for the few times that a multi-statement ''match()'' arm is needed.

===== Comparison to other languages =====

As far as we are aware, only two languages in widespread use require variables to be explicitly closed over: PHP and C++.  All other major languages capture implicitly, as is proposed here.

Languages commonly capture by-variable (not to be confused with by-value) or by reference. In practice this can lead to confusing effects, especially in loops. For that reason, PHP defaults to capturing by-value, which avoids this problem. This is discussed above in this RFC, as well as in [[rfc:arrow_functions_v2#binding_behavior|Arrow Functions]].

===== History =====

The [[https://externals.io/message/28399|first discussion]] around Anonymous Functions was objected because of the lack of closures: It would be unusual for anonymous functions to not support closures, which would surprise users and it would limit their usefulness. At the same time, objections against closures cited implementation difficulties and performance issues, as well as potential complexity or pitfalls commonly found in closure implementations.

A solution was proposed to use explicit capture with a new keyword, ''lexical'', close in many aspects to the ''global'' keyword. Alternative syntaxes was later proposed that would allow to chose between by-reference and by-value capture, ultimately leading to the current ''use($x)'' syntax.

It is unclear whether this was chosen because of technical concerns or because of semantics. Specifically, objections to closures focused on semantics appeared to assume the behavior most commonly found in closure implementations, which is not what the current RFC is proposing. Most notably, objections cite the possibility of a kind of side-effects that would not exist with by-value capture. Discussions didn't appear to occur in the light of by-value semantics.

The [[rfc:short_closures|Short Closures 1.0]] RFC was declined for three main reasons: The syntax, the lack or type hints, and implicit capture. Objections to implicit closures appear to be based on semantics that do not exist in the current RFC.

The [[rfc:arrow_functions_v2|Arrow Functions 2.0]] RFC was accepted with a large majority. Compared to the Short Closures 1.0 RFC, it addressed the syntax and type hints concerns, limited the body to only one expression, and keeps implicit closure by-value.

===== Backward Incompatible Changes =====

None.

===== Proposed PHP Version(s) =====

PHP 8.2.

===== Open Issues =====

None.

===== Unaffected PHP Functionality =====

Existing function syntaxes continues to work precisely as they do now.  Only new combinations are possible.

===== Proposed Voting Choices =====

This is a simple Yes/No vote, requiring 2/3 to pass.

===== Patches and Tests =====

Pull Request: https://github.com/php/php-src/pull/8330

===== Implementation =====
After the project is implemented, this section should contain 
  - the version(s) it was merged into
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature
  - a link to the language specification section (if any)

===== References =====
[[rfc:short-functions|PHP RFC: Short Functions]]
[[rfc:arrow_functions_v2|PHP RFC: Arrow Functions]]
[[rfc:short_closures|PHP RFC: Short Closures 1.0]]

===== Changelog =====

2.0: Updated for new patch; reduced discussion of short-function RFC and related topics; expanded discussion of the capture rules and noted benchmarks showing minimal performance impact; renamed to "Short Closures 2.0"
