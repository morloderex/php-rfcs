====== PHP RFC: Change the edge case of round() ======
  * Version: 0.4.0
  * Date: 2023-10-23
  * Author: Saki Takamachi, saki@sakiot.com
  * Status: Under Discussion
  * First Published at: https://wiki.php.net/rfc/change_the_edge_case_of_round

===== Introduction =====
round() can specify the operating mode when edge case values ​​such as HALF_UP and HALF_DOWN are passed. For example,  0.285 is internally 0.28499999999999998. Should this be considered an edge case? Or is it not an edge case? Regarding this issue, in 2008, the following RFC adopted the policy that 0.285 is considered an edge case.
https://wiki.php.net/rfc/rounding

However, there is an opinion that it is wrong to expect decimal-like behavior because FP is just FP. Since 0.28499999999999995 to 0.28500000000000000 are all the same IEEE754 internal representation, and most of their values ​​are less than 0.285, it is unreasonable to treat them as edge cases.

==== About the current implementation ====

Here are excerpts from the RFC that determined the current implementation policy that are particularly relevant in this context.

<blockquote>
If the requested number of places to round the number is smaller than the precision of the number, then the number will be first rounded to its own precision and then rounded to the requested number of places.

Example: Round 1.255 to 2 places precision, expected value is 1.26. First step: Calculate 10^places = 10^2 = 100. Second step: Calculate 14 - floor(log10(value)) = 14 - 0 = 14 which indicates the number of places after the decimal point which are guaranteed to be exact by IEEE 754. Now, 2 < 14, so the condition applies. So, calculate 10^14 and multiply the number by that: 1.255 * 1e14 = 125499999999999.984375... Now, round that number to integer, i.e. 125500000000000. Now, divide that number by 10^(14 - 2) = 10^12 (the difference) and get 125.5 (exact). NOW round that number to decimal which yields 126 and divide it by 10^2 = 100 which gives 1.26 which is the expected result for that rounding operation.

Of course, one may argue that pre-rounding is not necessary and that this is simply the problem with FP arithmetics. This is true on the one hand, but the introduction of the places parameter made it clear that round() is to operate as if the numbers were stored as decimals. We can't revert that and this seems to me to be the best solutions for FP numbers one can get.
</blockquote>

In other words, due to the presence of the second parameter, the user expects round() to behave as if it were dealing with a decimal number.

By the way, the double rounding method has side effects and can lead to incorrect results. It will need to be fixed regardless of the outcome of this RFC. I have already created a PR to correct the issue in accordance with PHP current policy. If this RFC is rejected, this PR will be adopted.
https://github.com/php/php-src/pull/12268

We can discuss this RFC without getting caught up in the technical issues of whether it is feasible.

==== Arguments against current implementation ====

FP is not a decimal number. When we treat FP "like" a decimal number, it is not an exact value, but an approximation with some error range. The following six numbers are all 3fd23d70a3d70a3d in IEEE754 representation.

<code>
0.28499999999999995
0.28499999999999996
0.28499999999999997
0.28499999999999998
0.28499999999999999
0.28500000000000000
</code>

Since this range does contain 0.28500000000000000, we could consider it to be 0.28500000000000000, but that would ignore the fact that the remaining five values ​​are less than 0.285.

And for users who want to round 0.28499999999999998 correctly, such behavior is a bug.

==== round() is the only one that handles FP like this ====

Now look at the following code.

<code>
var_dump(0.1 + 0.2 === 0.3);
</code>

You'll soon see that this becomes false. However, treating FP as a decimal number means that the above code must be true. I think you can understand that  is strange. There is no reason why only round() should behave as a decimal.

==== Expecting FP to behave like "FP" ====

Even if we treat FP like a decimal number, we should use the value that is closest to it, and not a value that is "just within the range" that is on the boundary with the next value. 

And if we expect FP to behave like a decimal number in round(), we should expect similar behavior for all FPs in PHP. We need to avoid inconsistent implementations where only certain features behave exceptionally.

==== If we want to calculate as a decimal number ====

See warnings on this page.
https://www.php.net/manual/en/language.types.float.php

It can be seen that PHP's policy is not to require FP to behave as a decimal number. And as it says in the warning, if we want to calculate as a decimal number, we should use BCMath.

==== Reference: For other languages ====

Similar to PHP, we investigated languages ​​that allow you to specify the precision you want to round.

Ruby:
<code>
p 0.285.round(2)
// 0.29

p 0.28499999999999998.round(2)
// 0.29
</code>

Python:
<code>
// Python rounds to even numbers, so 0.285 cannot be compared. Instead, I use 1.555, which is also 1.5549... due to the FP error.

print(round(1.555, 2))
// 1.55

print(round(1.5549999999999999, 2))
// 1.55
</code>

==== Reference: Databases ====

MySQL:
<code>
mysql> SELECT ROUND(0.285, 2);
+-----------------+
| ROUND(0.285, 2) |
+-----------------+
|            0.29 |
+-----------------+
</code>

PostgreSQL:
<code>
postgres=# SELECT ROUND(0.285, 2);
 round 
-------
  0.29
</code>

SQLite3:
<code>
sqlite> SELECT ROUND(0.285, 2);
0.29
</code>

Firebird:
<code>
SQL> SELECT ROUND(0.285, 2) FROM RDB$DATABASE;

                ROUND 
===================== 
                0.290 
</code>

SqlServer:
<code>
1> SELECT ROUND(0.285, 2);
2> go
     
-----
 .290
</code>

===== Proposal =====
This RFC proposes changes that will cause round() to stop expecting decimal behavior to FP and start expecting FP to behave as FP.

<code>
// previous behavior
var_dump(round(0.285, 2)); // float(0.29)

// new behavior
var_dump(round(0.285, 2)); // float(0.28)
</code>

===== Backward Incompatible Changes =====
Regarding edge case determination for round(), some values ​​will no longer be determined as edge cases.

===== Proposed PHP Version(s) =====
next PHP 8.x (Currently the target is 8.4)

===== RFC Impact =====
==== To SAPIs ====
None.

==== To Existing Extensions ====
Only "standard" is affected.

==== To Opcache ====
No impact.

==== New Constants ====
None.

==== php.ini Defaults ====
None.

===== Open Issues =====
None.

===== Unaffected PHP Functionality =====
There is no effect on anything other than "standard".

===== Future Scope =====
None.

===== Proposed Voting Choices =====
We will probably vote for or against adding these functions. This requires 2/3 majority.

===== Implementation =====
https://github.com/php/php-src/pull/12291

===== References =====
https://wiki.php.net/rfc/rounding
https://github.com/php/php-src/pull/12268
https://externals.io/message/121297

===== Rejected Features =====
None.