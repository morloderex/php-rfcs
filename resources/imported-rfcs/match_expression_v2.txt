====== PHP RFC: Match expression v2 ======

  * Date: 2020-05-16
  * Author: Ilija Tovilo, tovilo.ilija@gmail.com
  * Status: Under discussion
  * Target Version: PHP 8.0
  * Implementation: https://github.com/php/php-src/pull/5371
  * Supersedes: https://wiki.php.net/rfc/match_expression

===== Proposal =====

This RFC proposes adding a new ''%%match%%'' expression that is similar to ''%%switch%%'' but with safer semantics and the ability to return values.

<code php>
$expressionResult = match ($condition) {
    1, 2 => foo(),
    3, 4 => bar(),
    default => baz(),
};
</code>
===== Differences to switch =====

==== Return value ====

It is very common that the ''%%switch%%'' produces some value that is used afterwards.

<code php>
switch (1) {
    case 0:
        $y = 'Foo';
        break;
    case 1:
        $y = 'Bar';
        break;
    case 2:
        $y = 'Baz';
        break;
}

echo $y;
//> Bar
</code>
It is easy to forget assigning ''%%$y%%'' in one of the cases. It is also visually unintuitive to find ''%%$y%%'' declared in a deeper nested scope. ''%%match%%'' is an expression that evaluates to the result of the executed arm. This removes a lot of boilerplate and makes it impossible to forget assigning a value in an arm.

<code php>
echo match (1) {
    0 => 'Foo',
    1 => 'Bar',
    2 => 'Baz',
};
//> Bar
</code>
==== No type coercion ====

The ''%%switch%%'' statement loosely compares (''%%==%%'') the given value to the case values. This can lead to some very surprising results.

<code php>
switch ('foo') {
    case 0:
      echo "Oh no!\n";
      break;
}
</code>
The ''%%match%%'' expression uses strict comparison (''%%===%%'') instead. The comparison is strict regardless of ''%%strict_types%%''.

<code php>
echo match ('foo') {
    0 => "Never reached\n",
};
</code>
==== No fallthrough ====

The ''%%switch%%'' fallthrough has been a large source of bugs in many languages. Each ''%%case%%'' must explicitly ''%%break%%'' out of the ''%%switch%%'' statement or the execution will continue into the next ''%%case%%'' even if the condition is not met.

<code php>
switch ($pressedKey) {
    case Key::RETURN_:
        save();
        // Oops, forgot the break
    case Key::DELETE:
        delete();
        break;
}
</code>
This was intended to be a feature so that multiple conditions can execute the same block of code. It is often hard to understand if the missing ''%%break%%'' was the authors intention or a mistake.

<code php>
switch ($x) {
    case 1:
    case 2:
        // Same for 1 and 2
        break;
    case 3:
        // Only 3
    case 4:
        // Same for 3 and 4
        break;
}
</code>
The ''%%match%%'' expression resolves this problem by adding an implicit ''%%break%%'' after every arm. Multiple conditions can be comma-separated to execute the same block of code. There’s no way to achieve the same result as 3 and 4. This feels natural because the body of a match arm can only contain a single expression.

<code php>
echo match ($x) {
    1, 2 => 'Same for 1 and 2',
    3, 4 => 'Same for 3 and 4',
};
</code>
==== Exhaustiveness ====

Another large source of bugs is not handling all the possible cases supplied to the ''%%switch%%'' statement.

<code php>
switch ($configuration) {
    case Config::FOO:
        // ...
        break;
    case Config::BAR:
        // ...
        break;
}
</code>
This will go unnoticed until the program crashes in a weird way, causes strange behavior or even worse becomes a security hole. Many languages can check if all the cases are handled at compile time or force you to write a ''%%default%%'' case if they can’t. For a dynamic language like PHP the only alternative is throwing an error. This is exactly what the ''%%match%%'' expression does. It throws an ''%%UnhandledMatchError%%'' if the condition isn’t met for any of the arms.

<code php>
$y = match ($x) {
    1 => 'Foo',
    2 => 'Bar',
};

// Only reached if $x is 1 or 2
// $y is 'Foo' or 'Bar'
</code>
===== Miscellaneous =====

==== Arbitrary expressions ====

A match condition can be any arbitrary expression. Analogous to ''%%switch%%'' each condition will be checked from top to bottom until the first one matches. If a condition matches the remaining conditions won’t be evaluated.

<code php>
$y = match ($x) {
    foo() => ...,
    $this->bar() => ..., // bar() isn't called if foo() matched with $x
    $this->baz => ...,
    // etc.
};
</code>
===== Future scope =====

==== Blocks ====

In this RFC the body of a match arm must be an expression. Blocks for match and arrow functions will be discussed in a separate RFC.

==== Pattern matching ====

[[https://github.com/php/php-src/compare/master...iluuu1994:pattern-matching|I have experimented with pattern matching]] and decided not to include it in this RFC. Pattern matching is a complex topic and requires a lot of thought. Each pattern should be discussed in detail in a separate RFC.

==== Allow dropping (true) ====

<code php>
$x = match { ... };
// Equivalent to
$x = match (true) { ... };
</code>
===== Backward Incompatible Changes =====

''%%match%%'' was added as a keyword (''%%reserved_non_modifiers%%''). This means it can’t be used in the following contexts anymore:

  * namespaces
  * class names
  * function names
  * global constants

Note that it will continue to work in method names and class constants.

===== Vote =====

Voting started 2020-xx-xx and closes 2020-xx-xx.