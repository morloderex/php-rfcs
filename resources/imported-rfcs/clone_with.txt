====== PHP RFC: Clone with ======
  * Date: 2022-10-24
  * Author: Máté Kocsis <kocsismate@php.net>
  * Status: Draft
  * Target Version: PHP 8.3
  * Implementation: https://github.com/php/php-src/pull/9497

===== Introduction =====

With the advent of standards promoting "quasi-immutable" objects, like [[https://www.php-fig.org/psr/psr-7/|PSR-7]], "wither" methods became increasingly widely used. This practice is the "de facto" standard to modify the object state without altering the currently existing references to an object. A "wither" method copy-pasted from [[https://github.com/laminas/laminas-diactoros/blob/da227941abf1216f082535aacabc20759189d017/src/Response.php#L147|Diactoros]] basically looks like this:

<code php>
class Response implements ResponseInterface {
    // ...
    public function withStatus($code, $reasonPhrase = ''): Response
    {
        $new = clone $this;
        $new->setStatusCode($code, $reasonPhrase);
        return $new;
    }
    // ...
}
</code>

By using this approach, one can effectively implement immutable objects. As the "quasi" above indicates, these objects are not entirely immutable, since workarounds exist for modifying their state. As of PHP 8.1 though, [[rfc:readonly_properties_v2|PHP RFC: Readonly properties 2.0]] provides a foundational building block for preventing these workarounds: by adding the ''readonly'' modifier to a property, one can make sure that once initialized, it cannot be modified anymore. This would allow PSR-7 implementations to properly enforce their immutability.

Unfortunately, PSR-7 implementations cannot make use of readonly properties yet, unless they always instantiate a new class instance rather than using cloning as described above. This cumbersome workaround would be required because readonly properties have too strict constraints: they are readonly at the property level, while in order to be useful in practice, they should be readonly only at the object level. The former means that after initialization, a property is unmodifiable throughout its entire life span, while the latter means that it is unmodifiable during the life cycle of an object. The main difference between the two approaches is whether a property is modifiable after the object is cloned.

Since [[rfc:readonly_amendments|PHP RFC: Readonly amendments]] was (partially) accepted for PHP 8.3, readonly properties became modifiable during the execution of the ''__clone()'' magic method, allowing deep cloning of readonly properties. This was the first step towards achieving object-level readonliness, however the general problem of supporting safe modification of readonly properties was not solved yet.

===== Proposal =====

The current proposal aims to add support for a new language construct called "clone with" by extending the ''clone'' operator, that would make it possible to write "wither" methods with less code, no matter if the modified properties are readonly or not. 

Using "clone with", the above example can be rewritten as

<code php>
class Response implements ResponseInterface {
    // ...
    public function withStatus($code, $reasonPhrase = ''): Response
    {
        return clone $this with {
            code: $ode,
            reasonPhrase: $reasonPhrase
        };
    }
    // ...
}
</code>

In case of readonly properties, this syntax expresses that

Since readonly properties are now modifiable during cloning, this syntax would allow them to be reassigned without. 

===== Reflection =====

The proposal doesn't have impact for reflection.

===== Backward Incompatible Changes =====

If the proposal gets accepted, ''with'' becomes a reserved keyword.

===== Vote =====

The vote requires 2/3 majority.
